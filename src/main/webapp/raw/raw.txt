more on this later

Now that you have a SqlSessionFactory, as the name suggests, you can acquire an instance of SqlSession
The Resources class, as its name implies, helps you load resources from the classpath, filesystem or even a web URL.

The topic of Mapped SQL Statements is a big one,, and that topic will likely dominate the majority of this documentation

Namespaces are now required and have a purpose beyond simply isolating statements with longer, fully-qualified names.

Namespaces enable the interface bindings as you see here, and even if you don’t think you’ll use them today, you should follow these practices laid out here in case you change your mind. Using the namespace once, and putting it in a proper Java package namespace will clean up your code and improve the usability of MyBatis in the long term.       

. Doing so should be considered a “bad smell”. Therefore the best scope of SqlSessionFactory is application scope. This can be achieved a number of ways. The simplest is to use a Singleton pattern or Static Singleton pattern.        

 Never keep references to a SqlSession instance in a static field or even an instance field of a class. Never keep references to a SqlSession in any sort of managed scope, such as HttpSession of of the Servlet framework. If you're using a web framework of any sort, consider the SqlSession to follow a similar scope to that of an HTTP request. In other words, upon receiving an HTTP request, you can open a SqlSession, then upon returning the response, you can close it. Closing the session is very important. You should always ensure that it's closed within a finally block.

As such, --就其本身而言 technically the broadest scope of any mapper instance is the same as the SqlSession from which they were requested. 

 you might find that managing too many resources at this level will quickly get out of hand. Keep it simple, keep Mappers in the method scope


A type alias is simply a shorter name for a Java type. It's only relevant to the XML configuration and simply exists to reduce redundant typing of fully qualified classnames.

 This is due to the fact that MyBatis is unaware of the data type until the statement is executed.

Notice the key sections here: 
1.
2.。。。。

          
 Those details warrant their own section, which follows later in this section.

As mentioned 如前所述，正如, insert is a little bit more rich in that it has a few extra attributes and sub-elements that allow it to deal with key generation in a number of ways.

So already it seems to be getting verbose, but the truth is that you'll rarely set any of these.

By default, using the #{} syntax will cause MyBatis to generate PreparedStatement properties and set the values safely against the PreparedStatement parameters (e.g. ?). While this is safer, faster and almost always preferred, sometimes you just want to directly inject a string unmodified into the SQL Statement.         

 Just for example sake, let's see what this last example would look like as an external resultMap, as that is another way to solve column name mismatches.         


Now if only the world were always that simple.
Advanced Result Maps


MyBatis was created with one idea in mind: Databases aren't always what you want or need them to be. While we'd love every database to be perfect 3rd normal form or BCNF, they aren't. And it would be great if it was possible to have a single database map perfectly to all of the applications that use it, it's not. Result Maps are the answer that MyBatis provides to this problem. 

The resultMap element has a number of sub-elements and a structure worthy of some discussion

- ID argument; flagging results as ID will help improve overall performance

Always build ResultMaps incrementally， Start simple, and evolve it a step at a time。Your best bet to ensure that you're achieving the behaviour that you intend, is to write unit tests

We discussed default type handlers previously in this documentation

The collection element works almost identically to the association. In fact, it's so similar, to document the similarities would be redundant. So let's focus on the differences.

By this point, you can probably guess how nested results for a collection will work, because it's exactly the same as an association, but with the same addition of the ofType attribute applied.

 it behaves much like a switch statement in Java.

 use the FULL option with caution

Literally that's it。
The cache will use a Least Recently Used (LRU) algorithm for eviction.

MyBatis has a simple answer that will likely work in 90% of the cases.

The MyBatis Java API is where you get to reap the rewards of your efforts

Before we dive in to the Java API itself, it's important to understand the best practices surrounding directory structures. MyBatis is very flexible, and you can do almost anything with your files. But as with any framework, there's a preferred way.

Remember, these are preferences, not requirements, but others will thank you for using a common directory structure.

Many environments ship Commons Logging as a part of the application server classpath (good examples include Tomcat and WebSphere).

So to summarize,。。。。

Function time is helpful, but often inadequate

