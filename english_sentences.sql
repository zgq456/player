CREATE DATABASE  IF NOT EXISTS `english` /*!40100 DEFAULT CHARACTER SET utf8 */;
USE `english`;
-- MySQL dump 10.13  Distrib 5.6.17, for Win32 (x86)
--
-- Host: localhost    Database: english
-- ------------------------------------------------------
-- Server version	5.6.21-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `sentences`
--

DROP TABLE IF EXISTS `sentences`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sentences` (
  `id` bigint(20) NOT NULL,
  `content` varchar(255) DEFAULT NULL,
  `rank` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sentences`
--

LOCK TABLES `sentences` WRITE;
/*!40000 ALTER TABLE `sentences` DISABLE KEYS */;
INSERT INTO `sentences` VALUES (1,'infofor online information and ordering of this and other manning books, please visit www',1),(2,'the publisher offers discounts on this book when ordered in quantity',1),(3,'for more information, please contactspecial sales departmentmanning publications co',1),(4,'180 broad street, suite 1323 stamford, ct 06901 email: orders@manning',1),(5,'2011 by manning publications co',1),(6,'all rights reserved',1),(7,'no part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by means electronic, mechanical, photocopying, or otherwise, without prior written permission of the publisher',1),(8,'many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks',1),(9,'where those designations appear in the book, and manning publications was aware of a trademark claim, the designations have been printed in initial caps or all caps',1),(10,'recognizing the importance of preserving what has been written, it is manning’s policy to have the books we publish printed on acid-free paper, and we exert our best efforts to that end',1),(11,'recognizing also our responsibility to conserve the resources of our planet, manning books are printed on paper that is at least 15 percent recycled and processed without the use of elemental chlorine',1),(12,'manning publications co',1),(13,'development editor: cynthia kane 180 broad street, suite 1323 copyeditor: andy carrollstamford, ct 06901 cover designer: marija tudortypesetter: gordan salinovicisbn 978-1-935182-36-8printed in the united states of america 1 2 3 4 5 6 7 8 9 10 – mal ...',1),(14,'info to the apache camel community may this book be a helpful companion on your journeys with camel    www',1),(15,'infoviibrief contentspart 1 first steps',1),(16,'593 ■ transforming data with camel 614 ■ using beans with camel 935 ■ error handling 1206 ■ testing with camel 1547 ■ understanding components 1888 ■ enterprise integration patterns 237part 3 out in the wild',1),(17,'2819 ■ using transactions 283 10 ■ concurrency and scalability 315 11 ■ developing camel projects 359 12 ■ management and monitoring 385 13 ■ running and deploying camel 410 14 ■ bean routing and remoting 443    www',1),(18,'infoixcontentsforeword xvii foreword xix preface xxi acknowledgments xxiii about this book xxv about the cover illustration xxix about the authors xxxipart 1 first steps',1),(19,'1 introducing camel 4 what is camel',1),(20,'4 ■ why use camel',1),(21,'5 ■ getting started 8 ■ getting camel 8 ■ your first camel ride 91',1),(22,'2 camel’s message model 13 message 13 ■ exchange 141',1),(23,'3 camel’s architecture 15 architecture from 10,000 feet 15 ■ camel concepts 161',1),(24,'4 your first camel ride, revisited 201',1),(25,'1 introducing rider auto parts 232',1),(26,'2 understanding endpoints 24 working with files over ftp 24 ■ sending to a jms queue 262',1),(27,'3 creating routes in java 28 using the routebuilder 29 ■ the java dsl 302',1),(28,'4 creating routes with spring 34 bean injection and spring 34 ■ the spring dsl 37 ■ using camel and spring 402',1),(29,'5 routing and eips 43 using a content-based router 44 ■ using message filters 49using multicasting 50 ■ using recipient lists 52 ■ using the wiretap method 552',1),(30,'6 summary and best practices 57part 2 core camel',1),(31,'593 transforming data with camel 613',1),(32,'1 data transformation overview 62 data transformation with camel 623',1),(33,'2 transforming data using eips and java 63 using the message translator eip 63 ■ using the content enricher eip 703',1),(34,'3 transforming xml 73 transforming xml with xslt 73 ■ transforming xml with object marshaling 753',1),(35,'4 transforming with data formats 77 data formats provided with camel 78 ■ using camel’s csv data format 79 ■ using camel’s bindy data format 80 ■ using camel’s json data format 83 ■ configuring camel data formats 84 ■ writing your own data format 853',1),(36,'5 transforming with templates 86 using apache velocity 873',1),(37,'6 about camel type converters 88 how the camel type-converter mechanism works 88 ■ using camel type converters 90 ■ writing your own type converter 903',1),(38,'7 summary and best practices 92    www',1),(39,'infocontents xi4 using beans with camel 934',1),(40,'1 using beans the hard way and the easy way 94 invoking a bean from pure java 94 ■ invoking a bean defined in spring 95 ■ using beans the easy way 964',1),(41,'3 camel’s bean registries 98 simpleregistry 100 ■ jndiregistry 101 ■ applicationcontextregistry 101 ■ osgiserviceregistry 1024',1),(42,'4 selecting bean methods 103 how camel selects bean methods 104 ■ camel’s method-selection algorithm 105 ■ some method-selection examples 107 potential method-selection problems 1094',1),(43,'5 bean parameter binding 111 binding with multiple parameters 112 ■ binding using built-in types 113 ■ binding using camel annotations 114 ■ binding using camel language annotations 1154',1),(44,'6 summary and best practices 1195 error handling 1205',1),(45,'1 understanding error handling 121 recoverable and irrecoverable errors 121 ■ where camel’s error handling applies 1235',1),(46,'2 error handlers in camel 124 the default error handler 125 ■ the dead letter channel error handler 126 ■ the transaction error handler 128 ■ the no error handler 128 ■ the logging error handler 128 ■ features of the error handlers 1285',1),(47,'3 using error handlers with redelivery 129 an error-handling use case 129 ■ using redelivery 130 ■ error handlers and scopes 135 ■ handling faults 1375',1),(48,'4 using exception policies 138 understanding how onexception catches exceptions 139 ■ understandinghow onexception works with redelivery 142 ■ understanding how onexception can handle exceptions 143 ■ custom exception handling 146 ■ ignoring exceptio...',1),(49,'5 other error-handling features 150 using onwhen 150 ■ using onredeliver 151 ■ using retrywhile 1525',1),(50,'6 summary and best practices 153    www',1),(51,'infocontentsxii6 testing with camel 1546',1),(52,'1 introducing the camel test kit 155 the camel junit extensions 155 ■ using the camel test kit 156 unit testing with the cameltestsupport class 156 ■ unit testing an existing routebuilder class 159 ■ unit testing with the springcameltestsupport class...',1),(53,'2 using the mock component 166 introducing the mock component 167 ■ unit testing with the mock component 167 ■ verifying that the correct message arrived 169 using expressions with mocks 170 ■ testing the ordering of messages 174 ■ using mocks to sim...',1),(54,'3 simulating errors 178 simulating errors using a processor 178 ■ simulating errors using mocks 180 ■ simulating errors using interceptors 1806',1),(55,'4 testing without mocks 183 integration testing 183 ■ using notifybuilder 1856',1),(56,'5 summary and best practices 1877 understanding components 1887',1),(57,'1 overview of camel components 189 manually adding components 190 ■ autodiscovering components 1907',1),(58,'2 working with files (file and ftp components) 192 reading and writing files with the file component 193 ■ accessing remote files with the ftp component 1967',1),(59,'3 asynchronous messaging (jms component) 197 sending and receiving messages 200 ■ request-reply messaging 201 ■ message mappings 2027',1),(60,'4 web services (cxf component) 205 configuring cxf 206 ■ using a contract-first approach 209 using a code-first approach 2157',1),(61,'5 networking (mina component) 216 using mina for network programming 217 ■ using custom codecs 2197',1),(62,'6 working with databases (jdbc and jpa components) 221 accessing data with the jdbc component 221 ■ persisting objects with the jpa component 2247',1),(63,'7 in-memory messaging (direct, seda, and vm components) 229synchronous messaging with the direct component 229 asynchronous messaging with seda and vm 230    www',1),(64,'8 automating tasks (timer and quartz components) 232 using the timer component 232 ■ enterprise scheduling with quartz 2337',1),(65,'9 summary and best practices 2358 enterprise integration patterns 2378',1),(66,'1 introducing enterprise integration patterns 238 the aggregator and splitter eips 238 ■ the routing slip and dynamic router eips 239 ■ the load balancer eip 2398',1),(67,'2 the aggregator eip 239 introducing the aggregator eip 240 ■ completion conditions for the aggregator 243 ■ using persistence with the aggregator 248 using recovery with the aggregator 2518',1),(68,'3 the splitter eip 255 using the splitter 256 ■ using beans for splitting 258 ■ splitting big messages 260 ■ aggregating split messages 262 ■ when errors occur during splitting 2648',1),(69,'4 the routing slip eip 266 using the routing slip eip 267 ■ using a bean to compute the routing slip header 267 ■ using an expression as the routing slip 268 ■ using @routingslip annotation 2698',1),(70,'5 the dynamic router eip 270 using the dynamic router 270 ■ using the @dynamicrouter annotation 2718',1),(71,'6 the load balancer eip 272 introducing the load balancer eip 272 ■ load-balancing strategies 274 ■ using the failover load balancer 275 ■ using a custom load balancer 2788',1),(72,'7 summary and best practices 280part 3 out in the wild',1),(73,'2819 using transactions 2839',1),(74,'1 why use transactions',1),(75,'284 the rider auto parts partner integration application 284 ■ setting up the jms broker and the database 287 ■ the story of the lost message 2889',1),(76,'2 transaction basics 289 about spring’s transaction support 290 ■ adding transactions 291 ■ testing transactions 293    www',1),(77,'3 the transactional client eip 296 using local transactions 297 ■ using global transactions 2989',1),(78,'4 configuring and using transactions 301 configuring transactions 301 ■ using transactions with multiple routes 303 ■ returning a custom response when a transaction fails 3069',1),(79,'5 compensating for unsupported transactions 309 introducing unitofwork 309 ■ using synchronization callbacks 310 ■ using oncompletion 3129',1),(80,'6 summary and best practices 31310 concurrency and scalability 31510',1),(81,'1 introducing concurrency 316 running the example without concurrency 318 ■ using concurrency 31810',1),(82,'2 using thread pools 323 understanding thread pools in java 323 ■ camel thread pool profiles 326 ■ creating custom thread pools 328 ■ using executorservicestrategy 32910',1),(83,'3 using concurrency with eips 330 using concurrency with the threads eip 331 ■ using concurrency with the multicast eip 332 ■ using concurrency with the wire tap eip 33410',1),(84,'4 synchronicity and threading 335 asynchronous caller using one thread 336 ■ synchronous caller using one thread 337 ■ asynchronous caller using multiple threads 339 ■ synchronous caller using multiple threads 340 returning an early reply to a caller...',1),(85,'6 the asynchronous routing engine 350 hitting the scalability limit 350 ■ scalability in camel 352 components supporting asynchronous processing 353 asynchronous api 354 ■ writing a custom asynchronous component 35610',1),(86,'7 summary and best practices 358    www',1),(87,'infocontents xv11 developing camel projects 35911',1),(88,'1 managing projects with maven 360 using camel maven archetypes 360 ■ camel maven dependencies 364 ■ using camel in eclipse 366 ■ using the maven eclipse plugin 366 ■ using the m2eclipse plugin 36811',1),(89,'2 developing custom components 371 setting up a new camel component 371 ■ diving into the implementation 37311',1),(90,'3 developing interceptors 377 creating an interceptstrategy 37711',1),(91,'4 using alternative languages 380 the scala dsl 380 ■ adding scala routes to the camelcontext 382 mixing java and scala 38211',1),(92,'5 summary and best practices 38412 management and monitoring 38512',1),(93,'2 using jmx with camel 389 using jconsole to manage camel 390 ■ using jconsole to remotely manage camel 39112',1),(94,'3 tracking application activity 393 using log files 393 ■ using core logs 394 ■ using custom logging 394 ■ using tracer 398 ■ using notifications 40212',1),(95,'4 managing camel applications 405 managing camel application lifecycles 405 ■ managing custom camel components 40612',1),(96,'5 summary and best practices 40913 running and deploying camel 41013',1),(97,'1 starting camel 411 how camel starts 411 ■ camel startup options 413 ■ ordering routes 416 ■ disabling autostartup 41813',1),(98,'2 starting and stopping routes at runtime 419 using camelcontext to start and stop routes at runtime 420using routepolicy to start and stop routes at runtime 422    www',1),(99,'3 shutting down camel 424 graceful shutdown 42513',1),(100,'4 deploying camel 428 embedded in a java application 428 ■ embedded in a web application 430 ■ embedded in jboss application server 43613',1),(101,'5 camel and osgi 437 setting up maven to generate an osgi bundle 438 ■ installing and running apache karaf 439 ■ deploying the example 44013',1),(102,'6 summary and best practices 44114 bean routing and remoting 44314',1),(103,'1 using beans for routing 444 inventory update at rider auto parts 444 ■ receiving messages with @consume 445 ■ sending messages with @produce 448 when to use beans for routing 45014',1),(104,'2 hiding middleware 451 introducing the starter kit 453 ■ using spring remoting and camel proxies 45614',1),(105,'3 summary and best practices 460appendix a simple, the expression language 461 appendix b expressions and predicates 471 appendix c the producer and consumer templates 477 appendix d the camel community 483 appendix e akka and camel 487index 501    www',1),(106,'infoxviiforewordlanguages are a critical aspect of software development',1),(107,'they give us the vocabulary to express what a program should do',1),(108,'they force us to encode our requirements in precise and non-ambiguous terms',1),(109,'lastly, they enable the sharing of knowledge between developers',1),(110,'no, i’m not talking about java, haskell, or pl/1',1),(111,'i’m talking about the languages we use to communicate from human to human, from developer to developer, or from end user to product manager',1),(112,'for a long time, the world of enterprise integration (or eai, as it was commonly known in the “dark ages of integration”) lacked such a vocabulary',1),(113,'each vendor offered a proprietary solution, which not only failed to integrate at a technical level with other vendors’ offerings, but also used a different language to describe the main components and their functions',1),(114,'this not only caused confusion, but was also a key inhibitor to creating a community of developers that could span the vast space of enterprise integration',1),(115,'each “tribe” was essentially held hostage by the language bestowed upon them',1),(116,'ironically, integration developers were faced with the same “tower of babel” problem that their software was designed to solve',1),(117,'establishing a common vocabulary that enables knowledge sharing and collaboration was the key motivator for us to write enterprise integration patterns (eips)',1),(118,'each of the 65 patterns has a descriptive name, which represents the solution to a design challenge in the integration space',1),(119,'besides supporting effective communication, this vocabulary also raises the level of abstraction at which we can describe integration problems and solutions',1),(120,'a shared vocabulary is a big step forward, but a giant step we could not imagine at the time was that our language would spur the development of a whole family of open    www',1),(121,'infoforewordxviiisource messaging and enterprise service bus (esb) products',1),(122,'these tools embrace the eip vocabulary by implementing many patterns directly in the platform',1),(123,'with apache camel, a splitter pattern translates directly into a “split” element in the camel dsl',1),(124,'we couldn’t have wished for a more direct translation of the pattern language into an implementation platform',1),(125,'claus and jon bring the saga to a grand finale by showing us how to use the camel pattern language to compose real-life messaging solutions',1),(126,'in doing so, they not only cover fundamental concepts like routing and transformation, but also dig into oftenneglected parts of the development process, including testing, monitoring, and deploying',1),(127,'they find the right balance of the pattern language, camel core concepts, and running code to help you build easy-to-understand and robust messaging solutions',1),(128,'infoxixforewordi was one of the original founders of both apache activemq (an open source highperformance message broker) and servicemix (an open source esb based on jbi and osgi)',1),(129,'i found that enterprise integration patterns were becoming increasingly central to what we were doing on these projects and how we were using them; the only difference was the context and technologies with which we were using the patterns',1),(130,'there have been many libraries and frameworks over the years to help with integration',1),(131,'but frequently the concepts behind the enterprise integration patterns get transformed into some complex class hierarchies or objects that need to be wired together just so, and the original intentions and patterns are often lost',1),(132,'the developer is forced from then on to focus on the low-level detail and some complex class library api, losing the bigger picture and patterns',1),(133,'integration is hard and once you start down the path of integrating things together the code can very easily mushroom; being able to easily comprehend, communicate, adapt, and maintain integration solutions is vital to be able to solve integration pr...',1),(134,'so we decided it was time for a new integration framework that put the eips at its core and tried to raise the abstraction level so that developers could describe declaratively in very concise terms what enterprise integration patterns they wanted to...',1),(135,'using a convention over configuration approach, developers would declaratively describe what they wanted to do, using the enterprise integration pattern language; it would be both quick and easy to get things done and    www',1),(136,'infoforewordxxalso very easy for any developer on a team (including the developer himself months after writing the code',1),(137,') to understand and adapt the code',1),(138,'there are many different places we wanted to use the eips; whether in a standalone application, a web services stack, an enterprise message broker like apache activemq, or inside a full-blown esb like apache servicemix, so we wanted a lightweight fra...',1),(139,'we also wanted developers to focus on the enterprise integration patterns first and foremost and not to get lost in the weeds of different middleware apis and technologies',1),(140,'we also wanted developers to be able to use whatever dsl flavor they wished (whether java, xml, groovy, ruby, scala, or whatever) and yet, at runtime, still be able to introspect the framework and understand all of the eips that were being used',1),(141,'they would be able to visualize the core patterns to the team at any point in the project lifecycle, auto-document the patterns, or even support things like graphical editing of the enterprise integration patterns at design time or runtime',1),(142,'so apache camel was born, and since then we’ve seen the codebase, community, and number of components, technologies, and data formats grow massively as more and more developers have found apache camel an ideal way to design, implement, and maintain t...',1),(143,'in this book claus and jon describe the enterprise integration patterns and the concepts which underlie apache camel',1),(144,'then they walk you through how to take the concepts and apply them to many real-life scenarios to provide scalable and efficient solutions that are easy to understand and quick to adapt to your integration needs',1),(145,'i hope you’ll enjoy reading this book as much as i did',1),(146,'infoxxiprefacedevelopers who have done integration work know what a difficult task it can be',1),(147,'it systems may not have been designed to be accessible from other systems, and if they were designed for interoperability, they may not speak the protocol you need',1),(148,'as a developer, you end up spending a considerable amount of time working with the plumbing of the integration protocols to open up the it systems to the outside world',1),(149,'in enterprise integration patterns, gregor hohpe and bobby woolf gave us a standard way to describe, document, and implement complex integration problems',1),(150,'developers and architects alike can use this common language and catalog of solutions to tackle their integration problems',1),(151,'but although hohpe and woolf gave us the theory, the industry still needed an open source implementation of the book',1),(152,'james strachan, rob davies, guillaume nodet, and hiram chirino, within the open source communities of apache activemq and apache servicemix, brought the idea of camel to life',1),(153,'apache camel is essentially an implementation of the eip book, and in the summer of 2007 version 1',1),(154,'0 was released',1),(155,'apache camel is an integration framework whose main goal is to make integration easier',1),(156,'it implements many of the eip patterns and allows you to focus on solving business problems, freeing you from the burden of plumbing',1),(157,'using connectivity components has never been easier, because you don’t have to implement jms message listeners or ftp clients, deal with converting data between protocols, or mess with the raw details of http requests',1),(158,'all of this is taken care of by camel, which makes mediation and routing as easy as writing a few lines of java code or xml in a spring xml file',1),(159,'infoprefacexxii apache camel has since become very popular and today has an ever-growing community',1),(160,'as with many open source projects that become popular, a logical next step is for someone to write a book about the project',1),(161,'hadrian zbarcea, the project management committee chair of the apache camel project, realized this, and in early 2009 he contacted manning to discuss the need for such a book',1),(162,'hadrian got in touch with me (claus ibsen), inviting me in as a coauthor',1),(163,'it was perfect timing, as i was taking over from james strachan as the lead on apache camel',1),(164,'later that year, hadrian had to step down as an author, but he invited jonathan anstey in as his replacement, to ensure the project could continue',1),(165,'jonathan and i are both integration specialists working for fusesource, which is the professional company that offers enterprise services around various apache projects',1),(166,'this book is written by the people who wrote the camel code, which ensures you have the most updated camel book on the market',1),(167,'writing this book has been a very intense journey, proven by the fact that we were able to complete the manuscript in a year',1),(168,'it took a long time to implement the examples and to ensure that the accompanying source code is of the highest standard',1),(169,'but the result is a great source of examples that should inspire you to get the best out of camel, and it should be a good starting point for your camel projects',1),(170,'while we were writing this book, we were also implementing new features in camel, which often meant we had to go back and revise the material along the way',1),(171,'but we have kept up, and this book uses the latest camel release at the time of writing (camel 2',1),(172,'we hope this book brings great value to you and helps you prosper in the camel community',1),(173,'infoxxiiiacknowledgmentswe first want to thank cynthia kane, our development editor at manning, who put up with our many missed deadlines and gave great feedback during the writing process',1),(174,'we’d also like to thank our awesome copy editor, andy carroll, for catching an amazing number of grammatical errors in the early revisions of the book',1),(175,'the greater manning team deserves kudos as well; they’ve made for a very pleasant writing experience over the past year and a half',1),(176,'big thanks to our team of reviewers, who provided invaluable feedback during various stages of the book’s development: bruce snyder, charles moulliard, christophe avare, christopher hunt, domingo suarez torres, doug tillman, fintan bolton, gordon dic...',1),(177,'griffon, kevin jackson, marco ughetti, martin gilday, martin krasser, michael nash, mick knutson, roman kalukiewicz, tijs rademakers, and willem jiang',1),(178,'special thanks to willem jiang for being our technical proofreader, catching those bugs we missed, and helping improve the source code for the book',1),(179,'thanks to martin krasser for contributing appendix e, which is all about using camel from the akka project',1),(180,'we couldn’t think of a better person to write about camel and akka',1),(181,'we’d also like to thank hadrian zbarcea for getting this book project started—who knows when this book would have been written or by whom if he hadn’t gotten us together',1),(182,'we’d like to thank gregor hohpe and james strachan for writing the forewords to our book',1),(183,'gregor’s book, enterprise integration patterns, has been one of our favorite    www',1),(184,'infoacknowledgmentsxxivtech books for years now, so it’s an honor to have gregor on board to write the foreword',1),(185,'without the eip book, apache camel would look a lot different than it does today, if it existed at all',1),(186,'in our opinion, james is an inspiration to many developers out there—including us',1),(187,'he has co-founded tons of successful open source projects; camel is just one of them',1),(188,'if james and the other apache camel co-founders had not decided to create camel, we wouldn’t be writing this book',1),(189,'without the community, the apache camel project wouldn’t be as successful as it is today',1),(190,'in fact, without the success, both of us would have different kinds of jobs today, which wouldn’t involve hacking on camel all day along',1),(191,'clausi would like to thank my beautiful wife, christina, for her understanding of the long hours i needed to spend during evenings and weekends working on the book',1),(192,'knowing that you would never let my hand go, that the family life is safe and secure, is exactly the support any writer needs in taking up such a big challenge as writing a book',1),(193,'a warm thank you goes to our dog, bambi, who patiently sleeps in my office, and occasionally wakes up and politely “asks” me for a break and a walk',1),(194,'i must admit many of the ideas and thoughts behind this book came to me during my walks with bambi',1),(195,'joni would like to thank my amazing wife, lisa, for the patience, support, and encouragement i needed throughout the writing of this book',1),(196,'it simply would not have happened if it wasn’t for you',1),(197,'infoxxvabout this bookapache camel exists because integration is hard and camel’s creators wanted to make things easier for users',1),(198,'camel’s online documentation serves as a reference for its many features and components',1),(199,'in contrast, this book aims to guide readers through these features, starting with the simple points and building up to advanced camel usage by the end of the book',1),(200,'throughout the book, camel’s features are put into action in real-life scenarios',1),(201,'roadmapthe book is divided into three parts:■ part 1—first steps ■ part 2—core camel ■ part 3—out in the wildpart 1 starts off simple by introducing you to camel’s core functionality and concepts, and it presents some basic examples',1),(202,'■ chapter 1 introduces you to camel and explains what camel is and where it fits into the bigger enterprise software picture',1),(203,'you’ll also learn the concepts and terminology of camel',1),(204,'■ chapter 2 covers camel’s main feature, which is message routing',1),(205,'the java dsl and spring dsl are covered as are several enterprise integration patterns (eips)',1),(206,'eips are basically canned solutions to integration problems',1),(207,'infoabout this bookxxvibuilding on part 1’s foundation, part 2 covers the core features of camel',1),(208,'you’ll need many of these features when using camel',1),(209,'■ chapter 3 explains how camel can help you transform your data to different formats while it’s being routed',1),(210,'■ in chapter 4 we take a look at how you can use java beans in camel',1),(211,'■ chapter 5 covers all of camel’s error-handling features',1),(212,'■ in chapter 6 we look at the testing facilities shipped with camel',1),(213,'you can use these features for testing your own camel applications or applications based on other stacks',1),(214,'■ chapter 7 covers the most heavily used components among camel’s large selection of components',1),(215,'■ chapter 8 looks in depth at five of the most complex eips',1),(216,'in part 3 we cover the topics that are useful when you’ve gained a better understanding of camel from the earlier chapters',1),(217,'■ chapter 9 explains how you can use transactions in your camel applications',1),(218,'■ in chapter 10 we discuss how to deal with concurrency and scalability in your camel applications',1),(219,'■ chapter 11 explains how to create new camel projects, which could be camel applications, custom components, or interceptors',1),(220,'this chapter doesn’t require much additional camel knowledge, so you could read this right after part 1',1),(221,'the scala dsl is also touched on here',1),(222,'among other things, how to read the camel logs and how to control camel with jmx are covered',1),(223,'■ in chapter 13 we discuss the many ways to start and stop camel',1),(224,'deployment to several of the most popular containers is also discussed',1),(225,'■ chapter 14 covers what we consider extra features of camel: routing with beans and using remoting to hide camel apis',1),(226,'we consider this extra because these features do routing without using any of camel’s dsls and in some cases with no camel apis',1),(227,'they take a different approach than what was discussed throughout the book',1),(228,'the appendixes at the end of the book contain useful reference material on the simple expression language, expressions and predicates, the producer and consumer templates, and the camel community',1),(229,'appendix e is written by martin krasser and shows how to use akka with camel',1),(230,'who should read this bookwe wrote this book primarily for developers who have found the online camel documentation lacking and needed a guidebook that explained things in a more detailed and organized way',1),(231,'although we mainly targeted existing camel users, camel in action    www',1),(232,'infoabout this book xxviiis a great way to start learning about camel',1),(233,'experienced engineers and architects are also encouraged to read this book, as it explains advanced camel concepts that you just can’t find elsewhere',1),(234,'test and q&a engineers will find camel and this book useful as a means of driving tests that require communication with various transports and apis',1),(235,'system administrators, too, may find the management, monitoring, and deployment topics of great value',1),(236,'camel’s features are focused on the enterprise business community and its needs, but it’s also a generic and very useful integration toolkit',1),(237,'any java developer who needs to send a message somewhere will probably find camel and this book useful',1),(238,'code conventionsthe code examples in this book are abbreviated in the interest of space',1),(239,'in particular, some of the namespace declarations in the xml configurations and package imports in java classes have been omitted',1),(240,'we encourage you to use the source code when working with the examples',1),(241,'the line lengths of some of the examples exceed the page width, and in cases like these, the',1),(242,'marker is used to indicate that a line has been wrapped for formatting',1),(243,'all source code in listings or in text is in a fixed-width font like this to separate it from ordinary text',1),(244,'code annotations accompany many of the listings, highlighting important concepts',1),(245,'in some cases, numbered bullets link to explanations that follow the listing',1),(246,'source code downloadsthe source code for the examples in this book is available online from the publisher’s website at http://www',1),(247,'com/camelinaction, as well as from this site: http:// code',1),(248,'software requirementsthe following software is required to run the examples:■ jdk 5 or better■ maven 2',1),(249,'5 or betterapache camel can be downloaded from its official website: http://camel',1),(250,'all the examples can be run using maven',1),(251,'chapter 1 shows you how to get started with maven and run the examples',1),(252,'author onlinethe purchase of camel in action includes free access to a private web forum run by manning publications, where you can make comments about the book, ask technical questions, and receive help from the authors and from other users',1),(253,'to access the forum and    www',1),(254,'infoabout this bookxxviiisubscribe to it, point your web browser to http://www',1),(255,'this page provides information on how to get on the forum once you’re registered, what kind of help is available, and the rules of conduct on the forum',1),(256,'manning’s commitment to our readers is to provide a venue where a meaningful dialogue between individual readers and between readers and the authors can take place',1),(257,'it is not a commitment to any specific amount of participation on the part of the authors, whose contribution to the forum remains voluntary (and unpaid)',1),(258,'we suggest you try asking the authors some challenging questions, lest their interest stray',1),(259,'the author online forum and the archives of previous discussions will be accessible from the publisher’s website as long as the book is in print',1),(260,'infoxxixabout the cover illustrationthe illustration on the cover of camel in action bears the caption “a bedouin,” and is taken from a collection of costumes of the ottoman empire published on january 1, 1802, by william miller of old bond street, l...',1),(261,'the title page is missing from the collection and we have been unable to track it down to date',1),(262,'the book’s table of contents identifies the figures in both english and french, and each illustration also bears the names of two artists who worked on it, both of whom would no doubt be surprised to find their art gracing the front cover of a comput...',1),(263,'200 years later',1),(264,'the collection was purchased by a manning editor at an antiquarian flea market in the “garage” on west 26th street in manhattan',1),(265,'the seller was an american based in ankara, turkey, and the transaction took place just as he was packing up his stand for the day',1),(266,'the manning editor did not have on his person the substantial amount of cash that was required for the purchase and a credit card and check were both politely turned down',1),(267,'with the seller flying back to ankara that evening, the situation was getting hopeless',1),(268,'what was the solution',1),(269,'it turned out to be nothing more than an oldfashioned verbal agreement sealed with a handshake',1),(270,'the seller simply proposed that the money be transferred to him by wire and the editor walked out with the bank information on a piece of paper and the portfolio of images under his arm',1),(271,'needless to say, we transferred the funds the next day, and we remain grateful and impressed by this unknown person’s trust in one of us',1),(272,'it recalls something that might have happened a long time ago',1),(273,'infoabout the cover illustrationxxx the pictures from the ottoman collection, like the other illustrations that appear on our covers, bring to life the richness and variety of dress customs of two centuries ago',1),(274,'they recall the sense of isolation and distance of that period—and of every other historic period except our own hyperkinetic present',1),(275,'dress codes have changed since then and the diversity by region, so rich at the time, has faded away',1),(276,'it is now often hard to tell the inhabitant of one continent from another',1),(277,'perhaps, trying to view it optimistically, we have traded a cultural and visual diversity for a more varied personal life',1),(278,'or a more varied and interesting intellectual and technical life',1),(279,'we at manning celebrate the inventiveness, the initiative, and, yes, the fun of the computer business with book covers based on the rich diversity of regional life of two centuries ago',1),(280,'brought back to life by the pictures from this collection',1),(281,'infoxxxiabout the authorsclaus ibsen has worked as a software engineer and architect for more than 13 years',1),(282,'he has often worked with integration in various forms, from integrating with legacy systems on as/400s to building custom in-house integration frameworks',1),(283,'claus has designed and architected a large solution for custom clearance for the district of shanghai, china',1),(284,'he tracks the trends in the open source integration space and it led him to camel in late 2007',1),(285,'he currently holds a position as principal software engineer at fusesource, as project lead on apache camel',1),(286,'claus has ambitions to pick up speaking engagements, so you will likely be able to catch up with him at various conferences',1),(287,'claus lives in sweden near malmo with his wife and dog, which is spoiled as the only child in the family',1),(288,'he is danish by nationality',1),(289,'jonathan anstey is a software engineer with varied experience in manufacturing control systems, build infrastructure, and enterprise integration',1),(290,'he got involved in the apache camel project in early 2008 and hasn’t looked back since',1),(291,'most recently, jon has been working on apache camel and other apache open source projects at fusesource',1),(292,'when jon is not hacking on camel, he likes to spend time with his wife and daughter in st',1),(293,'john’s, newfoundland',1),(294,'infopart 1first stepsapache camel is an open source integration framework that aims to make integrating systems easier',1),(295,'in the first chapter of this book we’ll introduce you to camel and show you how it fits into the bigger enterprise software picture',1),(296,'you’ll also learn the concepts and terminology of camel',1),(297,'chapter 2 focuses on one of camel’s most important features: message routing',1),(298,'camel has two main ways of defining routing rules: the java-based domainspecific language (dsl) and the spring xml configuration format',1),(299,'in addition to these route-creation techniques, we’ll show you how to design and implement solutions to enterprise integration problems using enterprise integration patterns (eips) and camel',1),(300,'info3meeting camelbuilding complex systems from scratch is a very costly endeavor, and one that’s almost never successful',1),(301,'an effective and less risky alternative is to assemble a system like a jigsaw puzzle from existing, proven components',1),(302,'we depend daily on a multitude of such integrated systems, making possible everything from phone communications, financial transactions, and healthcare to travel planning and entertainment',1),(303,'you can’t finalize a jigsaw puzzle until you have a complete set of pieces that plug into each other simply, seamlessly, and robustly',1),(304,'that holds true for system integration projects as well',1),(305,'but whereas jigsaw puzzle pieces are made to plug into each other, the systems we integrate rarely are',1),(306,'integration frameworks aim to fill this gap',1),(307,'as an integrator, you’re less concerned about how the system you integrate works and more focused on how to interoperate with it from the outside',1),(308,'a good integration framework provides simple, manageable abstractions for the complex systems you’re integrating and the “glue” for plugging them together seamlessly',1),(309,'apache camel is such an integration framework',1),(310,'in this book, we’ll help you understand what camel is, how to use it, and why we think it’s one of the best integration frameworks out there',1),(311,'this chapter covers■ an introduction to camel■ camel’s main features■ your first camel ride■ camel’s architecture and concepts    www',1),(312,'info4 chapter 1 meeting camel this chapter will start off by introducing camel and highlighting some of its core features',1),(313,'we’ll then take a look at the camel distribution and explain how you can run the camel examples in the book',1),(314,'we’ll round off the chapter by bringing core camel concepts to the table so you can understand camel’s architecture',1),(315,'let’s meet camel',1),(316,'1 introducing camelcamel is an integration framework that aims to make your integration projects productive and fun',1),(317,'the camel project was started in early 2007, but although it’s relatively young, camel is already a mature open source project, available under the liberal apache 2 license, and it has a strong community',1),(318,'camel’s focus is on simplifying integration',1),(319,'we’re confident that by the time you finish reading these pages, you’ll appreciate camel and add it to your “must have” list of tools',1),(320,'the apache camel project was named camel simply because the name is short and easy to remember',1),(321,'rumor has it the name may be inspired by the fact that one of the founders once smoked camel cigarettes',1),(322,'at the camel website a faq entry (http://camel',1),(323,'html) lists other lighthearted reasons for the name',1),(324,'1 what is camel',1),(325,'at the core of the camel framework is a routing engine, or more precisely a routingengine builder',1),(326,'it allows you to define your own routing rules, decide from which sources to accept messages, and determine how to process and send those messages to other destinations',1),(327,'camel uses an integration language that allows you to define complex routing rules, akin to business processes',1),(328,'one of the fundamental principles of camel is that it makes no assumptions about the type of data you need to process',1),(329,'this is an important point, because it gives you, the developer, an opportunity to integrate any kind of system, without the need to convert your data to a canonical format',1),(330,'camel offers higher-level abstractions that allow you to interact with various systems using the same api regardless of the protocol or data type the systems are using',1),(331,'components in camel provide specific implementations of the api that target different protocols and data types',1),(332,'out of the box, camel comes with support for over 80 protocols and data types',1),(333,'its extensible and modular architecture allows you to implement and seamlessly plug in support for your own protocols, proprietary or not',1),(334,'these architectural choices eliminate the need for unnecessary conversions and make camel not only faster but also very lean',1),(335,'as a result, it’s suitable for embedding into other projects that require camel’s rich processing capabilities',1),(336,'other open source projects, such as apache servicemix and activemq, already use camel as a way to carry out enterprise integration',1),(337,'we should also mention what camel isn’t',1),(338,'camel isn’t an enterprise service bus (esb), although some call camel a lightweight esb because of its support for routing, transformation, monitoring, orchestration, and so forth',1),(339,'camel doesn’t have a    www',1),(340,'info5introducing camelcontainer or a reliable message bus, but it can be deployed in one, such as openesb or the previously mentioned servicemix',1),(341,'for that reason, we prefer to call camel an integration framework rather than an esb',1),(342,'to understand what camel is, it helps to look at its main features',1),(343,'so let’s take a look at them',1),(344,'2 why use camel',1),(345,'camel introduces a few novel ideas into the integration space, which is why its authors decided to create camel in the first place, instead of using an existing framework',1),(346,'we’ll explore the rich set of camel features throughout the book, but these are the main ideas behind camel:let’s dive into the details of each of these features',1),(347,'routing and mediation enginethe core feature of camel is its routing and mediation engine',1),(348,'a routing engine will selectively move a message around, based on the route’s configuration',1),(349,'in camel’s case, routes are configured with a combination of enterprise integration patterns and a domain-specific language, both of which we’ll describe next',1),(350,'enterprise integration patterns (eips)although integration problems are diverse, gregor hohpe and bobby woolf noticed that many problems and their solutions are quite similar',1),(351,'they cataloged them in their book enterprise integration patterns, a must-read for any integration professional (http://www',1),(352,'enterpriseintegrationpatterns',1),(353,'if you haven’t read it, we encourage you to do so',1),(354,'at the very least, it will help you understand camel concepts faster and easier',1),(355,'the enterprise integration patterns, or eips, are helpful not only because they provide a proven solution for a given problem, but also because they help define and communicate the problem itself',1),(356,'patterns have known semantics, which makes communicating problems much easier',1),(357,'the difference between using a pattern language and describing the problem at hand is similar to using spoken language rather than sign language',1),(358,'if you’ve ever visited a foreign country, you’ve probably experienced the difference',1),(359,'camel is heavily based on eips',1),(360,'although eips describe integration problems and solutions and also provide a common vocabulary, the vocabulary isn’t formalized',1),(361,'camel tries to close this gap by providing a language to describe the integration solutions',1),(362,'there’s almost a one-to-one relationship between the patterns described in enterprise integration patterns and the camel dsl',1),(363,'■ routing and mediation engine ■ enterprise integration patterns (eips)■ domain-specific language (dsl) ■ extensive component library■ payload-agnostic router ■ modular and pluggable architecture■ pojo model ■ easy configuration ■ automatic type conv...',1),(364,'info6 chapter 1 meeting cameldomain-specific language (dsl)camel’s domain-specific language (dsl) is a major contribution to the integration space',1),(365,'a few other integration frameworks currently feature a dsl (and some allow you to use xml to describe routing rules), but unlike camel their dsls are based on custom languages',1),(366,'camel is unique because it offers multiple dsls in regular programming languages such as java, scala, groovy, and it also allows routing rules to be specified in xml',1),(367,'the purpose of the dsl is to allow the developer to focus on the integration problem rather than on the tool—the programming language',1),(368,'although camel is written mostly in java, it does support mixing multiple programming languages',1),(369,'each language has its own strengths, and you may want to use different languages for different tasks',1),(370,'you have the freedom to build a solution your own way with as few constraints as possible',1),(371,'here are some examples of the dsl using different languages and staying functionally equivalent:■ java dsl from(\"file:data/inbox\")',1),(372,'to(\"jms:queue:order\");■ spring dsl <route>  <from uri=\"file:data/inbox\"/>  <to uri=\"jms:queue:order\"/> </route>■ scala dsl from \"file:data/inbox\" -> \"jms:queue:order\"these examples are real code, and they show how easily you can route files from a fo...',1),(373,'because there’s a real programming language underneath, you can use the existing tooling support, such as code completion and compiler error detection, as illustrated in figure 1',1),(374,'1 camel dsls use real programming languages like java, so you can use existing tooling support',1),(375,'info7introducing camelhere you can see how the eclipse ide’s autocomplete feature can give us a list of dsl terms that are valid to use',1),(376,'extensive component librarycamel provides an extensive library of more than 80 components',1),(377,'these components enable camel to connect over transports, use apis, and understand data formats',1),(378,'payload-agnostic routercamel can route any kind of payload—you aren’t restricted to carrying xml payloads',1),(379,'this freedom means that you don’t have to transform your payload into a canonical format to facilitate routing',1),(380,'modular and pluggable architecturecamel has a modular architecture, which allows any component to be loaded into camel, regardless of whether the component ships with camel, is from a third party, or is your own custom creation',1),(381,'pojo modelbeans (or pojos) are considered first-class citizens in camel, and camel strives to let you use beans anywhere and anytime in your integration projects',1),(382,'this means that in many places you can extend camel’s built-in functionality with your own custom code',1),(383,'chapter 4 has a complete discussion of using beans within camel',1),(384,'easy configurationthe convention over configuration paradigm is followed whenever possible, which minimizes configuration requirements',1),(385,'in order to configure endpoints directly in routes, camel uses an easy and intuitive uri configuration',1),(386,'for example, you could configure a file consumer to scan recursively in a subfolder and include only a',1),(387,'txt file, as follows:from(\"file:data/inbox',1),(388,'recursive=true&include=*',1),(389,'automatic type converterscamel has a built-in type-converter mechanism that ships with more than 150 converters',1),(390,'you no longer need to configure type-converter rules to go from byte arrays to strings, for example',1),(391,'and if you find a need to convert to types that camel doesn’t support, you can create your own type converter',1),(392,'the best part is that it works under the hood, so you don’t have to worry about it',1),(393,'the camel components also leverage this feature; they can accept data in most types and convert the data to a type they’re capable of using',1),(394,'this feature is one of the top favorites in the camel community',1),(395,'you may even start wondering why it wasn’t provided in java itself',1),(396,'chapter 3 covers more about type converters',1),(397,'lightweight corecamel’s core can be considered pretty lightweight, with the total library coming in at about 1',1),(398,'6 mb and only having a dependency on apache commons logging and fusesource commons management',1),(399,'this makes camel easy to embed or deploy anywhere you like, such as in a standalone application, web application, spring application, java    www',1),(400,'camel was designed not to be a server or esb but instead to be embedded in whatever platform you choose',1),(401,'test kit camel provides a test kit that makes it easier for you to test your own camel applications',1),(402,'the same test kit is used extensively to test camel itself, and it includes more than 6,000 unit tests',1),(403,'the test kit contains test-specific components that, for example, can help you mock real endpoints',1),(404,'it also contains setup expectations that camel can use to determine whether an application satisfied the requirements or failed',1),(405,'chapter 6 covers testing with camel',1),(406,'vibrant communitycamel has an active community',1),(407,'this is essential if you intend to use any open source project in your application',1),(408,'inactive projects have little community support, so if you run into issues, you’re on your own',1),(409,'with camel, if you’re having any trouble, users and developers alike will come to your aid promptly',1),(410,'for more information on camel’s community, see appendix d',1),(411,'now that you’ve seen the main features that make up camel, we’ll get a bit more hands on by looking at the camel distribution and trying out an example',1),(412,'2 getting startedin this section, we’ll show you how to get your hands on a camel distribution, explain what’s inside, and then run an example using apache maven',1),(413,'after this, you’ll know how to run any of the examples from the book’s source code',1),(414,'let’s first get the camel distribution',1),(415,'1 getting camelcamel is available from the official apache camel website at http:// camel',1),(416,'on that page you’ll see a list of all the camel releases and also the downloads for the latest release',1),(417,'for the purposes of this book, we’ll be using camel 2',1),(418,'to get this version, click on the camel 2',1),(419,'0 release link and near the bottom of the page you’ll find two binary distributions: the zip distribution is for windows users, and the tar',1),(420,'gz distribution is for unix/linux/cygwin users',1),(421,'when you’ve downloaded one of the distributions, extract it to a location on your hard drive',1),(422,'open up a command prompt, and go to the location where you extracted the camel distribution',1),(423,'issuing a directory listing here will give you something like this:janstey@mojo:~/apache-camel-2',1),(424,'0$ ls doc  examples  lib  license',1),(425,'txtas you can see, the distribution is pretty small, and you can probably guess what each directory contains already',1),(426,'here are the details:    www',1),(427,'info9getting started■ doc—contains the camel manual in pdf and html formats',1),(428,'this user guide is a download of a large portion of the apache camel wiki at the time of release',1),(429,'as such, it’s a great reference for those not able to browse to the camel website',1),(430,'■ examples—includes 27 camel examples',1),(431,'you’ll see an example shortly',1),(432,'■ lib—contains all camel libraries and third-party dependencies needed for the core of camel to run',1),(433,'you’ll see later in the chapter how maven can be used to easily grab dependencies for the components outside the core',1),(434,'txt—contains the license of the camel distribution',1),(435,'because this is an apache project, the license is the apache license, version 2',1),(436,'txt—contains copyright information about the third-party dependencies included in the camel distribution',1),(437,'txt—contains a short intro to what camel is and a list of helpful links to get new users up and running fast',1),(438,'now let’s try out one of the camel examples',1),(439,'2 your first camel rideso far, we’ve shown you how to get a camel distribution and we’ve explored what’s inside',1),(440,'at this point, feel free to explore the distribution; all examples have instructions to help you figure them out',1),(441,'from this point on, though, we won’t be using the distribution at all',1),(442,'the examples in the book’s source all use apache maven, which means that camel libraries will be downloaded automatically for you—there’s no need to make sure the camel distribution’s libraries are on the path, for example',1),(443,'you can get the book’s source code from either the book’s website, at http:// manning',1),(444,'com/ibsen or from the google code project that’s hosting the source: http://code',1),(445,'the first example we’ll look at can be considered the “hello world” of integrations: routing files',1),(446,'suppose you need to read files from one directory (data/inbox), process them in some way, and write the result to another directory (data/outbox)',1),(447,'for simplicity, you’ll skip the processing, so your output will be merely a copy of the original file',1),(448,'2 illustrates this process',1),(449,'it looks pretty simple, right',1),(450,'here’s a possible solution using pure java (with no camel)',1),(451,'public class filecopier {    public static void main(string args[]) throws exception {        file inboxdirectory = new file(\"data/inbox\");        file outboxdirectory = new file(\"data/outbox\");listing 1',1),(452,'1 routing files from one folder to another in plain javafiledata/inbox data/outboxfigure 1',1),(453,'2 files are routed from the data/inbox directory to the data/outbox directory',1),(454,'mkdir();        file[] files = inboxdirectory',1),(455,'listfiles();        for (file source : files) {            if (source',1),(456,'isfile()) {               file dest = new file(                    outboxdirectory',1),(457,'getpath()                    + file',1),(458,'separator                    + source',1),(459,'getname());               copyfile(source, dest);            }        }    }    private static void copyfile(file source, file dest)        throws ioexception {        outputstream out = new fileoutputstream(dest);        byte[] buffer = new byte[(in...',1),(460,'length()];        fileinputstream in = new fileinputstream(source);        in',1),(461,'close();            in',1),(462,'close();        }    } }the filecopier example in listing 1',1),(463,'1 is a pretty simple use case, but it still results in 34 lines of code',1),(464,'you have to use low-level file apis and ensure that resources get closed properly, a task that can easily go wrong',1),(465,'also, if you wanted to poll the data/ inbox directory for new files, you’d need to set up a timer and also keep track of which files you’ve already copied',1),(466,'this simple example is getting more complex',1),(467,'integration tasks like these have been done thousands of times before—you shouldn’t ever need to code something like this by hand',1),(468,'let’s not reinvent the wheel here',1),(469,'let’s see what a polling solution looks like if you use an integration framework like apache camel',1),(470,'public class filecopierwithcamel {    public static void main(string args[]) throws exception {        camelcontext context = new defaultcamelcontext();        context',1),(471,'addroutes(new routebuilder() {            public void configure() {                from(\"file:data/inbox',1),(472,'stop();    } }listing 1',1),(473,'2 routing files from one folder to another with apache camelb routes files from inbox to outbox    www',1),(474,'info11getting startedmost of this code is boilerplate stuff when using camel',1),(475,'every camel application uses a camelcontext that’s subsequently started and then stopped',1),(476,'you also add a sleep method to allow your simple camel application time to copy the files',1),(477,'what you should really focus on in listing 1',1),(478,'2 is the route b',1),(479,'routes in camel are defined in such a way that they flow when read',1),(480,'this route can be read like this: consume messages from file location data/inbox with the noop option set, and send to file location data/outbox',1),(481,'the noop option tells camel to leave the source file as is',1),(482,'if you didn’t use this option, the file would be moved',1),(483,'most people who have never seen camel before will be able to understand what this route does',1),(484,'you may also want to note that, excluding the boilerplate code, you created a file-polling route in just one line of java code b',1),(485,'to run this example, you’ll need to download and install apache maven from the maven site at http://maven',1),(486,'once you have maven up and working, open a terminal and browse to the chapter1/file-copy directory of the book’s source',1),(487,'if you take a directory listing here, you’ll see several things: ■ data—contains the inbox directory, which itself contains a single file named message1',1),(488,'■ src—contains the source code for the listings shown in this chapter',1),(489,'xml—contains information necessary to build the examples',1),(490,'this is the maven project object model (pom) xml file',1),(491,'note we used maven 2',1),(492,'newer versions of maven may not work or appear exactly as we’ve shown',1),(493,'the pom is shown here',1),(494,'<project xmlns=\"http://maven',1),(495,'0\"  xmlns:xsi=\"http://www',1),(496,'org/2001/xmlschema-instance\"  xsi:schemalocation=\"http://maven',1),(497,'org/xsd/maven-4',1),(498,'xsd\">  <modelversion>4',1),(499,'0</modelversion>  <parent>                                         <groupid>com',1),(500,'camelinaction</groupid>    <artifactid>chapter1</artifactid>    <version>1',1),(501,'0</version>  </parent>  <artifactid>file-copy</artifactid>  <name>camel in action :: chapter 1 :: file copy example</name>  <dependencies>    <dependency>      <groupid>org',1),(502,'camel</groupid>      <artifactid>camel-core</artifactid>              <version>${camel-version}</version>    </dependency>  </dependencies> </project>listing 1',1),(503,'3 the maven pom required to use camel’s core libraryparent pombcamel’s core libraryc    www',1),(504,'info12 chapter 1 meeting camelmaven itself is a complex topic, and we won’t go into great detail here',1),(505,'we’ll give you enough information to be productive with the examples in this book',1),(506,'we’ll also discuss using maven to develop camel applications in chapter 11, so there’s a good deal of information there too',1),(507,'the maven pom in listing 1',1),(508,'3 is probably one of the shortest poms you’ll ever see—almost everything uses the defaults provided by maven',1),(509,'besides those defaults, there are also some settings configured in the parent pom b',1),(510,'probably the most important section to point out here is the dependency on the camel library c',1),(511,'this dependency element tells maven to do the following:1 create a search path based on the groupid, artifactid, and version',1),(512,'the version element is set to the camel-version property, which is defined in the pom referenced in the parent element b, and will resolve to 2',1),(513,'the type of dependency was not specified, so the jar file type will be assumed',1),(514,'the search path will be org/apache/camel/camel-core/2',1),(515,'2 because listing 1',1),(516,'3 defined no special places for maven to look for the camel dependencies, it will look in maven’s central repository, located at http:// repo1',1),(517,'3 combining the search path and the repository url, maven will try to download http://repo1',1),(518,'4 this jar will be saved to maven’s local download cache, which is typically located in the home directory under',1),(519,'m2/repository',1),(520,'this would be ~/',1),(521,'m2/repository on linux/unix and c:\\documents and settings\\<username>\\',1),(522,'m2\\ repository on windows xp, and c:\\users\\<username>\\',1),(523,'m2\\repository on windows vista/7',1),(524,'5 when the application code in listing 1',1),(525,'2 is started, the camel jar will be added to the classpath',1),(526,'to run the example in listing 1',1),(527,'2, use the following command:mvn compile exec:java -dexec',1),(528,'mainclass=camelinaction',1),(529,'filecopierwithcamelthis instructs maven to compile the source in the src directory and to execute the filecopierwithcamel class with the camel-core jar on the classpath',1),(530,'note in order to run any of the examples in this book you’ll need an internet connection',1),(531,'a broadband speed connection is preferable because apache maven will download many jar dependencies of the examples, some of which are large',1),(532,'the whole set of examples will download about 140 mb of libraries',1),(533,'run the maven command from the chapter1/file-copy directory, and after it completes, browse to the data/outbox folder to see the file copy that has just been made',1),(534,'congratulations, you’ve just run your first camel example',1),(535,'it was a simple example, but knowing how it’s set up will enable you to run pretty much any of the book’s examples',1),(536,'info13camel’s message model we now need to cover some camel basics and the integration space in general to ensure that you’re well prepared for using camel',1),(537,'we’ll turn our attention to the message model, the architecture, and a few other camel concepts',1),(538,'most of the abstractions are based on known service-oriented architecture (soa) and eip concepts and retain their names and semantics',1),(539,'we’ll start with camel’s message model',1),(540,'3 camel’s message modelin camel, there are two abstractions for modeling messages, both of which we’ll cover in this section',1),(541,'message—the fundamental entity containing the data being carried and routed in camel■ org',1),(542,'exchange—the camel abstraction for an exchange of messages',1),(543,'this exchange of messages has an “in” message and as a reply, an “out” messagewe’ll start by looking at message to understand how data is modeled and carried in camel',1),(544,'then we’ll look at how a “conversation” is modeled in camel by the exchange',1),(545,'1 messagemessages are the entities used by systems to communicate with each other when using messaging channels',1),(546,'messages flow in one direction from a sender to a receiver, as illustrated in figure 1',1),(547,'messages have a body (a payload), headers, and optional attachments, as illustrated in figure 1',1),(548,'messages are uniquely identified with an identifier of type java',1),(549,'the identifier’s uniqueness is enforced and guaranteed by the message creator, it’s protocol dependent, and it doesn’t have a guaranteed format',1),(550,'for protocols that don’t define a unique message identification scheme, camel uses its own uid generator',1),(551,'headers and attachmentsheaders are values associated with the message, such as sender identifiers, hints about content encoding, authentication information, and so on',1),(552,'headers are name-value pairs; the name is a unique, case-insensitive string, and the value is of type java',1),(553,'this means that camel imposes no constraints on the type of the headers',1),(554,'headers are stored as a map within the message',1),(555,'a message can also have optional attachments, which are typically used for the web service and email components',1),(556,'sender receivermessagefigure 1',1),(557,'3 messages are entities used to send data from one system to another',1),(558,'headersattachmentsbodymessagefigure 1',1),(559,'4a message can contain headers, attachments, and a body',1),(560,'info14 chapter 1 meeting camelbodythe body is of type java',1),(561,'that means that a message can store any kind of content',1),(562,'it also means that it’s up to the application designer to make sure that the receiver can understand the content of the message',1),(563,'when the sender and receiver use different body formats, camel provides a number of mechanisms to transform the data into an acceptable format, and in many cases the conversion happens automatically with type converters, behind the scenes',1),(564,'fault flagmessages also have a fault flag',1),(565,'some protocols and specifications, such as wsdl and jbi, distinguish between output and fault messages',1),(566,'they’re both valid responses to invoking an operation, but the latter indicates an unsuccessful outcome',1),(567,'in general, faults aren’t handled by the integration infrastructure',1),(568,'they’re part of the contract between the client and the server and are handled at the application level',1),(569,'during routing, messages are contained in an exchange',1),(570,'2 exchangean exchange in camel is the message’s container during routing',1),(571,'an exchange also provides support for the various types of interactions between systems, also known as message exchange patterns (meps)',1),(572,'meps are used to differentiate between one-way and request-response messaging styles',1),(573,'the camel exchange holds a pattern property that can be either■ inonly—a one-way message (also known as an event message)',1),(574,'for example, jms messaging is often one-way messaging',1),(575,'■ inout—a request-response message',1),(576,'for example, http-based transports are often request reply, where a client requests to retrieve a web page, waiting for the reply from the server',1),(577,'5 illustrates the contents of an exchange in camel',1),(578,'let’s look at the elements of figure 1',1),(579,'5 in more detail:■ exchange id—a unique id that identifies the exchange',1),(580,'camel will generate a default unique id, if you don’t explicitly set one',1),(581,'■ mep—a pattern that denotes whether you’re using the inonly or inout messaging style',1),(582,'when the pattern is inonly, the exchange contains an in message',1),(583,'for inout, an out message also exists that contains the reply message for the caller',1),(584,'exchangeheadersattachmentsbodyout messageheadersattachmentsbodyin messageexchange id mepexception propertiesfigure 1',1),(585,'5 a camel exchange has an id, mep, exception, and properties',1),(586,'it also has an in message to store the incoming message and an out message to store the result',1),(587,'info15camel’s architecture■ exception—if an error occurs at any time during routing, an exception will be set in the exception field',1),(588,'■ properties—similar to message headers, but they last for the duration of the entire exchange',1),(589,'properties are used to contain global-level information, whereas message headers are specific to a particular message',1),(590,'camel itself will add various properties to the exchange during routing',1),(591,'you, as a developer, can store and retrieve properties at any point during the lifetime of an exchange',1),(592,'■ in message—this is the input message, which is mandatory',1),(593,'the in message contains the request message',1),(594,'■ out message—this is an optional message that only exists if the mep is inout',1),(595,'the out message contains the reply message',1),(596,'we discussed camel’s message model before the architecture because we wanted you to have a solid understanding of what a message is in camel',1),(597,'after all, the most important aspect of camel is routing messages',1),(598,'you’re now well prepared to learn more about camel and its architecture',1),(599,'4 camel’s architecturelet’s now turn our attention to camel’s architecture',1),(600,'we’ll first take a look at the highlevel architecture and then drill down into the specific concepts',1),(601,'after you’ve read this section, you should be caught up on the integration lingo and be ready for chapter 2, where we’ll explore camel’s routing capabilities',1),(602,'1 architecture from 10,000 feetwe think that architectures are best viewed first from high above',1),(603,'6 shows a high-level view of the main concepts that make up camel’s architecture',1),(604,'content-based routerprocessor message filter processor',1),(605,'camelcontextfile http jmsroute 1route 2route nfrom(\"file:c:\\dir\")',1),(606,'xpath(expression)',1),(607,'to(\"jms :aqueue\");components',1),(608,'connect to other systemsprocessorshandle things inbetween endpoints like',1),(609,'transformation',1),(610,'interceptionrouting enginea dsl wiresendpoints andprocessorstogether to form routes',1),(611,'6 at a high level, camel is composed of processors, components, and routes',1),(612,'all of these are contained within the camelcontext',1),(613,'info16 chapter 1 meeting camelthe routing engine uses routes as specifications for where messages are routed',1),(614,'routes are defined using one of camel’s domain-specific languages (dsls)',1),(615,'processors are used to transform and manipulate messages during routing and also to implement all the eip patterns, which have corresponding keywords in the dsl languages',1),(616,'components are the extension points in camel for adding connectivity to other systems',1),(617,'to expose these systems to the rest of camel, components provide an endpoint interface',1),(618,'with that high-level view out of the way, let’s take a closer look at the individual concepts in figure 1',1),(619,'2 camel conceptsfigure 1',1),(620,'6 revealed many new concepts, so let’s take some time to go over them one by one',1),(621,'we’ll start with the camelcontext, which is camel’s runtime',1),(622,'camelcontextyou may have guessed that the camelcontext is a container of sorts, judging from figure 1',1),(623,'you can think of it as camel’s runtime system, which keeps all the pieces together',1),(624,'7 shows the most notable services that the camelcontext keeps together',1),(625,'as you can see from figure 1',1),(626,'7, there are a lot of services for the camelcontext to keep track of',1),(627,'these are described in table 1',1),(628,'the details of each of these services will be discussed throughout the book',1),(629,'let’s now take a look at routes and camel’s routing engine',1),(630,'1 the services that the camelcontext providesservice descriptioncomponents contains the components used',1),(631,'camel is capable of loading components on the fly either by autodiscovery on the classpath or when a new bundle is activated in an osgi container',1),(632,'in chapter 7 we’ll discuss components in more detail',1),(633,'endpoints contains the endpoints that have been created',1),(634,'routes contains the routes that have been added',1),(635,'we’ll cover routes in chapter 2',1),(636,'type converterscontains the loaded type converters',1),(637,'camel has a mechanism that allows you to manually or automatically convert from one type to another',1),(638,'type converters are covered in chapter 3',1),(639,'data formats contains the loaded data formats',1),(640,'data formats are covered in chapter 3',1),(641,'componentscamelcontextendpoints routestypeconvertersregistrydata formatslanguagesfigure 1',1),(642,'7 the camelcontext provides access to many useful services, the most notable being components, type converters, a registry, endpoints, routes, data formats, and languages',1),(643,'info17camel’s architecturerouting enginecamel’s routing engine is what actually moves messages under the hood',1),(644,'this engine isn’t exposed to the developer, but you should be aware that it’s there and that it does all the heavy lifting, ensuring that messages are routed properly',1),(645,'routesroutes are obviously a core abstraction for camel',1),(646,'the simplest way to define a route is as a chain of processors',1),(647,'there are many reasons for using routers in messaging applications',1),(648,'by decoupling clients from servers, and producers from consumers, routes can■ decide dynamically what server a client will invoke■ provide a flexible way to add extra processing■ allow for clients and servers to be developed independently■ allow for ...',1),(649,'routes also have exactly one input source for messages, so they’re effectively tied to an input endpoint',1),(650,'to define a route, a dsl is used',1),(651,'domain-specific language (dsl)to wire processors and endpoints together to form routes, camel defines a dsl',1),(652,'the term dsl is used a bit loosely here',1),(653,'in camel, dsl means a fluent java api that contains methods named for eip terms',1),(654,'consider this example:from(\"file:data/inbox\")',1),(655,'xpath(\"/order[not(@test)]\")',1),(656,'to(\"jms:queue:order\")here, in a single java statement, you define a route that consumes files from a file endpoint',1),(657,'messages are then routed to the filter eip, which will use an xpath predicate toregistry contains a registry that allows you to look up beans',1),(658,'by default, this will be a jndi registry',1),(659,'if you’re using camel from spring, this will be the spring applicationcontext',1),(660,'it can also be an osgi registry if you use camel in an osgi container',1),(661,'we’ll cover registries in chapter 4',1),(662,'languages contains the loaded languages',1),(663,'camel allows you to use many different languages to create expressions',1),(664,'you’ll get a glimpse of the xpath language in action when we cover the dsl',1),(665,'a complete reference to camel’s own simple expression language is available in appendix a',1),(666,'1 the services that the camelcontext provides (continued)service description    www',1),(667,'info18 chapter 1 meeting cameltest whether the message is a test order or not',1),(668,'if a message passes the test, it’s forwarded to the jms endpoint',1),(669,'messages failing the filter test will be dropped',1),(670,'camel provides multiple dsl languages, so you could define the same route using the spring dsl, like this:<route>  <from uri=\"file:data/inbox\"/>  <filter>    <xpath>/order[not(@test)]</xpath>    <to uri=\"jms:queue:order\"/>  </filter> </route>the dsls...',1),(671,'under the hood, though, a route is actually composed of a graph of processors',1),(672,'let’s take a moment to see what a processor really is',1),(673,'processorthe processor is a core camel concept that represents a node capable of using, creating, or modifying an incoming exchange',1),(674,'during routing, exchanges flow from one processor to another; as such, you can think of a route as a graph having specialized processors as the nodes, and lines that connect the output of one processor to the input of another',1),(675,'many of the processors are implementations of eips, but one could easily implement their own custom processor and insert it into a route',1),(676,'so how do exchanges get in or out of this processor graph',1),(677,'to find out, we’ll need to look at both components and endpoints',1),(678,'componentcomponents are the main extension point in camel',1),(679,'to date, there are over 80 components in the camel ecosystem that range in function from data transports, to dsls, data formats, and so on',1),(680,'you can even create your own components for camel—we’ll discuss this in chapter 11',1),(681,'from a programming point of view, components are fairly simple: they’re associated with a name that’s used in a uri, and they act as a factory of endpoints',1),(682,'for example, a filecomponent is referred to by file in a uri, and it creates fileendpoints',1),(683,'the endpoint is perhaps an even more fundamental concept in camel',1),(684,'endpointan endpoint is the camel abstraction that models the end of a channel through which a system can send or receive messages',1),(685,'this is illustrated in figure 1',1),(686,'data messageendpointsenderapplicationreceiverapplicationmessageendpointdatamessage channelfigure 1',1),(687,'8an endpoint acts as a neutral interface allowing systems to integrate',1),(688,'info19camel’s architecturein camel, you configure endpoints using uris, such as file:data/inbox',1),(689,'delay=5000, and you also refer to endpoints this way',1),(690,'at runtime, camel will look up an endpoint based on the uri notation',1),(691,'9 shows how this works',1),(692,'the scheme b denotes which camel component handles that type of endpoint',1),(693,'in this case, the scheme of file selects the filecomponent',1),(694,'the filecomponent then works as a factory creating the fileendpoint based on the remaining parts of the uri',1),(695,'the context path data/ inbox c tells the filecomponent that the starting folder is data/inbox',1),(696,'the option, delay=5000 d indicates that files should be polled at a 5 second interval',1),(697,'there’s more to an endpoint than meets the eye',1),(698,'10 shows how an endpoint works together with an exchange, producers, and consumers',1),(699,'at first glance, figure 1',1),(700,'10 may seem a bit overwhelming, but it will all make sense in a few minutes',1),(701,'in a nutshell, an endpoint acts as a factory for creating consumers and producers that are capable of receiving and sending messages to a particular endpoint',1),(702,'we didn’t mention producers or consumers in the high-level view of camel in figure 1',1),(703,'producera producer is the camel abstraction that refers to an entity capable of creating and sending a message to an endpoint',1),(704,'10 illustrates where the producer fits in with other camel concepts',1),(705,'when a message needs to be sent to an endpoint, the producer will create an exchange and populate it with data compatible with that particular endpoint',1),(706,'for example, a fileproducer will write the message body to a file',1),(707,'a jmsproducer, on the other hand, will map the camel message to a javax',1),(708,'message before sending it to a jms destination',1),(709,'this is an important feature in camel, because it hides the complexity of interacting with particular transports',1),(710,'all you need to do is route a message to an endpoint, and the producer does the heavy lifting',1),(711,'delay=5000scheme context path optionsb c dfigure 1',1),(712,'9 endpoint uris are divided into three parts: a scheme, a context path, and options',1),(713,'endpoint exchangeconsumer producerprocessorcreatescreates createscreatesusesuses usesfigure 1',1),(714,'10 how endpoints work with producers, consumers, and an exchange    www',1),(715,'info20 chapter 1 meeting camelconsumera consumer is the service that receives messages produced by a producer, wraps them in an exchange, and sends them to be processed',1),(716,'consumers are the source of the exchanges being routed in camel',1),(717,'10, we can see where the consumer fits in with other camel concepts',1),(718,'to create a new exchange, a consumer will use the endpoint that wraps the payload being consumed',1),(719,'a processor is then used to initiate the routing of the exchange in camel using the routing engine',1),(720,'in camel there are two kinds of consumers: event-driven consumers and polling consumers',1),(721,'the differences between these consumers are important, because they help solve different problems',1),(722,'event-driven consumerthe most familiar consumer is probably the event-driven consumer, which is illustrated in figure 1',1),(723,'this kind of consumer is mostly associated with client-server architectures and web services',1),(724,'it’s also referred to as an asynchronous receiver in the eip world',1),(725,'an event-driven consumer listens on a particular messaging channel, usually a tcp/ip port or a jms queue, and waits for a client to send messages to it',1),(726,'when a message arrives, the consumer wakes up and takes the message for processing',1),(727,'polling consumerthe other kind of consumer is the polling consumer illustrated in figure 1',1),(728,'in contrast to the event-driven consumer, the polling consumer actively goes and fetches messages from a particular source, such as an ftp server',1),(729,'the polling consumer is also known as a synchronous receiver in eip lingo, because it won’t poll for more messages until it has finished processing the current message',1),(730,'a common flavor of the polling consumer is the scheduled polling consumer, which polls at scheduled intervals',1),(731,'file, ftp, and email transports all use scheduled polling consumers',1),(732,'we’ve now covered all of camel’s core concepts',1),(733,'with this new knowledge, you can revisit your first camel ride and see what’s really happening',1),(734,'5 your first camel ride, revisitedrecall that in your first camel ride (section 1',1),(735,'2), you read files from one directory (data/inbox) and wrote the results to another directory (data/outbox)',1),(736,'now that you know the core camel concepts, you can put this example in perspective',1),(737,'senderevent drivenconsumermessagereceiverfigure 1',1),(738,'11 an event-driven consumer waits idle until a message arrives, at which point it wakes up and consumes the message',1),(739,'senderpollingconsumermessagereceiverfigure 1',1),(740,'12 a polling consumer actively checks for new messages',1),(741,'public class filecopierwithcamel {    public static void main(string args[]) throws exception {        camelcontext context = new defaultcamelcontext();        context',1),(742,'addroutes(new routebuilder() {            public void configure() {                from(\"file:data/inbox',1),(743,'stop();    } }in this example, you first create a camelcontext, which is the camel runtime',1),(744,'you then add the routing logic using a routebuilder and the java dsl b',1),(745,'by using the dsl, you can cleanly and concisely let camel instantiate components, endpoints, consumers, producers, and so on',1),(746,'all you have to focus on is defining the routes that matter for your integration projects',1),(747,'under the hood, though, camel is accessing the filecomponent, and using it as a factory to create the endpoint and its producer',1),(748,'the same filecomponent is used to create the consumer side as well',1),(749,'6 summaryin this chapter you met camel',1),(750,'you saw how camel simplifies integration by relying on known eips',1),(751,'you also saw camel’s dsl, which aims to make camel code self documenting and keeps developers focused on what the glue code does, not how it does it',1),(752,'we covered camel’s main features, what camel is and isn’t, and where it can be used',1),(753,'we looked at how camel provides abstractions and an api that work over a large range of protocols and data formats',1),(754,'at this point, you should have a good understanding of what camel does and what the concepts behind camel are',1),(755,'soon you’ll be able to confidently browse camel applications and get a good idea of what they do',1),(756,'in the rest of the book, we’ll explore camel’s features and give you practical solutions you can apply in everyday integration scenarios',1),(757,'we’ll also explain what’s going on under camel’s tough skin',1),(758,'to make sure that you get the main concepts from each chapter, from now on we’ll present you with a number of best practices and key points in the summary',1),(759,'in the next chapter, we’ll investigate routing, which is an essential feature and a fun one to learn',1),(760,'listing 1',1),(761,'4 routing files from one folder to another with apache camelb java dsl route    www',1),(762,'info22routing with camelone of the most important features of camel is routing; without it, camel would essentially be a library of transport connectors',1),(763,'in this chapter, we’ll dive into routing with camel',1),(764,'routing happens in many aspects of everyday life',1),(765,'when you mail a letter, for instance, it may be routed through several cities before reaching its final address',1),(766,'an email you send will be routed through many different computer network systems before reaching its final destination',1),(767,'in all cases, the router’s function is to selectively move the message forward',1),(768,'in the context of enterprise messaging systems, routing is the process by which a message is taken from an input queue and, based on a set of conditions, sent to one of several output queues, as shown in figure 2',1),(769,'this effectively means that thethis chapter covers■ an overview of routing■ introducing the rider auto parts scenario■ the basics of ftp and jms endpoints■ creating routes using the java dsl■ configuring routes from spring■ routing using enterprise i...',1),(770,'info23introducing rider auto partsinput and output queues are unaware of the conditions in between them',1),(771,'the conditional logic is decoupled from the message consumer and producer',1),(772,'in apache camel, routing is a more general concept',1),(773,'it’s defined as a step-by-step movement of the message, which originates from an endpoint in the role of a consumer',1),(774,'the consumer could be receiving the message from an external service, polling for the message on some system, or even creating the message itself',1),(775,'this message then flows through a processing component, which could be an enterprise integration pattern (eip), a processor, an interceptor, or some other custom creation',1),(776,'the message is finally sent to a target endpoint that’s in the role of a producer',1),(777,'a route may have many processing components that modify the message or send it to another location, or it may have none, in which case it would be a simple pipeline',1),(778,'in this chapter, we’ll first introduce the fictional company that we’ll use as the running example throughout the book',1),(779,'to support this company’s use case, you’ll learn how to communicate over ftp and java message service (jms) using camel’s endpoints',1),(780,'following this, we’ll look in depth at the java-based domain-specific language (dsl) and the spring-based configuration format for creating routes',1),(781,'we’ll also give you a glimpse of how to design and implement solutions to enterprise integration problems using eips and camel',1),(782,'by the end of the chapter, you’ll be proficient enough to create useful routing applications with camel',1),(783,'to start, let’s look at the example company that we’ll use to demonstrate the concepts throughout the book',1),(784,'1 introducing rider auto partsour fictional motorcycle parts business, rider auto parts, supplies parts to motorcycle manufacturers',1),(785,'over the years, they’ve changed the way they receive orders several times',1),(786,'initially, orders were placed by uploading comma-separated value (csv) files to an ftp server',1),(787,'the message format was later changed to xml',1),(788,'currently they provide a website through which orders are submitted as xml messages over http',1),(789,'rider auto parts asks new customers to use the web interface to place orders, but because of service level agreements (slas) with existing customers, they must keep all the old message formats and interfaces up and running',1),(790,'all of these messages are converted to an internal plain old java object (pojo) format before processing',1),(791,'a highlevel view of the order processing system is shown in figure 2',1),(792,'inqueuemessage routeroutqueue1outqueue2figure 2',1),(793,'1 a message router consumes messages from an input channel and, depending on a set of conditions, sends the message to one of a set of output channels',1),(794,'info24 chapter 2 routing with camelrider auto parts faces a pretty common problem: over years of operation, they have acquired software baggage in the form of transports and data formats that were popular at the time',1),(795,'this is no problem for an integration framework like camel, though',1),(796,'in this chapter, and throughout the book, you’ll help rider auto parts implement their current requirements and new functionality using camel',1),(797,'as a first assignment, you’ll need to implement the ftp module in the rider order frontend system',1),(798,'later in the chapter, you’ll see how backend services are implemented too',1),(799,'implementing the ftp module will involve the following steps:1 polling the ftp server and downloading new orders2 converting the order files to jms messages3 sending the messages to the jms incomingorders queueto complete steps 1 and 3, you’ll need t...',1),(800,'to complete the entire assignment, you’ll need to understand routing with the java dsl',1),(801,'let’s first take a look at how you can use camel’s endpoints',1),(802,'2 understanding endpointsas you read in chapter 1, an endpoint is an abstraction that models the end of a message channel through which a system can send or receive messages',1),(803,'in this section, we’re going to explain how you can use uris to configure camel to communicate over ftp and jms',1),(804,'let’s first look at ftp',1),(805,'1 working with files over ftpone of the things that make camel easy to use is the endpoint uri',1),(806,'by specifying a uri, you can identify the component you want to use and how that component is configured',1),(807,'you can then decide to either send messages to the component configured by this uri, or to consume messages from it',1),(808,'take your first rider auto parts assignment, for example',1),(809,'to download new orders from the ftp server, you need to do the following:rider auto parts webstoreuserftphttprider orderfrontendrider orderbackendjmsfigure 2',1),(810,'2 a customer has two ways of submitting orders to the rider auto parts order-handling system: either by uploading the raw order file to an ftp server or by submitting an order through the rider auto parts web store',1),(811,'all orders are eventually sent via jms for processing at rider auto parts',1),(812,'info25understanding endpoints1 connect to the rider',1),(813,'com ftp server on the default ftp port of 212 provide a username of “rider” and password of “secret”3 change the directory to “orders”4 download any new order filesas shown in figure 2',1),(814,'3, you can easily configure camel to do this by using uri notation',1),(815,'camel will first look up the ftp scheme in the component registry, which will resolve to the ftpcomponent',1),(816,'the ftpcomponent then works as a factory, creating the ftpendpoint based on the remaining context path and options',1),(817,'com/orders tells the ftpcomponent that it should log into the ftp server at rider',1),(818,'com on the default ftp port and change the directory to “orders”',1),(819,'finally, the only options specified are username and password, which are used to log in to the ftp server',1),(820,'tip for the ftp component, you can also specify the username and password in the context path of the uri',1),(821,'so the following uri is equivalent to the one in figure 2',1),(822,'3: ftp://rider:secret@rider',1),(823,'the ftpcomponent isn’t part of the camel-core module, so you have to add an additional dependency to your project',1),(824,'using maven you just have to add the following dependency to the pom:<dependency>  <groupid>org',1),(825,'camel</groupid>  <artifactid>camel-ftp</artifactid>  <version>2',1),(826,'0</version> </dependency>although this endpoint uri would work equally well in a consumer or producer scenario, you’ll be using it to download orders from the ftp server',1),(827,'to do so, you need to use it in a from node of camel’s dsl:from(\"ftp://rider',1),(828,'username=rider&password=secret\")that’s all you need to do to consume files from an ftp server',1),(829,'the next thing you need to do, as you may recall from figure 2',1),(830,'2, is send the orders you downloaded from the ftp server to a jms queue',1),(831,'this process requires a little more setup, but it’s still easy',1),(832,'username rider&password secretscheme context path optionsfigure 2',1),(833,'3 a camel endpoint uri consists of three parts: a scheme, a context path, and a list of options',1),(834,'2 sending to a jms queuecamel provides extensive support for connecting to jms-enabled providers, and we’ll cover all the details in chapter 7',1),(835,'for now, though, we’re just going to cover enough so that you can complete your first task for rider auto parts',1),(836,'recall that you need to download orders from an ftp server and send them to a jms queue',1),(837,'jms (java message service) is a java api that allows you to create, send, receive, and read messages',1),(838,'it also mandates that messaging is asynchronous and has specific elements of reliability, like guaranteed and once-and-only-once delivery',1),(839,'jms is the de facto messaging solution in the java community',1),(840,'in jms, message consumers and producers talk to one another through an intermediary—a jms destination',1),(841,'as shown in figure 2',1),(842,'4, a destination can be either a queue or a topic',1),(843,'queues are strictly point-to-point, where each message has only one consumer',1),(844,'topics operate on a publish/subscribe scheme; a single message may be delivered to many consumers if they have subscribed to the topic',1),(845,'jms also provides a connectionfactory that clients (like camel) can use to create a connection with a jms provider',1),(846,'jms providers are usually referred to as brokers because they manage the communication between a message producer and a message consumer',1),(847,'how to configure camel to use a jms providerto connect camel to a specific jms provider, you need to configure camel’s jms component with an appropriate connectionfactory',1),(848,'apache activemq is one of the most popular open source jms providers, and it’s the primary jms broker that the camel team uses to test the jms component',1),(849,'as such, we’ll be using it to demonstrate jms concepts within the book',1),(850,'for more information on apache activemq, we recommend activemq in action by bruce snyder, dejan bosanac, and rob davies, available from manning publications',1),(851,'client a client bqueueclient cclient dtopicsubscribesdeliversclient esubscribesdeliversconsumessendspublishesfigure 2',1),(852,'4 there are two types of jms destinations: queues and topics',1),(853,'the queue is a point-to-point channel, where each message has only one recipient',1),(854,'a topic delivers a copy of the message to all clients who have subscribed to receive it',1),(855,'info27understanding endpointsso in the case of apache activemq, you can create an activemqconnectionfactory that points to the location of the running activemq broker:connectionfactory connectionfactory =  new activemqconnectionfactory(\"vm://localhos...',1),(856,'the vm transport connector in activemq creates a broker on demand if one isn’t running already, so it’s very handy for quickly testing jms applications; for production scenarios, it’s recommended that you connect to a broker that’s already running',1),(857,'furthermore, in production scenarios we recommend that connection pooling be used when connecting to a jms broker',1),(858,'see chapter 7 for details on these alternate configurations',1),(859,'next, when you create your camelcontext, you can add the jms component as follows:camelcontext context = new defaultcamelcontext(); context',1),(860,'addcomponent(\"jms\",    jmscomponent',1),(861,'jmscomponentautoacknowledge(connectionfactory));the jms component and the activemq-specific connection factory aren’t part of the camel-core module',1),(862,'in order to use these, you’ll need to add some dependencies to your maven-based project',1),(863,'for the plain jms component, all you have to add is this:<dependency>  <groupid>org',1),(864,'camel</groupid>  <artifactid>camel-jms</artifactid>  <version>2',1),(865,'0</version> </dependency>the connection factory comes directly from activemq, so you’ll need the following dependency:<dependency>  <groupid>org',1),(866,'activemq</groupid>  <artifactid>activemq-core</artifactid>  <version>5',1),(867,'2</version> </dependency>now that you’ve configured the jms component to connect to an actual jms broker, it’s time to look at how uris can be used to specify the destination',1),(868,'using uris to specify the destinationonce the jms component is configured, you can start sending and receiving jms messages at your leisure',1),(869,'because you’re using uris, this is a real breeze to configure',1),(870,'let’s say you want to send a jms message to the queue named incomingorders',1),(871,'the uri in this case would bejms:queue:incomingordersthis is pretty self-explanatory',1),(872,'the “jms” prefix indicates that you’re using the jms component you configured before',1),(873,'by specifying “queue”, the jms component knows    www',1),(874,'info28 chapter 2 routing with camelto send to a queue named incomingorders',1),(875,'you could even have omitted the queue qualifier, because the default behavior is to send to a queue rather than a topic',1),(876,'note some endpoints can have an intimidating list of endpoint uri properties',1),(877,'for instance, the jms component has about 60 options, many of which are only used in specific jms scenarios',1),(878,'camel always tries to provide built-in defaults that fit most cases, and you can always find out what the default values are by browsing to the component’s page in the online camel documentation',1),(879,'the jms component is discussed here: http://camel',1),(880,'using camel’s java dsl, you can send a message to the incomingorders queue by using the to keyword like this:',1),(881,'to(\"jms:queue:incomingorders\")this can be read as sending to the jms queue named incomingorders',1),(882,'now that you know the basics of communicating over ftp and jms with camel, you can get back to the routing theme of this chapter and start routing some messages',1),(883,'3 creating routes in javain chapter 1, you saw how each camelcontext can contain multiple routes and also how a routebuilder could be used to create a route',1),(884,'it may not have been obvious, though, that the routebuilder isn’t the final route that the camelcontext will use at runtime; it’s a builder of one or more routes, which are then added to the camelcontext',1),(885,'this is illustrated in figure 2',1),(886,'the addroutes method of the camelcontext accepts a routesbuilder, not just a routebuilder',1),(887,'the routesbuilder interface has a single method defined:void addroutestocamelcontext(camelcontext context) throws exception;this means that you could use your own custom class to build camel routes',1),(888,'the most common way to build routes, though, is to use the routebuilder class, which implements routesbuilder',1),(889,'the routebuilder class also gives you access to camel’s java dsl for route creation',1),(890,'in the next sections, you’ll learn how to use a routebuilder and the java dsl to create simple routes',1),(891,'once you know that, you’ll be well prepared to take on the spring dsl in section 2',1),(892,'4 and routing using eips in section 2',1),(893,'5 routebuilders are used to create routes in camel',1),(894,'info29creating routes in java2',1),(895,'1 using the routebuilderthe abstract org',1),(896,'routebuilder class in camel is one that you’ll see frequently',1),(897,'you’ll need to use it any time you create a route in java',1),(898,'to use the routebuilder class, you extend a class from it and implement the configure method, like this:class myroutebuilder extends routebuilder {    public void configure() throws exception {',1),(899,'} }you then need to add the class to the camelcontext with the addroutes method:camelcontext context = new defaultcamelcontext(); context',1),(900,'addroutes(new myroutebuilder());alternatively, you can combine the routebuilder and camelcontext configuration by adding an anonymous routebuilder class directly into the camelcontext, like this:camelcontext context = new defaultcamelcontext(); context',1),(901,'addroutes(new routebuilder() {    public void configure() throws exception {',1),(902,'} });within the configure method, you define your routes using the java dsl',1),(903,'we’ll discuss the java dsl in detail in the next section, but you can start a route now to get an idea of how it works',1),(904,'in chapter 1, you should have downloaded the source code from the book’s website and set up apache maven',1),(905,'if you didn’t do this, please do so now',1),(906,'change to the chapter2/ftp-jms directory in your terminal, and type this command:mvn eclipse:eclipsethis will generate an eclipse project file',1),(907,'note eclipse is a popular open source ide that you can find at http:// eclipse',1),(908,'during the book’s development, we used eclipse 3',1),(909,'when the command has completed, you can import this project by selecting file > import > existing projects into workspace in the eclipse menus and selecting the chapter2/ftp-jms directory',1),(910,'for more information on developing camel projects in eclipse, see chapter 11',1),(911,'note you don’t need an ide to use camel, but it does make it a lot easier',1),(912,'feel free to skip to the next section if you don’t want to see the ide-related setup',1),(913,'when the ftp-jms project is loaded in eclipse, open the src/main/java/camelinaction/ routebuilderexample',1),(914,'as shown in figure 2',1),(915,'info30 chapter 2 routing with camel(ctrl-space in eclipse) in the configure method, you’ll be presented with a number of methods',1),(916,'to start a route, you should use the from method',1),(917,'the from method accepts an endpoint uri as an argument',1),(918,'you can add a ftp endpoint uri to connect to rider auto parts’ order server as follows:from(\"ftp://rider',1),(919,'username=rider&password=secret\")the from method returns a routedefinition object, on which you can invoke a number of different methods that implement eips and other messaging concepts',1),(920,'congratulations, you’re now using camel’s java dsl',1),(921,'let’s take a closer look at what’s going on here',1),(922,'2 the java dsldomain-specific languages (dsls) are computer languages that target a specific problem domain, rather than a general purpose domain like most programming languages',1),(923,'for example, you have probably used the regular expression dsl to match strings of text and found it to be a clear and concise way of matching strings',1),(924,'doing the same string matching in java wouldn’t be so easy',1),(925,'the regular expression dsl is an external dsl—it has a custom syntax and so requires a separate compiler or interpreter to execute',1),(926,'internal dsls, in contrast, use an existing general purpose language, such as java, in such a way that the dsl feels like a language from a particular domain',1),(927,'the most obvious way of doing this is by naming methods and arguments to match concepts from the domain in question',1),(928,'another popular way of implementing internal dsls is by using fluent interfaces (aka fluent builders)',1),(929,'when using a fluent interface, you build up objects with methods that perform an operation and then return the current object instance; another method is then invoked on this object instance, and so on',1),(930,'6 use autocomplete to start your route',1),(931,'all routes start with a from method',1),(932,'info31creating routes in javanote for more information on internal dsls, see martin fowler’s “domain specific language” entry on his bliki (blog plus wiki) at http://www',1),(933,'he also has an entry on “fluent interfaces” at http://www',1),(934,'for more information on dsls in general, we recommend dsls in action by debasish ghosh, available from manning publications',1),(935,'camel’s domain is enterprise integration, so the java dsl is essentially a set of fluent interfaces that contain methods named after terms from the eip book',1),(936,'in the eclipse editor, take a look at what is available using autocomplete after a from method in the routebuilder',1),(937,'you should see something like what’s shown in figure 2',1),(938,'the screenshot shows several eips—pipeline, enricher, and recipient list—and there are many others that we’ll discuss later',1),(939,'for now, select the to method and finish the route with a semicolon',1),(940,'each java statement that starts with a from method in the routebuilder creates a new route',1),(941,'this new route now completes your first task at rider auto parts—consuming orders from an ftp server and sending them to the incomingorders jms queue',1),(942,'if you want, you can load up the completed example from the book’s source code, in chapter2/ftp-jms and open src/main/java/camelinaction/ftptojmsexample',1),(943,'the code is shown in listing 2',1),(944,'7 after the from method, use your ide’s autocomplete feature to get a list of eips (such as pipeline, enricher, and recipient list) and other useful integration functions',1),(945,'jmscomponent; import org',1),(946,'defaultcamelcontext;public class ftptojmsexample {    public static void main(string args[]) throws exception {        camelcontext context = new defaultcamelcontext();        connectionfactory connectionfactory =            new activemqconnectionfac...',1),(947,'addcomponent(\"jms\",            jmscomponent',1),(948,'jmscomponentautoacknowledge(connectionfactory));        context',1),(949,'addroutes(new routebuilder() {            public void configure() {                from(\"ftp://rider',1),(950,'com/orders\"                           + \"',1),(951,'username=rider&password=secret\")',1),(952,'to(\"jms:incomingorders\");                      }        });        context',1),(953,'stop();    } }note because you’re consuming from ftp://rider',1),(954,'com, which doesn’t exist, you can’t run this example',1),(955,'it’s only useful for demonstrating the java dsl constructs',1),(956,'for runnable ftp examples, please see chapter 7',1),(957,'as you can see, this listing includes a bit of boilerplate setup and configuration, but the actual solution to the problem is concisely defined within the configure method as a single java statement b',1),(958,'the from method tells camel to consume messages from an ftp endpoint, and the to method instructs camel to send messages to a jms endpoint',1),(959,'the flow of messages in this simple route can be viewed as a basic pipeline, where the output of the consumer is fed into the producer as input',1),(960,'this is depicted in figure 2',1),(961,'listing 2',1),(962,'1 polling for ftp messages and sending them to the incomingorders queueb java statement that forms a routerouteconsumer producerjms queueimplicittypeconversionftp serverfigure 2',1),(963,'8 the route shown in listing 2',1),(964,'1 forms a simple pipeline',1),(965,'the output of the ftp consumer is fed into the input of the jms producer',1),(966,'the payload conversion from file to jms message is done automatically',1),(967,'info33creating routes in javaone thing you may have noticed is that we didn’t do any conversion from the ftp file type to the jms message type—this was done automatically by camel’s typeconverter facility',1),(968,'you can force type conversions to occur at any time during a route, but often you don’t have to worry about them at all',1),(969,'data transformation and type conversion is covered in detail in chapter 3',1),(970,'you may be thinking now that although this route is nice and simple, it would be really nice to see what’s going on in the middle of the route',1),(971,'fortunately, camel always lets the developer stay in control by providing ways to hook into flows or inject behavior into features',1),(972,'there is a pretty simple way of getting access to the message by using a processor, and we’ll discuss that next',1),(973,'adding a processorthe processor interface in camel is an important building block of complex routes',1),(974,'it’s a simple interface, having a single method:public void process(exchange exchange) throws exception;this gives you full access to the message exchange, letting you do pretty much whatever you want with the payload or headers',1),(975,'all eips in camel are implemented as processors',1),(976,'you can even add a simple processor to your route inline, like so:from(\"ftp://rider',1),(977,'username=rider&password=secret\")',1),(978,'process(new processor() {    public void process(exchange exchange) throws exception {        system',1),(979,'println(\"we just downloaded: \"            + exchange',1),(980,'to(\"jms:incomingorders\");this route will now print out the filename of the order that was downloaded before sending it to the jms queue',1),(981,'by adding this processor into the middle of the route, you’ve effectively added it to the conceptual pipeline we mentioned earlier, as illustrated in figure 2',1),(982,'the output of the ftp consumer is fed into the processor as input; the processor doesn’t modify the message payload or headers, so the exchange moves on to the jms producer as input',1),(983,'note many components, like the filecomponent and the ftpcomponent, set useful headers describing the payload on the incoming message',1),(984,'in the previous example, you used the camelfilename header to retrieve the filename of the file that was downloaded via ftp',1),(985,'the component pages of the online documentation contain information about the headers set for each individual component',1),(986,'camel’s main method for creating routes is through the java dsl',1),(987,'it is, after all, built into the camel-core module',1),(988,'there are other ways of creating routes though, some of which may better suit your situation',1),(989,'for instance, camel provides extensions for writing routes in groovy, scala, and, as we’ll discuss next, spring xml',1),(990,'4 creating routes with springspring is the most popular inversion of control (ioc) java container out there',1),(991,'the core framework allows to you “wire” beans together to form applications',1),(992,'this wiring is done through an xml configuration file',1),(993,'in this section, we’ll give you a quick introduction to creating applications with spring',1),(994,'for a more comprehensive view of spring, we recommend spring in action, by craig walls (http://www',1),(995,'com/walls4/)',1),(996,'we’ll then go on to show you how camel uses spring to form a replacement or complementary solution to the java dsl',1),(997,'1 bean injection and springcreating an application from beans using spring is pretty simple',1),(998,'all you need are a few java beans (classes), a spring xml configuration file, and an applicationcontext',1),(999,'the applicationcontext is similar to the camelcontext, in that it’s the runtime container for spring',1),(1000,'let’s look at a simple example',1),(1001,'consider an application that prints out a greeting followed by your username',1),(1002,'in this application you don’t want the greeting to be hardcoded, so you can use an interface to break this dependency',1),(1003,'consider the following interface:public interface greeter {    public string sayhello(); }this interface is implemented by the following classes:public class englishgreeter implements greeter {    public string sayhello() {        return \"hello \" + s...',1),(1004,'getproperty(\"user',1),(1005,'name\");    } } public class danishgreeter implements greeter {    public string sayhello() {        return \"davs \" + system',1),(1006,'getproperty(\"user',1),(1007,'name\");    } }you can now create a greeter application as follows:public class greetmebean {    private greeter greeter;    public void setgreeter(greeter greeter) {        this',1),(1008,'greeter = greeter;    }routeconsumer producerftp serverjms queueprocessorfigure 2',1),(1009,'9 with a processor in the mix, the output of the ftp consumer is now fed into the processor, and then the output of the processor is fed into the jms producer',1),(1010,'info35creating routes with spring    public void execute() {        system',1),(1011,'sayhello());    } }this application will output a different greeting depending on how you configure it',1),(1012,'to configure this application using spring, you could do something like this:<beans xmlns=\"http://www',1),(1013,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(1014,'org/2001/xmlschema-instance\"       xsi:schemalocation=\"       http://www',1),(1015,'org/schema/beans       http://www',1),(1016,'org/schema/beans/spring-beans-3',1),(1017,'xsd\">  <bean id=\"mygreeter\" class=\"camelinaction',1),(1018,'englishgreeter\"/>  <bean id=\"greetmebean\" class=\"camelinaction',1),(1019,'greetmebean\">    <property name=\"greeter\" ref=\"mygreeter\"/>  </bean></beans> this xml file instructs spring to do the following:1 create an instance of englishgreeter and names the bean mygreeter2 create an instance of greetmebean and names the bean ...',1),(1020,'in order to load this xml file into spring, you can use the classpathxmlapplicationcontext, which is a concrete implementation of the applicationcontext that’s provided with the spring framework',1),(1021,'this class loads spring xml files from a location specified on the classpath',1),(1022,'here is the final version of greetmebean:public class greetmebean {',1),(1023,'public static void main(string[] args) {        applicationcontext context =            new classpathxmlapplicationcontext(\"beans',1),(1024,'execute();    } }the classpathxmlapplicationcontext you instantiate here loads up the bean definitions you saw previously in the beans',1),(1025,'you then call getbean on the context to look up the bean with the greetmebean id in the spring registry',1),(1026,'all beans defined in this file are accessible in this way',1),(1027,'to run this example, go to the chapter2/spring directory in the book’s source code and run this maven command:mvn compile exec:java -dexec',1),(1028,'mainclass=camelinaction',1),(1029,'info36 chapter 2 routing with camelthis will output something like the following on the command line:hello jansteyif you had wired the danishgreeter in instead, you’d have seen something like this on the console:davs jansteythis example may seem pret...',1),(1030,'so how does camel fit into this',1),(1031,'essentially, camel can be configured as if it were another bean',1),(1032,'for instance, you configured the jms component to connect to an activemq broker in section 2',1),(1033,'2, but you could have done this in spring by using the bean terminology, as follows:<bean id=\"jms\" class=\"org',1),(1034,'jmscomponent\">  <property name=\"connectionfactory\">    <bean class=\"org',1),(1035,'activemqconnectionfactory\">      <property name=\"brokerurl\" value=\"vm://localhost\" />    </bean>  </property> </bean>in this case, camel will know to look for beans of type org',1),(1036,'component and add them to the camelcontext automatically—a task you did manually in section 2',1),(1037,'but where is the camelcontext defined in spring',1),(1038,'well, to make things easier on the eyes, camel utilizes spring extension mechanisms to provide custom xml syntax for camel concepts within the spring xml file',1),(1039,'to load up a camelcontext in spring, you can do the following:<beans xmlns=\"http://www',1),(1040,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(1041,'org/2001/xmlschema-instance\"       xsi:schemalocation=\"       http://www',1),(1042,'org/schema/beans       http://www',1),(1043,'org/schema/beans/spring-beans-3',1),(1044,'xsd       http://camel',1),(1045,'org/schema/spring       http://camel',1),(1046,'org/schema/spring/camel-spring',1),(1047,'xsd\">',1),(1048,'<camelcontext xmlns=\"http://camel',1),(1049,'org/schema/spring\"/></beans>this will automatically start a springcamelcontext, which is a subclass of the defaultcamelcontext you used for the java dsl',1),(1050,'also notice that you had to include the http://camel',1),(1051,'org/schema/spring/camel-spring',1),(1052,'xsd xml schema definition in the xml file—this is needed to import the custom xml elements',1),(1053,'this snippet alone isn’t going to do much for you',1),(1054,'you need to tell camel what routes to use, as you did when using the java dsl',1),(1055,'the following code uses spring to produce the same results as the code in listing 2',1),(1056,'info37creating routes with spring<beans xmlns=\"http://www',1),(1057,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(1058,'org/2001/xmlschema-instance\"       xsi:schemalocation=\"       http://www',1),(1059,'org/schema/beans       http://www',1),(1060,'org/schema/beans/spring-beans-3',1),(1061,'xsd       http://camel',1),(1062,'org/schema/spring       http://camel',1),(1063,'org/schema/spring/camel-spring',1),(1064,'xsd\">  <bean id=\"jms\" class=\"org',1),(1065,'jmscomponent\">    <property name=\"connectionfactory\">      <bean class=\"org',1),(1066,'activemqconnectionfactory\">        <property name=\"brokerurl\" value=\"vm://localhost\" />      </bean>    </property>  </bean>  <bean id=\"ftptojmsroute\" class=\"camelinaction',1),(1067,'ftptojmsroute\"/>  <camelcontext xmlns=\"http://camel',1),(1068,'org/schema/spring\">    <routebuilder ref=\"ftptojmsroute\"/>  </camelcontext></beans>you may have noticed that we’re referring to the camelinaction',1),(1069,'ftptojmsroute class as a routebuilder',1),(1070,'in order to reproduce the java dsl example in listing 2',1),(1071,'1, you have to factor out the anonymous routebuilder into its own named class',1),(1072,'the ftptojmsroute class looks like this:public class ftptojmsroute extends routebuilder {  public void configure() {            from(\"ftp://rider',1),(1073,'com\" +       \"/orders',1),(1074,'username=rider&password=secret\")',1),(1075,'to(\"jms:incomingorders\");  } }now that you know the basics of spring and how to load camel inside it, we can go further by looking at how to write camel routing rules purely in xml—no java dsl required',1),(1076,'2 the spring dslwhat we’ve seen of camel’s integration with spring is adequate, but it isn’t taking full advantage of spring’s methodology of configuring applications using no code',1),(1077,'to completely invert the control of creating applications using spring xml, camel provides custom xml extensions that we call the spring dsl',1),(1078,'the spring dsl allows you to do almost everything you can do in the java dsl',1),(1079,'let’s continue with the rider auto parts example shown in listing 2',1),(1080,'2, but this time you’ll specify the routing rules defined in the routebuilder purely in xml',1),(1081,'the following spring xml does this',1),(1082,'listing 2',1),(1083,'2 a spring configuration that produces the same results as listing 2',1),(1084,'info38 chapter 2 routing with camel<beans xmlns=\"http://www',1),(1085,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(1086,'org/2001/xmlschema-instance\"       xsi:schemalocation=\"       http://www',1),(1087,'org/schema/beans       http://www',1),(1088,'org/schema/beans/spring-beans-3',1),(1089,'xsd       http://camel',1),(1090,'org/schema/spring       http://camel',1),(1091,'org/schema/spring/camel-spring',1),(1092,'xsd\">  <bean id=\"jms\" class=\"org',1),(1093,'jmscomponent\">    <property name=\"connectionfactory\">      <bean class=\"org',1),(1094,'activemqconnectionfactory\">        <property name=\"brokerurl\" value=\"vm://localhost\" />      </bean>    </property>  </bean>  <camelcontext xmlns=\"http://camel',1),(1095,'org/schema/spring\">    <route>      <from uri=\"ftp://rider',1),(1096,'username=rider&password=secret\"/>      <to uri=\"jms:incomingorders\"/>    </route>  </camelcontext></beans>in this listing, under the camelcontext element you replace routebuilder with the route element',1),(1097,'within the route element, you specify the route using elements with names similar to ones used inside the java dsl routebuilder',1),(1098,'this listing is functionally equivalent to the java dsl version in listing 2',1),(1099,'1 and the spring plus java dsl combo in listing 2',1),(1100,'in the book’s source code, we changed the from method to consume messages from a local file directory instead',1),(1101,'the new route looks like this:<route>  <from uri=\"file:src/data',1),(1102,'noop=true\"/>  <to uri=\"jms:incomingorders\"/> </route>the file endpoint will load order files from the relative src/data directory',1),(1103,'the noop property configures the endpoint to leave the file as is after processing; this option is very useful for testing',1),(1104,'in chapter 7, you’ll also see how camel allows you to delete or move the files after processing',1),(1105,'this route won’t display anything interesting yet',1),(1106,'you need to add an additional processing step for testing',1),(1107,'adding a processoradding additional processing steps is simple, as in the java dsl',1),(1108,'here you’ll add a custom processor like you did in section 2',1),(1109,'because you can’t refer to an anonymous class in spring xml, you need to factor out the anonymous processor into the following class:listing 2',1),(1110,'3 a spring dsl example that produces the same results as listing 2',1),(1111,'info39creating routes with springpublic class downloadlogger implements processor {    public void process(exchange exchange) throws exception {        system',1),(1112,'println(\"we just downloaded: \"                + exchange',1),(1113,'getheader(\"camelfilename\"));    } }you can now use it in your spring dsl route as follows:<bean id=\"downloadlogger\" class=\"camelinaction',1),(1114,'downloadlogger\"/><camelcontext xmlns=\"http://camel',1),(1115,'org/schema/spring\">  <route>    <from uri=\"file:src/data',1),(1116,'noop=true\"/>    <process ref=\"downloadlogger\"/>    <to uri=\"jms:incomingorders\"/>  </route> </camelcontext>now you’re ready to run the example',1),(1117,'go to the chapter2/spring directory in the book’s source code and run this maven command:mvn clean compile camel:runbecause there is only one message file named message1',1),(1118,'xml in the src/data directory, this will output something like the following on the command line:we just downloaded: message1',1),(1119,'xmlwhat if you wanted to print this message after consuming it from the incomingorders queue',1),(1120,'to do this, you’ll need to create another route',1),(1121,'using multiple routesyou may recall that in the java dsl each java statement starting with a from creates a new route',1),(1122,'you can also create multiple routes with the spring dsl',1),(1123,'to do this, simply add an additional route element within the camelcontext element',1),(1124,'for example, move the downloadlogger bean into a second route, after the order gets sent to the incomingorders queue:<camelcontext xmlns=\"http://camel',1),(1125,'org/schema/spring\">  <route>    <from uri=\"file:src/data',1),(1126,'noop=true\"/>    <to uri=\"jms:incomingorders\"/>  </route>  <route>    <from uri=\"jms:incomingorders\"/>    <process ref=\"downloadlogger\"/>  </route> </camelcontext>now you are consuming the message from the incomingorders queue in the second route',1),(1127,'so, the downloaded message will be printed after the order is sent to the queue',1),(1128,'choosing which dsl to usewhich dsl is best to use in a particular scenario is a common question for camel users, but it mostly comes down to personal preference',1),(1129,'info40 chapter 2 routing with camelspring or like defining things in xml, you may prefer a pure spring approach',1),(1130,'if you want to be hands-on with java, maybe a pure java dsl approach is better for you',1),(1131,'in either case, you’ll be able to access nearly all of camel’s functionality',1),(1132,'the java dsl is a slightly richer language to work with because you have the full power of the java language at your fingertips',1),(1133,'also, some java dsl features, like value builders (for building expressions and predicates1), aren’t available in the spring dsl',1),(1134,'on the other hand, using spring gives you access to the wonderful object construction capabilities as well as commonly used spring abstractions for things like database connections and jms integration',1),(1135,'a common compromise (and our favorite usage) is to use both spring and the java dsl, which is one of the topics we’ll cover next',1),(1136,'3 using camel and springwhether you write your routes in the java or spring dsl, running camel in a spring container gives you many other benefits',1),(1137,'for one, if you’re using the spring dsl, you don’t have to recompile any code when you want to change your routing rules',1),(1138,'also, you gain access to spring’s portfolio of database connectors, transaction support, and more',1),(1139,'let’s take a closer look at what other spring integrations camel provides',1),(1140,'finding route buildersusing the spring camelcontext as a runtime and the java dsl for route development is a great way of using camel',1),(1141,'in fact, it’s the most frequent usage of camel',1),(1142,'you saw before that you can explicitly tell the spring camelcontext what route builders to load',1),(1143,'you can do this by using the routerbuilder element:<camelcontext xmlns=\"http://camel',1),(1144,'org/schema/spring\">  <routebuilder ref=\"ftptojmsroute\"/> </camelcontext>being this explicit results in a clean and concise definition of what is being loaded into camel',1),(1145,'sometimes, though, you may need to be a bit more dynamic',1),(1146,'this is where the packagescan and contextscan elements come in:<camelcontext xmlns=\"http://camel',1),(1147,'org/schema/spring\">  <packagescan>    <package>camelinaction',1),(1148,'routes</package>  </packagescan> </camelcontext>this packagescan element will load all routebuilder classes found in the camelinaction',1),(1149,'routes package, including all subpackages',1),(1150,'you can even be a bit more picky about what route builders are included:<camelcontext xmlns=\"http://camel',1),(1151,'org/schema/spring\">  <packagescan>    <package>camelinaction',1),(1152,'routes</package>1 see appendix b for more information on expressions and predicates',1),(1153,'info41creating routes with spring    <excludes>**',1),(1154,'*test*</excludes>    <includes>**',1),(1155,'*</includes>  </packagescan> </camelcontext>in this case, you’re loading all route builders in the camelinaction',1),(1156,'routes package, except for ones with “test” in the class name',1),(1157,'the matching syntax is similar to what is used in apache ant’s file pattern matchers',1),(1158,'the contextscan element takes advantage of spring’s component-scan feature to load any camel route builders that are marked with the @org',1),(1159,'let’s modify the ftptojmsroute class to use this annotation:@component public class ftptojmsroute extends springroutebuilder {    public void configure() {            from(\"ftp://rider',1),(1160,'com\" +         \"/orders',1),(1161,'username=rider&password=secret\")',1),(1162,'to(\"jms:incomingorders\");    } }notice that this version uses the org',1),(1163,'springroutebuilder class, which is an extension of routebuilder that contains extra spring utility functions',1),(1164,'you can now enable the component scanning by using the following configuration in your spring xml file:<context:component-scan base-package=\"camelinaction',1),(1165,'routes\"/><camelcontext xmlns=\"http://camel',1),(1166,'org/schema/spring\">  <contextscan/> </camelcontext>this will load up any spring route builders within the camelinaction',1),(1167,'routes package that have the @component annotation',1),(1168,'under the hood, some of camel’s components, like the jms component, are built on top of abstraction libraries from spring',1),(1169,'it makes sense that configuring those components is easy in spring',1),(1170,'configuring components and endpointsyou saw in section 2',1),(1171,'1 that components could be defined in spring xml and would be picked up automatically by camel',1),(1172,'for instance, look at the jms component again:<bean id=\"jms\" class=\"org',1),(1173,'jmscomponent\">  <property name=\"connectionfactory\">    <bean class=\"org',1),(1174,'activemqconnectionfactory\">      <property name=\"brokerurl\" value=\"vm://localhost\" />    </bean>  </property> </bean>the bean id defines what this component will be called',1),(1175,'this gives you the flexibility to give the component a more meaningful name based on the use case',1),(1176,'info42 chapter 2 routing with camelmay require the integration of two jms brokers, for instance',1),(1177,'one could be for apache activemq and another could be for sonicmq:<bean id=\"activemq\" class=\"org',1),(1178,'jmscomponent\">',1),(1179,'</bean> <bean id=\"sonicmq\" class=\"org',1),(1180,'jmscomponent\">',1),(1181,'</bean>you could then use uris like activemq:myactivemqqueue or sonicmq:mysonicqueue',1),(1182,'endpoints can also be defined using camel’s spring xml extensions',1),(1183,'for example, you can break out the ftp endpoint for connecting to rider auto parts’ legacy order server and see what the route looks like:<camelcontext xmlns=\"http://camel',1),(1184,'org/schema/spring\">  <endpoint id=\"ridersftp\" uri=\"ftp://rider',1),(1185,'username=rider&password=secret\"/>  <route>    <from ref=\"ridersftp\"/>    <to uri=\"jms:incomingorders\"/>  </route> </camelcontext>note you may notice that credentials have been added directly into the endpoint uri, which isn’t always the best solution',1),(1186,'a better way would be to refer to credentials that are defined and sufficiently protected elsewhere',1),(1187,'in section 6',1),(1188,'6 of chapter 6, you can see how the camel properties component or spring property placeholders are used to do this',1),(1189,'importing configuration and routesa common practice in spring development is to separate out an application’s wiring into several xml files',1),(1190,'this is mainly done to make the xml more readable; you probably wouldn’t want to wade through thousands of lines of xml in a single file without some separation',1),(1191,'another reason to separate an application into several xml files is the potential for reuse',1),(1192,'for instance, some other application may require a similar jms setup, so you can define a second spring xml file called jms-setup',1),(1193,'xml with these contents:<beans xmlns=\"http://www',1),(1194,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(1195,'org/2001/xmlschema-instance\"       xsi:schemalocation=\"       http://www',1),(1196,'org/schema/beans       http://www',1),(1197,'org/schema/beans/spring-beans-3',1),(1198,'xsd\">  <bean id=\"jms\" class=\"org',1),(1199,'jmscomponent\">    <property name=\"connectionfactory\">      <bean class=\"org',1),(1200,'activemqconnectionfactory\">        <property name=\"brokerurl\" value=\"vm://localhost\" />      </bean>    </property>  </bean> </beans>    www',1),(1201,'info43routing and eipsthis file could then be imported into the xml file containing the camelcontext by using the following line:<import resource=\"jms-setup',1),(1202,'xml\"/>now the camelcontext can use the jms component configuration even though it’s defined in a separate file',1),(1203,'other useful things to define in separate files are the spring dsl routes themselves',1),(1204,'because route elements need to be defined within a camelcontext element, an additional concept is introduced to define routes',1),(1205,'you can define routes within a routecontext element, as shown here:<routecontext id=\"ftptojms\" xmlns=\"http://camel',1),(1206,'org/schema/spring\">  <route>    <from uri=\"ftp://rider',1),(1207,'username=rider&password=secret\"/>    <to uri=\"jms:incomingorders\"/>  </route> </routecontext>this routecontext element could be in another file or in the same file',1),(1208,'you can then import the routes defined in this routecontext with the routecontextref element',1),(1209,'you use the routecontextref element inside a camelcontext as follows:<camelcontext xmlns=\"http://camel',1),(1210,'org/schema/spring\">  <routecontextref ref=\"ftptojms\"/> </camelcontext>if you import the routecontext into multiple camelcontexts, a new instance of the route is created in each',1),(1211,'in the preceding case, two identical routes, with the same endpoint uris, will lead to them competing for the same resource',1),(1212,'in this case, only one route at a time will receive a particular file from ftp',1),(1213,'in general, you should take care when reusing routes in multiple camelcontexts',1),(1214,'advanced configuration optionsthere are many other configuration options available when using the spring camelcontext:■ pluggable bean registries are discussed in chapter 4',1),(1215,'■ the tracer and delay mechanisms are covered in chapter 12',1),(1216,'■ custom class resolvers, tracing, fault handling and startup are mentioned in chapter 13',1),(1217,'■ the configuration of interceptors is covered in chapter 6',1),(1218,'with these route configuration techniques behind us, you’re ready to tackle more advanced routing topics using camel’s implementation of the eips',1),(1219,'5 routing and eipsso far we haven’t touched much on the eips that camel was built to implement',1),(1220,'this was intentional',1),(1221,'we wanted to make sure you had a good understanding of what camel is doing in the simplest cases before moving on to more complex examples',1),(1222,'info44 chapter 2 routing with camel as far as eips go, we’ll be looking at the content-based router, message filter, multicast, recipient list, and wire tap right away',1),(1223,'other patterns will be introduced throughout the book, and in chapter 8 we’ll be covering the most complex eips',1),(1224,'the complete list of eips supported by camel is available from the camel website (http:// camel',1),(1225,'org/enterprise-integration-patterns',1),(1226,'for now, let’s start by looking at the most well known eip, the content-based router',1),(1227,'1 using a content-based routeras the name implies, a content-based router (cbr) is a message router that routes a message to a destination based on its content',1),(1228,'the content could be a message header, the payload data type, part of the payload itself—pretty much anything in the message exchange',1),(1229,'to demonstrate, let’s go back to rider auto parts',1),(1230,'some customers have started uploading orders to the ftp server in the newer xml format rather than csv',1),(1231,'that means you have two types of messages coming in to the incomingorders queue',1),(1232,'we didn’t touch on this before, but you need to convert the incoming orders into an internal pojo format',1),(1233,'you obviously need to do different conversions for the different types of incoming orders',1),(1234,'as a possible solution, you could use the filename extension to determine whether a particular order message should be sent to a queue for csv orders or a queue for xml orders',1),(1235,'this is depicted in figure 2',1),(1236,'as you saw earlier, you can use the camelfilename header set by the ftp consumer to get the filename',1),(1237,'to do the conditional routing required by the cbr, camel introduces a few keywords in the dsl',1),(1238,'the choice method creates a cbr processor, and conditions are added by following choice with a combination of a when method and a predicate',1),(1239,'camel’s creators could have chosen contentbasedrouter for the method name, to match the eip, but they stuck with choice because it reads more naturally',1),(1240,'it looks like this:if file extension is “',1),(1241,'xml”    send to xmlorders queueelse    send to csvorders queue    jms:incomingorderscontent basedrouterjms:xmlordersjms:csvordersfigure 2',1),(1242,'10 the cbr routes messages based on their content',1),(1243,'in this case, the filename extension (as a message header) is used to determine which queue to route to',1),(1244,'info45routing and eipsfrom(\"jms:incomingorders\")',1),(1245,'to(\"jms:xmlorders\")',1),(1246,'to(\"jms:csvorders\");you may have noticed that we didn’t fill in the predicates required for each when method',1),(1247,'a predicate in camel is a simple interface that only has a matches method:public interface predicate {    boolean matches(exchange exchange); }for example, you can think of a predicate as a boolean condition in a java if statement',1),(1248,'you probably don’t want to look inside the exchange yourself and do a comparison',1),(1249,'fortunately, predicates are often built up from expressions, and expressions are used to extract a result from an exchange based on the expression content',1),(1250,'there are many different expression languages to choose from in camel, some of which include simple, el, jxpath, mvel, ognl, php, beanshell, javascript, groovy, python, ruby, xpath, and xquery',1),(1251,'as you’ll see in chapter 4, you can even use a method call to a bean as an expression in camel',1),(1252,'in this case, you’ll be using the expression builder methods that are part of the java dsl',1),(1253,'within the routebuilder, you can start by using the header method, which returns an expression that will evaluate to the header value',1),(1254,'for example, header(\"camelfilename\") will create an expression that will resolve to the value of the camelfilename header on the incoming exchange',1),(1255,'on this expression you can invoke a number of methods to create a predicate',1),(1256,'so, to check whether the filename extension is equal to',1),(1257,'xml, you can use the following predicate:header(\"camelfilename\")',1),(1258,'endswith(\"',1),(1259,'xml\")the completed cbr is shown here',1),(1260,'addroutes(new routebuilder() {    public void configure() {        from(\"file:src/data',1),(1261,'to(\"jms:incomingorders\");        from(\"jms:incomingorders\")',1),(1262,'endswith(\"',1),(1263,'to(\"jms:xmlorders\")',1),(1264,'endswith(\"',1),(1265,'csv\"))',1),(1266,'to(\"jms:csvorders\");            from(\"jms:xmlorders\")',1),(1267,'process(new processor() {                    public void process(exchange exchange) throws exception {listing 2',1),(1268,'4 a complete content-based routerb content-based routertest routes that print message contentc    www',1),(1269,'info46 chapter 2 routing with camel                system',1),(1270,'println(\"received xml order: \"                        + exchange',1),(1271,'getheader(\"camelfilename\"));            }        });        from(\"jms:csvorders\")',1),(1272,'process(new processor() {                   public void process(exchange exchange) throws exception {                system',1),(1273,'println(\"received csv order: \"                        + exchange',1),(1274,'getheader(\"camelfilename\"));            }        });    } });to run this example, go to the chapter2/cbr directory in the book’s source code and run this maven command:mvn clean compile exec:java -dexec',1),(1275,'mainclass=camelinaction',1),(1276,'orderrouterthis will consume two order files in the chapter2/cbr/src/data directory and output the following:received csv order: message2',1),(1277,'csvreceived xml order: message1',1),(1278,'xmlthe output comes from the two routes at the end of the configure method c',1),(1279,'these routes consume messages from the xmlorders and csvorders queues and then print out messages',1),(1280,'you use these routes to test that the router b is working as expected',1),(1281,'more advanced route-testing techniques will be discussed in chapter 6',1),(1282,'using the otherwise clauseone of rider auto parts’ customers sends csv orders with the',1),(1283,'csl extension',1),(1284,'csv and',1),(1285,'xml files and will drop all orders with other extensions',1),(1286,'this isn’t a good solution, so you need to improve things a bit',1),(1287,'one way to handle the extra extension is to use a regular expression as a predicate instead of the simple endswith call',1),(1288,'the following route can handle the extra file extension:from(\"jms:incomingorders\")',1),(1289,'endswith(\"',1),(1290,'to(\"jms:xmlorders\")',1),(1291,'*(csv|csl)$\"))',1),(1292,'to(\"jms:csvorders\");this solution still suffers from the same problem, though',1),(1293,'any orders not conforming to the file extension scheme will be dropped',1),(1294,'really, you should be handling bad orders that come in so someone can fix the problem',1),(1295,'for this you can use the otherwise clause:from(\"jms:incomingorders\")',1),(1296,'endswith(\"',1),(1297,'xml\"))test routes that print message contentc    www',1),(1298,'to(\"jms:xmlorders\")',1),(1299,'*(csv|csl)$\"))',1),(1300,'to(\"jms:csvorders\")',1),(1301,'otherwise()',1),(1302,'to(\"jms:badorders\");now, all orders not having an extension of',1),(1303,'csv,',1),(1304,'csl, or',1),(1305,'xml are sent to the badorders queue for handling',1),(1306,'to run this example, go to the chapter2/cbr directory in the book’s source and run this command:mvn clean compile exec:java',1),(1307,'mainclass=camelinaction',1),(1308,'orderrouterotherwisethis will consume four order files in the chapter2/cbr/src/data directory and output the following:received csv order: message2',1),(1309,'csvreceived xml order: message1',1),(1310,'xml received bad order: message4',1),(1311,'bad received csv order: message3',1),(1312,'cslyou can now see that a bad order has been received',1),(1313,'routing after a cbrthe cbr may seem like it’s the end of the route; messages are routed to one of several destinations, and that’s it',1),(1314,'continuing the flow means you need another route, right',1),(1315,'well, there are several ways you can continue routing after a cbr',1),(1316,'one is by using another route, like you did in listing 2',1),(1317,'4 for printing a test message to the console',1),(1318,'another way of continuing the flow is by closing the choice block and adding another processor to the pipeline after that',1),(1319,'you can close the choice block by using the end method:from(\"jms:incomingorders\")',1),(1320,'endswith(\"',1),(1321,'to(\"jms:xmlorders\")',1),(1322,'*(csv|csl)$\"))',1),(1323,'to(\"jms:csvorders\")',1),(1324,'otherwise()',1),(1325,'to(\"jms:badorders\")',1),(1326,'to(\"jms:continuedprocessing\");here, the choice has been closed and another to has been added to the route',1),(1327,'now, after each destination with the choice, the message will be routed to the continuedprocessing queue as well',1),(1328,'this is illustrated in figure 2',1),(1329,'you can also control what destinations are final in the choice block',1),(1330,'for instance, you may not want bad orders continuing through the rest of the route',1),(1331,'you’d like them to be routed to the badorders queue and stop there',1),(1332,'in this case, you can use the stop method in the dsl:    www',1),(1333,'info48 chapter 2 routing with camelfrom(\"jms:incomingorders\")',1),(1334,'endswith(\"',1),(1335,'to(\"jms:xmlorders\")',1),(1336,'*(csv|csl)$\"))',1),(1337,'to(\"jms:csvorders\")',1),(1338,'otherwise()',1),(1339,'to(\"jms:badorders\")',1),(1340,'to(\"jms:continuedprocessing\");now, any orders entering into the otherwise block will only be sent to the badorders queue—not to the continuedprocessing queue',1),(1341,'using the spring dsl, this route looks a bit different:<route>  <from uri=\"jms:incomingorders\"/>  <choice>    <when>      <simple>${header',1),(1342,'*xml$\'</simple>      <to uri=\"jms:xmlorders\"/>    </when>    <when>      <simple>${header',1),(1343,'*(csv|csl)$\'</simple>      <to uri=\"jms:csvorders\"/>    </when>    <otherwise>      <to uri=\"jms:badorders\"/>      <stop/>    </otherwise>  </choice>  <to uri=\"jms:continuedprocessing\"/> </route>other than being in xml rather than java, there are two...',1),(1344,'11 by using the end method, you can route messages to a destination after the cbr',1),(1345,'info49routing and eips■ you use a simple expression instead of the java-based predicate',1),(1346,'the simple expression language is typically used as a replacement for predicates from the java dsl',1),(1347,'a complete guide on the simple expression language can be found in appendix a',1),(1348,'■ you don’t have to use an end() call to end the choice block because xml requires an explicit end block in the form of the closing element </choice>',1),(1349,'2 using message filtersrider auto parts now has a new issue—their qa department has expressed the need to be able to send test orders into the live web frontend of the order system',1),(1350,'your current solution would accept these orders as real and send them to the internal systems for processing',1),(1351,'you’ve suggested that qa should be testing on a development clone of the real system, but management has shot down this idea, citing a limited budget',1),(1352,'what you need is a solution that will discard these test messages while still operating on the real orders',1),(1353,'the message filter eip, shown in figure 2',1),(1354,'12, provides a nice way of dealing with this kind of problem',1),(1355,'incoming messages only pass through the filter if a certain condition is met',1),(1356,'messages failing the condition will be dropped',1),(1357,'let’s see how you can implement this using camel',1),(1358,'recall that the web frontend that rider auto parts uses only sends orders in the xml format, so you can place this filter after the xmlorders queue, where all orders are xml',1),(1359,'test messages have an extra test attribute set, so you can use this to do the filtering',1),(1360,'a test message looks like this:<',1),(1361,'xml version=\"1',1),(1362,'> <order name=\"motor\" amount=\"1\" customer=\"foo\" test=\"true\"/>the entire solution is implemented in orderrouterwithfilter',1),(1363,'java, which is included with the chapter2/filter project in the book’s source distribution',1),(1364,'the filter looks like this:from(\"jms:xmlorders\")',1),(1365,'filter(xpath(\"/order[not(@test)]\"))',1),(1366,'process(new processor() {    public void process(exchange exchange) throws exception {        system',1),(1367,'println(\"received xml order: \"                + exchange',1),(1368,'getheader(\"camelfilename\"));    } });to run this example, execute the following maven command on the command line:mvn clean compile exec:java',1),(1369,'mainclass=camelinaction',1),(1370,'orderrouterwithfiltermessage filterrealorderrealtest order orderrealorderrealorderfigure 2',1),(1371,'12 a message filter allows you to filter out uninteresting messages based on some condition',1),(1372,'in this case, test messages are filtered out',1),(1373,'info50 chapter 2 routing with camelthis will output the following on the command line:received xml order: message1',1),(1374,'xmlyou’ll only receive one message after the filter because the test message was filtered out',1),(1375,'you may have noticed that this example filters out the test message with an xpath expression',1),(1376,'xpath expressions are useful for creating conditions based on xml payloads',1),(1377,'in this case, the expression will evaluate true for orders that don’t have the test attribute',1),(1378,'as you saw back in section 2',1),(1379,'2, when the spring dsl is used, you cannot use an anonymous inner class for a processor',1),(1380,'you must name the processor class and add a bean entry in the spring xml file',1),(1381,'so a message filter route in the spring dsl looks like this:<route>  <from uri=\"jms:xmlorders\"/>  <filter>    <xpath>/order[not(@test)]</xpath>    <process ref=\"orderlogger\"/>  </filter> </route>the flow remains the same as in the java dsl version of...',1),(1382,'so far, the eips we’ve looked at only sent messages to a single destination',1),(1383,'next we’ll take a look at how you can send to multiple destinations',1),(1384,'3 using multicastingoften in enterprise applications you’ll need to send a copy of a message to several different destinations for processing',1),(1385,'when the list of destinations is known ahead of time and is static, you can add an element to the route that will consume messages from a source endpoint and then send the message out to a list of destinations',1),(1386,'borrowing terminology from computer networking, we call this the multicast eip',1),(1387,'currently at rider auto parts, orders are processed in a step-by-step manner',1),(1388,'they’re first sent to accounting for validation of customer standing and then to production for manufacture',1),(1389,'a bright new manager has suggested that they could improve the speed of operations by sending orders to accounting and production at the same time',1),(1390,'this would cut out the delay involved when production waits for the ok from accounting',1),(1391,'you’ve been asked to implement this change to the system',1),(1392,'using a multicast, you could envision the solution shown in figure 2',1),(1393,'jms:xmlordersmulticastjms:accountingjms:production figure 2',1),(1394,'13a multicast sends a message to a number of specified recipients',1),(1395,'info51routing and eipswith camel, you can use the multicast method in the java dsl to implement this solution:from(\"jms:xmlorders\")',1),(1396,'multicast()',1),(1397,'to(\"jms:accounting\", \"jms:production\");to run this example, go to the chapter2/multicast directory in the book’s source code and run this command:mvn clean compile exec:java -dexec',1),(1398,'mainclass=camelinaction',1),(1399,'orderrouterwithmulticastyou should see the following output on the command line:accounting received order: message1',1),(1400,'xmlproduction received order: message1',1),(1401,'xmlthese two lines of output are coming from two test routes that consume from the accounting and production queues and then output text to the console that qualifies the message',1),(1402,'tip for dealing with responses from services invoked in a multicast, an aggregator is used',1),(1403,'by default, the multicast sends message copies sequentially',1),(1404,'in the preceding example, a message is sent to the accounting queue and then to the production queue',1),(1405,'but what if you wanted to send them in parallel',1),(1406,'parallel multicastingsending messages in parallel using the multicast involves only one extra dsl method: parallelprocessing',1),(1407,'extending the previous multicast example, you can add the parallelprocessing method as follows:from(\"jms:xmlorders\")',1),(1408,'multicast()',1),(1409,'parallelprocessing()',1),(1410,'to(\"jms:accounting\", \"jms:production\");this will set up the multicast to distribute messages to the destinations in parallel',1),(1411,'a default thread pool size of 10 is used if you don’t specify anything else',1),(1412,'if you want to change this default, you can set the underlying java',1),(1413,'executorservice that’s used to launch new asynchronous message sends by using the executorservice dsl method',1),(1414,'here’s an example:executorservice executor = executors',1),(1415,'newfixedthreadpool(16);from(\"jms:xmlorders\")',1),(1416,'multicast()',1),(1417,'parallelprocessing()',1),(1418,'to(\"jms:accounting\", \"jms:production\");this code increases the maximum number of threads to 16, in order to handle a larger number of incoming requests',1),(1419,'for more information on the camel threading model and thread pools, please see chapter 10',1),(1420,'by default, the multicast will continue sending messages to destinations even if one fails',1),(1421,'in your application, though, you may consider the whole process as failed if one destination fails',1),(1422,'what do you do in this case',1),(1423,'info52 chapter 2 routing with camelstopping the multicast on exceptionour multicast solution at rider auto parts suffers from a problem: if the order failed to send to the accounting queue, it might take longer to track down the order from production...',1),(1424,'to solve this problem, you can take advantage of the stoponexception feature of the multicast',1),(1425,'when enabled, this feature will stop the multicast on the first exception caught, so you can take any necessary action',1),(1426,'to enable this feature, use the stoponexception method as follows:from(\"jms:xmlorders\")',1),(1427,'multicast()',1),(1428,'parallelprocessing()',1),(1429,'to(\"jms:accounting\", \"jms:production\");to handle the exception coming back from this route, you’ll need to use camel’s error-handling facilities, which are described in detail in chapter 5',1),(1430,'when using the spring dsl, this route looks a little bit different:<route>  <from uri=\"jms:xmlorders\"/>  <multicast stoponexception=\"true\" parallelprocessing=\"true\"',1),(1431,'executorserviceref=\"executor\">    <to uri=\"jms:accounting\"/>    <to uri=\"jms:production\"/>  </multicast> </route>the main difference is that the methods used to set flags such as stoponexception in the java dsl are now attributes on the multicast element',1),(1432,'also, the executor service is now specified as a reference to a spring bean defined as follows:<bean id=\"executor\" class=\"java',1),(1433,'executors\"',1),(1434,'factory-method=\"newfixedthreadpool\">  <constructor-arg index=\"0\" value=\"16\"/> </bean>now you know how to multicast messages in camel, but you may be thinking that this seems like a pretty static solution, because changing the destinations means chang...',1),(1435,'let’s see how you can make sending to multiple recipients more dynamic',1),(1436,'4 using recipient listsin the previous section, you implemented a new manager’s suggestion to parallelize the accounting and production queues so orders could be processed more quickly',1),(1437,'rider auto parts’ top-tier customers first noticed the problem with this approach: now that all orders are going directly into production, top-tier customers are not getting priority over the smaller customers',1),(1438,'their orders are taking longer, and they’re losing business opportunities',1),(1439,'management suggested immediately going back to the old scheme, but you suggested a simple solution to the problem: by parallelizing only toptier customers’ orders, all other orders would have to go to accounting first, thereby not bogging down production',1),(1440,'info53routing and eipsthis solution can be realized by using the recipient list eip',1),(1441,'as shown in figure 2',1),(1442,'14, a recipient list first inspects the incoming message, then generates a list of desired recipients based on the message content, and sends the message to those recipients',1),(1443,'a recipient is specified by an endpoint uri',1),(1444,'note that the recipient list is different from the multicast because the list of recipients is dynamic',1),(1445,'camel provides a recipientlist method for implementing the recipient list eip',1),(1446,'for example, the following route will take the list of recipients from a header named recipients, where each recipient is separated from the next by a comma:from(\"jms:xmlorders\")',1),(1447,'recipientlist(header(\"recipients\"));this is useful if you already have some information in the message that can be used to construct the destination names—you could use an expression to create the list',1),(1448,'in order for the recipient list to extract meaningful endpoint uris, the expression result must be iterable',1),(1449,'values that will work are java',1),(1450,'iterator, java arrays, org',1),(1451,'nodelist, and, as shown in the example, a string with comma-separated values',1),(1452,'in the rider auto parts situation, the message doesn’t contain that list',1),(1453,'you need some way of determining whether the message is from a top-tier customer or not',1),(1454,'a simple solution could be to add a custom processor to do this:from(\"jms:xmlorders\")',1),(1455,'setheader(\"customer\", xpath(\"/order/@customer\"))',1),(1456,'process(new processor() {    public void process(exchange exchange) throws exception {        string recipients = \"jms:accounting\";        string customer =            exchange',1),(1457,'getheader(\"customer\", string',1),(1458,'class);        if (customer',1),(1459,'equals(\"honda\")) {            recipients += \",jms:production\";        }        exchange',1),(1460,'setheader(\"recipients\", recipients);    } })',1),(1461,'recipientlist(header(\"recipients\"));recipient listabcdfigure 2',1),(1462,'14 a recipient list inspects the incoming message and determines a list of recipients based on the content of the message',1),(1463,'in this case, the message is only sent to the a, b, and d destinations',1),(1464,'info54 chapter 2 routing with camelthe processor now sets the recipients header to \"jms:accounting, jms:production\" only if the customer is at the gold level of support',1),(1465,'the check for gold-level support here is greatly simplified—ideally you’d query a database for this check',1),(1466,'any other orders will be routed only to accounting, which will send them to production after the checks are complete',1),(1467,'the spring dsl version of this route follows a very similar layout:<route>  <from uri=\"jms:xmlorders\" />  <setheader headername=\"customer\">    <xpath>/order/@customer</xpath>  </setheader>  <process ref=\"calculaterecipients\" />  <recipientlist>      ...',1),(1468,'this processor was then loaded as a spring bean and given the name calculaterecipients, which is then referenced in the process element by using the ref attribute',1),(1469,'it’s common for recipients to not be embedded in the message as headers or parts of the body, and using a custom processor for this case is perfectly functional, but not very nice',1),(1470,'in using a custom processor, you have to manipulate the exchange and message apis directly',1),(1471,'fortunately, camel supports a better way of implementing a recipient list',1),(1472,'recipient list annotationrather than using the recipientlist method in the dsl, you can add a @recipientlist annotation to a method in a plain java class (a java bean)',1),(1473,'this annotation tells camel that the annotated method should be used to generate the list of recipients from the exchange',1),(1474,'this behavior only gets invoked, however, if the class is used with camel’s bean integration',1),(1475,'for example, replacing the custom processor you used in the previous section with an annotated bean results in a greatly simplified route:from(\"jms:xmlorders\")',1),(1476,'bean(recipientlistbean',1),(1477,'class);now all the logic for calculating the recipients and sending out messages is captured in the recipientlistbean class, which looks like this:public class recipientlistbean {    @recipientlist    public string[] route(@xpath(\"/order/@customer\") ...',1),(1478,'info55routing and eips    private boolean isgoldcustomer(string customer) {        return customer',1),(1479,'equals(\"honda\");    } }notice that the return type of the bean is a list of the desired recipients',1),(1480,'camel will take this list and send a copy of the message to each destination in the list',1),(1481,'one nice thing about implementing the recipient list this way is that it’s entirely separated from the route, which makes it a bit easier to read',1),(1482,'you also have access to camel’s bean-binding annotations, which allow you to extract data from the message using expressions, so you don’t have to manually explore the exchange',1),(1483,'this example uses the @xpath bean-binding annotation to grab the customer attribute of the order element in the body',1),(1484,'we’ll cover these annotations in chapter 4, which is all about using beans',1),(1485,'to run this example, go to the chapter2/recipientlist directory in the book’s source code and run this command:mvn clean compile exec:java -dexec',1),(1486,'mainclass=camelinaction',1),(1487,'orderrouterwithrecipientlistbeanthis will output the following on the command line:accounting received order: message1',1),(1488,'xmlproduction received order: message1',1),(1489,'xml accounting received order: message2',1),(1490,'xmlwhy do you get this output',1),(1491,'well, you had the following two orders in the src/data directory:■ message1',1),(1492,'xml version=\"1',1),(1493,'> <order name=\"motor\" amount=\"1000\" customer=\"honda\"/>■ message2',1),(1494,'xml version=\"1',1),(1495,'> <order name=\"motor\" amount=\"2\" customer=\"joe\'s bikes\"/>the first message is from a gold customer, according to the rider auto parts rules, so it was routed to both accounting and production',1),(1496,'the second order is from a smaller customer, so it went to accounting for verification of the customer’s credit standing',1),(1497,'what this system lacks now is a way to inspect these messages as they’re flowing through the route, rather than waiting until they reach the end',1),(1498,'let’s see how a wire tap can help',1),(1499,'5 using the wiretap methodoften in enterprise applications it’s useful and necessary to inspect messages as they flow through a system',1),(1500,'for instance, when an order fails, you need a way to look at which messages were received to determine the cause of the failure',1),(1501,'you could use a simple processor, as you’ve done before, to output information about a incoming message to the console or append it to a file',1),(1502,'here is a processor that outputs the message body to the console:    www',1),(1503,'info56 chapter 2 routing with camelfrom(\"jms:incomingorders\")',1),(1504,'process(new processor() {    public void process(exchange exchange) throws exception {        system',1),(1505,'println(\"received order: \" +            exchange',1),(1506,'this is fine for debugging purposes, but it’s a pretty poor solution for production use',1),(1507,'what if you wanted the message headers, exchange properties, or other data in the message exchange',1),(1508,'ideally you could copy the whole incoming exchange and send that to another channel for auditing',1),(1509,'as shown in figure 2',1),(1510,'15, the wire tap eip defines such a solution',1),(1511,'by using the wiretap method in the java dsl, you can send a copy of the exchange to a secondary destination without affecting the behavior of the rest of the route:from(\"jms:incomingorders\")',1),(1512,'wiretap(\"jms:orderaudit\")',1),(1513,'endswith(\"',1),(1514,'to(\"jms:xmlorders\")',1),(1515,'*(csv|csl)$\"))',1),(1516,'to(\"jms:csvorders\")',1),(1517,'otherwise()',1),(1518,'to(\"jms:badorders\");the preceding code sends a copy of the exchange to the orderaudit queue, and the original exchange continues on through the route, as if you hadn’t used a wire tap at all',1),(1519,'camel doesn’t wait for a response from the wire tap because the wire tap sets the message exchange pattern (mep) to inonly',1),(1520,'this means that the message will be sent to the orderaudit queue in a fire-and-forget fashion—it won’t wait for a reply',1),(1521,'in the spring dsl, you can configure a wire tap just as easily:<route>  <from uri=\"jms:incomingorders\"/>  <wiretap uri=\"jms:orderaudit\"/>',1),(1522,'what can you do with a tapped message',1),(1523,'a number of things could be done at this point:source destinationtapdestinationwire tapfigure 2',1),(1524,'15 a wire tap is a fixed recipient list that sends a copy of a message traveling from a source to a destination to a secondary destination',1),(1525,'info57summary and best practices■ you could print the information to the console like you did before',1),(1526,'this is useful for simple debugging purposes',1),(1527,'■ you could save the message in a persistent store (in a file or database) for retrieval later',1),(1528,'the wire tap is a pretty useful monitoring tool, but it leaves most of the work up to you',1),(1529,'we’ll discuss some of camel’s more powerful tracing and auditing tools in chapter 12',1),(1530,'6 summary and best practicesin this chapter, we’ve covered one of the core abilities of camel: routing messages',1),(1531,'by now you should know how to create routes in either the java or spring dsl and know the differences in their configuration',1),(1532,'you should also have a good grasp of when to apply several eip implementations in camel and how to use them',1),(1533,'with this knowledge, you can create camel applications that do useful tasks',1),(1534,'here are some of the key concepts you should take away from this chapter:■ routing occurs in many aspects of everyday life',1),(1535,'whether you’re surfing the internet, doing online banking, booking a flight or hotel room, messages are being routed behind the scenes using some sort of router',1),(1536,'■ use apache camel for routing messages',1),(1537,'camel is primarily a message router that allows to you route messages from and to a variety of transports and apis',1),(1538,'■ camel’s dsls are used to define routing rules',1),(1539,'the java dsl allows you to write in the popular java language, which gives you autocompletion of terms in most ides',1),(1540,'it also allows you to use the full power of the java language when writing routes',1),(1541,'it’s considered the main dsl in camel',1),(1542,'the spring dsl allows you to write routing rules without any java code at all',1),(1543,'in section 2',1),(1544,'3 we described our favorite way to write camel applications, which is to boot up the camelcontext in spring and write routing rules in java dsl routebuilders',1),(1545,'this gives you the best of both: the most expressive dsl that camel has in the java dsl, and a more feature-rich and standard container in the spring camelcontext',1),(1546,'■ use enterprise integration patterns (eips) to solve integration and routing problems',1),(1547,'eips are like design patterns from object oriented programming, but for the enterprise integration world',1),(1548,'■ use camel’s built-in eip implementations rather than creating your own',1),(1549,'camel implements most eips as easy-to-use dsl terms, which allows you to focus on the actual business problem rather than the integration architecture',1),(1550,'in the coming chapters we’ll build on this foundation to show you things like data transformation, error handling, testing, sending data over other transports, and more',1),(1551,'in the next chapter, we’ll look at how camel makes data transformation a breeze',1),(1552,'infopart 2core camelin part 1, we guided you through what we consider introductory topics in camel',1),(1553,'they were topics you absolutely needed to know to use camel',1),(1554,'in this next part, we’ll cover in depth the core features of camel',1),(1555,'you’ll need many of these features when using camel in real-world applications',1),(1556,'in chapter 3 we’ll take a look at the data in the messages being routed by camel',1),(1557,'in particular, we’ll look at how you can transform this data to other formats using camel',1),(1558,'camel has great support for integrating beans into your routing applications',1),(1559,'in chapter 4 we’ll look at the many ways beans can be used in camel applications',1),(1560,'in complex enterprise systems, lots of things can go wrong',1),(1561,'this is why camel features an extensive set of error-handling abilities',1),(1562,'in chapter 5 we’ll discuss these in detail',1),(1563,'in chapter 6 we’ll take a look at another important topic in application development: testing',1),(1564,'we’ll look at the testing facilities shipped with camel',1),(1565,'you can use these features for testing your own camel applications or applications based on other stacks',1),(1566,'components are the main extension mechanism in camel',1),(1567,'as such, they include functionality to connect to many different transports, apis, and other extensions to camel’s core',1),(1568,'chapter 7 covers the most heavily used components that ship with camel',1),(1569,'the last chapter of this part revisits the important topic of enterprise integration patterns (eips) in camel',1),(1570,'back in chapter 2, we covered some of the simpler eips; in chapter 8, we’ll look at several of the more complex eips',1),(1571,'info61transforming data with camelin the previous chapter, we covered routing, which is the single most important feature any integration kit must provide',1),(1572,'in this chapter, we’ll take a look at the second most important feature: data or message transformation',1),(1573,'just as in the real world, where people speak different languages, the it world speaks different protocols',1),(1574,'software engineers regularly need to act as mediators between various protocols when it systems must be integrated',1),(1575,'to address this, the data models used by the protocols must be transformed from one form to another, adapting to whatever protocol the receiver understands',1),(1576,'mediation and data transformation is a key feature in any integration kit, including camel',1),(1577,'this chapter covers■ transforming data using eips and java■ transforming xml data■ transforming using well-known data formats■ writing your own data formats for transformations■ understanding the camel type-converter mechanism    www',1),(1578,'info62 chapter 3 transforming data with camel in this chapter, you’ll learn all about how camel can help you with your data transformation challenges',1),(1579,'we’ll start with a brief overview of data transformation in camel and then look at how you can transform data into any custom format you may have',1),(1580,'then we’ll look at some camel components that are specialized for transforming xml data and other well-known data formats',1),(1581,'we’ll end the chapter by looking into camel’s type-converter mechanism, which supports implicitly and explicitly type coercing',1),(1582,'after reading this chapter, you’ll know how to tackle any data transformation you’re faced with and which camel solution to leverage',1),(1583,'1 data transformation overviewcamel provides many techniques for data transformation, and we’ll cover them shortly',1),(1584,'but first we’ll start with an overview of data transformation in camel',1),(1585,'data transformation is a broad term that covers two types of transformation:■ data format transformation—the data format of the message body is transformed from one form to another',1),(1586,'for example, a csv record is formatted as xml',1),(1587,'■ data type transformation—the data type of the message body is transformed from one type to another',1),(1588,'string is transformed into a javax',1),(1589,'textmessage',1),(1590,'1 illustrates the principle of transforming a message body from one form into another',1),(1591,'this transformation can involve any combination of format and type transformations',1),(1592,'in most cases, the data transformation you’ll face with camel is format transformation, where you have to mediate between two protocols',1),(1593,'camel has a builtin type-converter mechanism that can automatically convert between types, which greatly reduces the need for end users to deal with type transformations',1),(1594,'camel has many data-transformation features',1),(1595,'we’ll introduce them in the following section, and then look at them one by one',1),(1596,'after reading this chapter, you’ll have a solid understanding of how to use camel to transform your data',1),(1597,'1 data transformation with camelin camel, data transformation typically takes places in the six ways listed in table 3',1),(1598,'messagemessagebodymessagemessagebodytransform figure 3',1),(1599,'1 camel offers many features for transforming data from one form to another',1),(1600,'info63transforming data using eips and javain this chapter, we’ll cover the first five of the data transformation methods listed in table 3',1),(1601,'we’ll leave the last one for chapter 11',1),(1602,'2 transforming data using eips and javadata mapping is the process of mapping between two distinct data models, and it’s a key factor in data integration',1),(1603,'there are many existing standards for data models, governed by various organizations or committees',1),(1604,'as such, you’ll often find yourself needing to map from a company’s custom data model to a standard data model',1),(1605,'camel provides great freedom in data mapping because it allows you to use java code—you aren’t limited to using a particular data mapping tool that at first might seem elegant but that turns out to make things impossible',1),(1606,'in this section, we’ll look at how you can map data using a processor, which is a camel api',1),(1607,'camel can also use beans for mapping, which is a good practice, because it allows your mapping logic to be independent of the camel api',1),(1608,'1 using the message translator eip the message translator eip is illustrated in figure 3',1),(1609,'this pattern covers translating a message from one format to another',1),(1610,'it’s the equivalent of the adapter pattern from the gang of four book',1),(1611,'1 six ways data transformation typically takes place in cameltransformation descriptiondata transformation in routesyou can explicitly enforce transformation in the route using the message translator or the content enricher eips',1),(1612,'this gives you the power to do data mapping using regular java code',1),(1613,'we ll cover this in section 3',1),(1614,'data transformation using componentscamel provides a range of components for transformation, such as the xslt component for xml transformation',1),(1615,'we’ll dive into this in section 3',1),(1616,'data transformation using data formatsdata formats are camel transformers that come in pairs to transform data back and forth between well-known formats',1),(1617,'data transformation using templatescamel provides a range of components for transforming using templates, such as apache velocity',1),(1618,'we’ll look at this in section 3',1),(1619,'data type transformation using camel’s typeconverter mechanismcamel has an elaborate type-converter mechanism that activates on demand',1),(1620,'this is convenient when you need to convert from common types such as java',1),(1621,'type converters are covered in section 3',1),(1622,'message transformation in component adapterscamel’s many components adapt to various commonly used protocols and, as such, need to be able to transform messages as they travel to and from those protocols',1),(1623,'often these components use a combination of custom data transformations and type converters',1),(1624,'this happens seamlessly, and only component writers need to worry about it',1),(1625,'we’ll cover writing custom components in chapter 11',1),(1626,'info64 chapter 3 transforming data with camelnote the gang of four book is design patterns: elements of reusable objectoriented software by erich gamma, richard helm, ralph johnson, and john vlissides',1),(1627,'see the “design patterns” wikipedia article for more information: http://en',1),(1628,'org/wiki/design_patterns_(book)',1),(1629,'camel provides three ways of using this pattern:■ using a processor■ using beans■ using <transform>we’ll look at them each in turn',1),(1630,'transforming using a processorthe camel processor is an interface defined in org',1),(1631,'processor with a single method:public void process(exchange exchange) throws exception;the processor is a low-level api where you work directly on the camel exchange instance',1),(1632,'it gives you full access to all camel’s moving parts from the camelcontext, which you can obtain exchange using the getcamelcontext method',1),(1633,'let’s look at an example',1),(1634,'at rider auto parts you’ve been asked to generate daily reports of newly received orders to be outputted to a csv file',1),(1635,'the company uses a custom format for order entries, but to make things easy, they already have an http service that returns a list of orders for whatever date you input',1),(1636,'the challenge you face is mapping the returned data from the http service to a csv format and writing the report to a file',1),(1637,'because you want to get started on a prototype quickly, you decide to use the camel processor',1),(1638,'processor;public class ordertocsvprocessor implements processor {    public void process(exchange exchange) throws exception {        string custom = exchange',1),(1639,'class);            listing 3',1),(1640,'1 using a processor to translate from a custom format to csv formatmessagetranslatorincomingmessagetranslatedmessagefigure 3',1),(1641,'2 in the message translator eip, an incoming message goes through a translator and comes out as a translated message',1),(1642,'gets custom payloadb    www',1),(1643,'info65transforming data using eips and java        string id = custom',1),(1644,'substring(0, 9);                  string customerid = custom',1),(1645,'substring(10, 19);               string date = custom',1),(1646,'substring(20, 29);              string items = custom',1),(1647,'substring(30);                 string[] itemids = items',1),(1648,'split(\"@\");                 stringbuilder csv = new stringbuilder();              csv',1),(1649,'trim());        csv',1),(1650,'trim());        csv',1),(1651,'append(customerid',1),(1652,'trim());        for (string item : itemids) {            csv',1),(1653,'setbody(csv',1),(1654,'tostring());           }}first you grab the custom format payload from the exchange b',1),(1655,'it’s a string type, so you pass string in as the parameter to have the payload returned as a string',1),(1656,'then you extract data from the custom format to the local variables c',1),(1657,'the custom format could be anything, but in this example it’s a fixed-length custom format',1),(1658,'then you map the csv format by building a string with comma-separated values d',1),(1659,'finally, you replace the custom payload with your new csv payload e',1),(1660,'you can use the ordertocsvprocessor from listing 3',1),(1661,'1 in a camel route as follows:from(\"quartz://report',1),(1662,'cron=0+0+6+*+*+',1),(1663,'com/orders/cmd=received&date=yesterday\")',1),(1664,'process(new ordertocsvprocessor())',1),(1665,'to(\"file://riders/orders',1),(1666,'csv\");the preceding route uses quartz to schedule a job to run once a day at 6 a',1),(1667,'it then invokes the http service to retrieve the orders received yesterday, which are returned in the custom format',1),(1668,'next, it uses ordertocsvprocessor to map from the custom format to csv format before writing the result to a file',1),(1669,'the equivalent route in spring xml is as follows:<bean id=\"csvprocessor\" class=\"camelinaction',1),(1670,'ordertocsvprocessor\"/><camelcontext xmlns=\"http://camel',1),(1671,'org/schema/spring\">  <route>    <from uri=\"quartz://report',1),(1672,'cron=0+0+6+*+*+',1),(1673,'com/orders/cmd=received&amp;date=yesterday\"/>    <process ref=\"csvprocessor\"/>    <to uri=\"file://riders/orders',1),(1674,'csv\"/>  </route> </camelcontext>you can try this example yourself—we’ve provided a little unit test with the book’s source code',1),(1675,'go to the chapter3/transform directory, and run these maven goals: mvn test -dtest=ordertocsvprocessortest mvn test -dtest=springordertocsvprocessortestafter the test runs, a report file is written in the target/orders/received directory',1),(1676,'maps to csv formatdreplaces payload with csv payloade    www',1),(1677,'info66 chapter 3 transforming data with camelusing a processor has one disadvantage: you’re required to use the camel api',1),(1678,'in the next section, we’ll look at how to avoid this by using a bean',1),(1679,'transforming using beansusing beans is a great practice because it allows you to use any java code and library you wish',1),(1680,'camel imposes no restrictions whatsoever',1),(1681,'camel can invoke any bean you choose, so you can use existing beans without having to rewrite or recompile them',1),(1682,'let’s try using a bean instead of a processor',1),(1683,'public class ordertocsvbean {                                      public static string map(string custom) {        string id = custom',1),(1684,'substring(0, 9);                  string customerid = custom',1),(1685,'substring(10, 19);              string date = custom',1),(1686,'substring(20, 29);              string items = custom',1),(1687,'substring(30);                 string[] itemids = items',1),(1688,'split(\"@\");                 stringbuilder csv = new stringbuilder();                       csv',1),(1689,'trim());        csv',1),(1690,'trim());        csv',1),(1691,'append(customerid',1),(1692,'trim());        for (string item : itemids) {            csv',1),(1693,'trim());        }        return csv',1),(1694,'tostring();                       } }listing 3',1),(1695,'2 using a bean to translate from a custom format to csv formatusing the getin and getout methods on exchangesthe camel exchange defines two methods for retrieving messages: getin and getout',1),(1696,'the getin method returns the incoming message, and the getout method accesses the outbound message',1),(1697,'there are two scenarios where the camel end user will have to decide among using these methods:■ a read-only scenario, such as when you’re logging the incoming message■ a write scenario, such as when you’re transforming the messagein the second scena...',1),(1698,'that’s correct according to theory, but in practice there’s a common pitfall when using getout: the incoming message headers and attachments will be lost',1),(1699,'this is often not what you want, so you must copy the headers and attachments from the incoming message to the outgoing message, which can be tedious',1),(1700,'the alternative is to set the changes directly on the incoming message using getin, and not to use getout at all',1),(1701,'this is the practice we use in this book',1),(1702,'b extracts data to local variablesreturns csv payloadc    www',1),(1703,'info67transforming data using eips and javathe first noticeable difference between listings 3',1),(1704,'2 is that listing 3',1),(1705,'2 doesn’t use any camel imports',1),(1706,'this means your bean is totally independent of the camel api',1),(1707,'the next difference is that you can name the method signature in listing 3',1),(1708,'2—in this case it’s a static method named map',1),(1709,'the method signature defines the contract, which means that the first parameter, (string custom), is the message body you’re going to use for translation',1),(1710,'the method returns a string, which means the translated data will be a string type',1),(1711,'at runtime, camel binds to this method signature',1),(1712,'we won’t go into any more details here; we’ll cover much more about using beans in chapter 4',1),(1713,'the actual mapping b is the same as with the processor',1),(1714,'you can use ordertocsvbean in a camel route as shown here:from(\"quartz://report',1),(1715,'cron=0+0+6+*+*+',1),(1716,'com/orders/cmd=received&date=yesterday\")',1),(1717,'bean(new ordertocsvbean())',1),(1718,'to(\"file://riders/orders',1),(1719,'csv\");the equivalent route in spring xml is as follows:<bean id=\"csvbean\" class=\"camelinaction',1),(1720,'ordertocsvbean\"/><camelcontext xmlns=\"http://camel',1),(1721,'org/schema/spring\">  <route>    <from uri=\"quartz://report',1),(1722,'cron=0+0+6+*+*+',1),(1723,'com/orders/cmd=received&amp;date=yesterday\"/>    <bean ref=\"csvbean\"/>    <to uri=\"file://riders/orders',1),(1724,'csv\"/>  </route> </camelcontext>you can try this example from the chapter3/transform directory by using the following maven goals:mvn test -dtest=ordertocsvbeantest mvn test -dtest=springordertocsvbeantestit will generate a test report file in the ta...',1),(1725,'another advantage of using beans over processors for mappings is that unit testing is much easier',1),(1726,'for example, listing 3',1),(1727,'2 doesn’t require the use of camel at all, as opposed to listing 3',1),(1728,'1 where you need to create and pass in an exchange instance',1),(1729,'we’ll leave the beans for now, because they’re covered extensively in the next chapter',1),(1730,'but you should keep in mind that beans are very useful for doing message transformation',1),(1731,'transforming using the transform() method from the java dsltransform() is a method in the java dsl that can be used in camel routes to transform messages',1),(1732,'by allowing the use of expressions, transform() permits great flexibility, and using expressions directly within the dsl can sometimes save time',1),(1733,'let’s look at a little example',1),(1734,'info68 chapter 3 transforming data with camel suppose you need to prepare some text for html formatting by replacing all line breaks with a <br/> tag',1),(1735,'this can be done with a built-in camel expression that searches and replaces using regular expressions:from(\"direct:start\")',1),(1736,'transform(body()',1),(1737,'regexreplaceall(\"\\n\", \"<br/>\"))',1),(1738,'to(\"mock:result\");what this route does is use the transform() method to tell camel that the message should be transformed using an expression',1),(1739,'camel provides what is know as the builder pattern to build expressions from individual expressions',1),(1740,'this is done by chaining together method calls, which is the essence of the builder pattern',1),(1741,'note for more information on the builder pattern, see the wikipedia article: http://en',1),(1742,'in this example, you combine body() and regexreplaceall()',1),(1743,'the expression should be read as follows: take the body and perform a regular expression that replaces all new lines (\\n) with <br/> tags',1),(1744,'now you’ve combined two methods that conform to a compound camel expression',1),(1745,'you can run this example from chapter3/transform directly by using the following maven goal: mvn test -dtest=transformtestcamel also allows you to use custom expressions',1),(1746,'this is useful when you need to be in full control and have java code at your fingertips',1),(1747,'for example, the previous example could have been implemented as follows:from(\"direct:start\")',1),(1748,'transform(new expression() {        public <t> t evaluate(exchange exchange, class<t> type) {            string body = exchange',1),(1749,'class);            body = body',1),(1750,'replaceall(\"\\n\", \"<br/>\");            body = \"<body>\" + body + \"</body>\";            return (t) body;        }    })',1),(1751,'to(\"mock:result\");as you can see, this code uses an inlined camel expression that allows you to use java code in its evaluate method',1),(1752,'this follows the same principle as the camel processor you saw before',1),(1753,'the direct componentthe example here uses the direct component (http://camel',1),(1754,'org/direct) as the input source for the route (from(\"direct:start\"))',1),(1755,'the direct component provides direct invocation between a producer and a consumer',1),(1756,'it only allows connectivity from within camel, so external systems can’t send messages directly to it',1),(1757,'this component is used within camel to do things such as link routes together or for testing',1),(1758,'info69transforming data using eips and java now let’s see how you can transform data using spring xml',1),(1759,'transforming using <transform> from spring xmlusing <transform> from spring xml is a bit different than from java dsl because the xml dsl isn’t as powerful',1),(1760,'in spring xml, the builder pattern expressions aren’t available because with xml you don’t have a real programming language underneath',1),(1761,'what you can do instead is invoke a method on a bean or use scripting languages',1),(1762,'let’s see how this works',1),(1763,'the following route uses a method call on a bean as the expression:<bean id=\"htmlbean\" class=\"camelinaction',1),(1764,'htmlbean\"/>       <camelcontext id=\"camel\" xmlns=\"http://camel',1),(1765,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>        <transform>            <method bean=\"htmlbean\" method=\"tohtml\"/>             </transform>        <to uri=\"mock:result\"/>    </route> </camelcontext>first, you declare a regular s...',1),(1766,'then, in the route, you use <transform> with a <method> call expression to invoke the bean c',1),(1767,'the implementation of the htmlbean is very straightforward:public class htmlbean {    public static string tohtml(string body) {        body = body',1),(1768,'replaceall(\"\\n\", \"<br/>\");        body = \"<body>\" + body + \"</body>\";        return body;    } }you can also use scripting languages as expressions in camel',1),(1769,'for example, you can use groovy, mvel, javascript, or camel’s own scripting language, called simple (explained in some detail in appendix a)',1),(1770,'we won’t go in detail on how to use the other scripting languages at this point, but the simple language can be used to build strings using placeholders',1),(1771,'it pretty much speaks for itself—i’m sure you’ll understand what the following transformation does:<transform>    <simple>hello ${body} how are you',1),(1772,'</simple> </transform>you can try the spring transformation examples provided in the book’s source code by running the following maven goals from the chapter3/transform directory:mvn test -dtest= springtransformmethodtest mvn test -dtest= springtrans...',1),(1773,'does the transformationbinvokes tohtml method on beanc    www',1),(1774,'info70 chapter 3 transforming data with camel we’re done covering the message translator eip, so let’s look at the related content enricher eip',1),(1775,'2 using the content enricher eip the content enricher eip is illustrated in figure 3',1),(1776,'this pattern documents the scenario where a message is enriched with data obtained from another resource',1),(1777,'to help understand this pattern, we’ll turn back to rider auto parts',1),(1778,'it turns out that the data mapping you did in listing 3',1),(1779,'1 wasn’t sufficient',1),(1780,'orders are also piled up on an ftp server, and your job is to somehow merge this information into the existing report',1),(1781,'4 illustrates the scenario',1),(1782,'basicmessageenrichedmessageenricherresource figure 3',1),(1783,'3 in the content enricher eip, an existing message has data added to it from another source',1),(1784,'http serverftp servercontentenricherquartzschedulerreport(csv)file serverorders(csv)transformcamelb cdefgfigure 3',1),(1785,'4 an overview of the route that generates the orders report, now with the content enricher pulling in data from an ftp server    www',1),(1786,'info71transforming data using eips and javain figure 3',1),(1787,'4, a scheduled consumer using quartz starts the route every day at 6 a',1),(1788,'it then pulls data from an http server, which returns orders in a custom format c, which is then transformed into csv format d',1),(1789,'at this point, you have to perform the additional content enrichment step e with the data obtained from the ftp server f',1),(1790,'after this, the final report is written to the file server g',1),(1791,'before we dig into the code and see how to implement this, we need to take a step back and look at how the content enricher eip is implemented in camel',1),(1792,'camel provides two operations in the dsl for implementing the pattern:■ pollenrich—this operation merges data retrieved from another source using a consumer',1),(1793,'■ enrich—this operation merges data retrieved from another source using a producer',1),(1794,'camel uses the org',1),(1795,'processor',1),(1796,'aggregationstrategy interface to merge the result from the source with the original message, as follows:exchange aggregate(exchange oldexchange, exchange newexchange);this aggregate method is a callback that you must implement',1),(1797,'the method has two parameters: the first, named oldexchange, contains the original exchange; the second, newexchange, is the enriched source',1),(1798,'your task is to enrich the message using java code and return the merged result',1),(1799,'this may sound a bit confusing, so let’s see it in action',1),(1800,'to solve the problem at rider auto parts, you need to use pollenrich because it’s capable of polling a file from an ftp server',1),(1801,'enriching using pollenrichlisting 3',1),(1802,'3 shows how you can use pollenrich to retrieve the additional orders from the remote ftp server and aggregate this data with the existing message using camel’s aggregationstrategy',1),(1803,'cron=0+0+6+*+*+',1),(1804,'com/orders/cmd=received\")',1),(1805,'process(new ordertocsvprocessor())',1),(1806,'com/orders/',1),(1807,'username=rider&password=secret\",listing 3',1),(1808,'3 using pollenrich to merge additional data with an existing messagethe difference between pollenrich and enrichthe difference between pollenrich and enrich is that the former uses a consumer and the latter a producer to retrieve data from the source',1),(1809,'knowing the difference is important: the file component can be used with both, but using enrich will write the message content as a file; using pollenrich will read the file as the source, which is most likely the scenario you’ll be facing when enric...',1),(1810,'the http component only works with enrich; it allows you to invoke an external http service and use its reply as the source',1),(1811,'info72 chapter 3 transforming data with camel                new aggregationstrategy() {                        public exchange aggregate(exchange oldexchange,                                  exchange newexchange) {            if (newexchange == nul...',1),(1812,'class);            string ftp = newexchange',1),(1813,'class);            string body = http + \"\\n\" + ftp;                     oldexchange',1),(1814,'to(\"file://riders/orders\");          the route is triggered by quartz to run at 6 a',1),(1815,'you invoke the http service to retrieve the orders and transform them to csv format using a processor',1),(1816,'at this point, you need to enrich the existing data with the orders from the remote ftp server',1),(1817,'this is done by using pollenrich b, which consumes the remote file',1),(1818,'to merge the data, you use aggregationstrategy c',1),(1819,'first, you check whether any data was consumed or not',1),(1820,'if newexchange is null, there is no remote file to consume, and you just return the existing data',1),(1821,'if there is a remote file, you merge the data by concatenating the existing data with the new data and setting it back on the oldexchange',1),(1822,'to write the csv report file, you use the file component d',1),(1823,'pollenrich uses a polling consumer to retrieve messages, and it offers three timeout modes:■ pollenrich(timeout = -1)—polls the message and waits until a message arrives',1),(1824,'this mode will block until a message exists',1),(1825,'■ pollenrich(timeout = 0)—immediately polls the message if any exists; otherwise null is returned',1),(1826,'it will never wait for messages to arrive, so this mode will never block',1),(1827,'this is the default mode',1),(1828,'■ pollenrich(timeout > 0)—polls the message, and if no message exists, it will wait for one, waiting at most until the timeout triggers',1),(1829,'this mode will potentially block',1),(1830,'it’s a best practice to either use timeout = 0 or to assign a timeout value when using pollenrich to avoid waiting indefinitely if no message arrives',1),(1831,'uses pollenrich to read ftp filebc merges data using aggregationstrategywrites output to filedenrich and pollenrich can’t access information in the current exchangeneither enrich nor pollenrich can leverage any information from the current exchange',1),(1832,'this means, for example, that you can’t store a filename header on the exchange for pollenrich to use to select a particular file',1),(1833,'this may change in the future if the camel team can find a solution',1),(1834,'info73transforming xmlnow let’s take a quick look at how to use enrich with spring xml; it’s a bit different than when using the java dsl',1),(1835,'enriching using enrichenrich is used when you need to enrich the current message with data from another source using request-response messaging',1),(1836,'a prime example would be to enrich the current message with the reply from a web service call',1),(1837,'but we’ll look at another example, using spring xml to enrich the current message using the tcp transport:<bean id=\"quotestrategy\"                     class=\"camelinaction',1),(1838,'quotestrategy\"/>        <route>    <from uri=\"activemq:queue:quotes\"/>    <enrich url=\"mina:tcp://riders',1),(1839,'textline=true&sync=true\"            strategyref=\"quotestrategy\"/>    <to uri=\"log:quotes\"/> </route>here you use the camel mina component for tcp transport, configured to use request-response messaging by using sync=true option',1),(1840,'to merge the original message with data from the remote server, <enrich> must refer to an aggregationstrategy',1),(1841,'this is done using the strategyref attribute',1),(1842,'as you can see in the example, the quotestrategy being referred to is a bean id b, which contains the actual implementation of the aggregationstrategy, where the merging takes place',1),(1843,'you’ve seen a lot about how to transform data in camel, using java code for the actual transformations',1),(1844,'now let’s take a peek into the xml world and look at the xslt component, which is used for transforming xml messages using xslt stylesheets',1),(1845,'3 transforming xmlcamel provides two ways to perform xml transformations: ■ xslt component—for transforming an xml payload into another format using xslt stylesheets■ xml marshaling—for marshaling and unmarshaling objects to and from xml both of thes...',1),(1846,'1 transforming xml with xsltxsl transformations (xslt) is a declarative xml-based language used to transform xml documents into other documents',1),(1847,'for example, xslt can be used to transform xml into html for web pages or to transform an xml document into another xml document with a different structure',1),(1848,'xslt is powerful and versatile, but it’s also a complex language that takes time and effort to fully understand and master',1),(1849,'think twice before deciding to pick up and use xslt',1),(1850,'camel provides xslt as a component in camel-spring',1),(1851,'jar because it leverages spring’s resource loading',1),(1852,'this means greater flexibility in loading stylesheets because spring enables them to be loaded from various locations, such as the classpath, file paths, and over http',1),(1853,'info74 chapter 3 transforming data with camelusing the xslt component is straightforward because it’s just another camel component',1),(1854,'the following route shows an example of how you could use it; this route is also illustrated in figure 3',1),(1855,'to(\"xslt://camelinaction/transform',1),(1856,'xsl\")',1),(1857,'to(\"activemq:queue:transformed\")                    the file consumer picks up new files and routes them to the xslt component, which transforms the payload using the stylesheet',1),(1858,'after the transformation, the message is routed to a jms producer, which sends the message to the jms queue',1),(1859,'notice in the preceding code how the url for the xslt component is defined: xslt://camelinaction/transform',1),(1860,'xsl',1),(1861,'the part after the scheme is the uri location of the stylesheet to use',1),(1862,'camel will look in the classpath by default',1),(1863,'as mentioned before, the camel xslt component leverages spring to load the stylesheet',1),(1864,'you can prefix the resource name with any of the three prefixes listed in table 3',1),(1865,'let’s leave the xslt world now and take a look at how you can do xml-to-object marshaling with camel',1),(1866,'2 prefixes supported by the xslt component for loading stylesheetsprefix example description<none> xslt://camelinaction/ transform',1),(1867,'xslif no prefix is provided, camel loads the resource from the classpathclasspath: xslt://classpath:com/ mycompany/transform',1),(1868,'xmlloads the resource from the classpathfile: xslt://file:/rider/config/ transform',1),(1869,'xmlloads the resource from the filesystemhttp: xslt://http://rider',1),(1870,'com/ styles/transform',1),(1871,'xslloads the resource from an urlxsltcomponentstylesheetfilemessagedtransformedmessagefileconsumerjmsproducerb c dfigure 3',1),(1872,'5 a camel route using an xslt component to transform an xml document before it’s sent to a jms queue    www',1),(1873,'info75transforming xml3',1),(1874,'2 transforming xml with object marshalingany software engineer who has worked with xml knows that it’s a challenge to use the low-level xml api that java offers',1),(1875,'instead, people often prefer to work with regular java objects and use marshaling to transform between java objects and xml representations',1),(1876,'in camel, this marshaling process is provided in ready-to-use components known as data formats',1),(1877,'we’ll cover data formats in full detail in section 3',1),(1878,'4, but we’ll take a quick look at the xstream and jaxb data formats here as we cover xml transformations using marshaling',1),(1879,'transforming using xstreamxstream is a simple library for serializing objects to xml and back again',1),(1880,'to use it, you need camel-xstream',1),(1881,'jar on the classpath and the xstream library itself',1),(1882,'suppose you need to send messages in xml format to a shared jms queue, which is then used to integrate two systems',1),(1883,'let’s look at how this can be done',1),(1884,'<camelcontext id=\"camel\" xmlns=\"http://camel',1),(1885,'org/schema/spring\">    <dataformats>        <xstream id=\"myxstream\"/>           </dataformats>    <route>        <from uri=\"direct:foo\"/>        <marshal ref=\"myxstream\"/>                 <to uri=\"activemq:queue:foo\"/>    </route> </camelcontext>when...',1),(1886,'by doing this, you can share the data formats in multiple routes',1),(1887,'in the first route, where you send messages to a jms queue, you use marshal c, which refers to the id from b, so camel knows that the xstream data format is being used',1),(1888,'you can also use the xstream data format directly in the route, which can shorten the syntax a bit, like this:<route>    <from uri=\"direct:foo\"/>    <marshal><xstream/></marshal>    <to uri=\"activemq:queue:foo\"/> </route>the same route is a bit short...',1),(1889,'marshal()',1),(1890,'xstream()',1),(1891,'to(\"uri:activemq:queue:foo\");yes, using xstream is that simple',1),(1892,'and the reverse operation, unmarshaling from xml to an object, is just as simple:listing 3',1),(1893,'4 using xstream to transform a message into xml specifies xstream data formatbtransforms to xmlc    www',1),(1894,'info76 chapter 3 transforming data with camel<route>    <from uri=\"activemq:queue:foo\"/>    <unmarshal ref=\"myxstream\"/>    <to uri=\"direct:handlefoo\"/> </route>you’ve now seen how easy it is to use xstream with camel',1),(1895,'let’s take a look at using jaxb with camel',1),(1896,'transforming using jaxbjaxb (java architecture for xml binding) is a standard specification for xml binding, and it’s provided out of the box in the java runtime',1),(1897,'like xstream, it allows you to serialize objects to xml and back again',1),(1898,'it’s not as simple, but it does offer more bells and whistles for controlling the xml output',1),(1899,'and because it’s distributed in java, you don’t need any special jar files on the classpath',1),(1900,'unlike xstream, jaxb requires that you do a bit of work to declare the binding between java objects and the xml form',1),(1901,'this is often done using annotations',1),(1902,'suppose you define a model bean to represent an order, as shown in listing 3',1),(1903,'5, and you want to transform this into xml before sending it to a jms queue',1),(1904,'then you want to transform it back to the order bean again when consuming from the jms queue',1),(1905,'this can be done as shown in listings 3',1),(1906,'xmlaccesstype; import javax',1),(1907,'xmlaccessortype; import javax',1),(1908,'xmlrootelement;@xmlrootelement                      @xmlaccessortype(xmlaccesstype',1),(1909,'field)        public class purchaseorder {             @xmlattribute     private string name;    @xmlattribute    private double price;    @xmlattribute    private double amount; }listing 3',1),(1910,'5 shows how to use jaxb annotations to decorate your model object (omitting the usual getters and setters)',1),(1911,'first you define @xmlrootelement b as a class-level annotation to indicate that this class is an xml element',1),(1912,'then you define the @xmlaccessortype to let jaxb access fields directly',1),(1913,'to expose the fields of this model object as xml attributes, you mark them with the @xmlattribute annotation',1),(1914,'using jaxb, you should be able to marshal a model object into an xml representation like this:<purchaseorder name=\"camel in action\" price=\"4995\" amount=\"1\"/>listing 3',1),(1915,'5 annotating a bean with jaxb so it can be transformed to and from xmlb purchaseorder class is jaxb annotated    www',1),(1916,'info77transforming with data formatslisting 3',1),(1917,'6 shows how you can use jaxb in routes to transform the purchaseorder object to xml before it’s sent to a jms queue, and then back again from xml to the purchaseorder object when consuming from the same jms queue',1),(1918,'<camelcontext id=\"camel\" xmlns=\"http://camel',1),(1919,'org/schema/spring\">    <dataformats>        <jaxb id=\"jaxb\" contextpath=\"camelinaction\"/>          </dataformats>    <route>        <from uri=\"direct:order\"/>        <marshal ref=\"jaxb\"/>                        <to uri=\"activemq:queue:order\"/>    </r...',1),(1920,'note that a contextpath attribute is also defined on the jaxb data format—this is a package name that instructs jaxb to look in this package for classes that are jaxb-annotated',1),(1921,'the first route then marshals to xml c and the second route unmarshals to transform the xml back into the purchaseorder object d',1),(1922,'you can try this example by running the following maven goal from the chapter3/ order directory:mvn test -dtest=purchaseorderjaxbtestnote to tell jaxb which classes are jaxb-annotated, you need to drop a special jaxb',1),(1923,'it’s a plain text file in which each line lists the class name',1),(1924,'in the preceding example, the file contains a single line with the text purchaseorder',1),(1925,'that’s the basis of using xml object marshaling with xstream and jaxb',1),(1926,'both of them are implemented in camel via data formats that are capable of transforming back and forth between various well-known formats',1),(1927,'4 transforming with data formatsin camel, data formats are pluggable transformers that can transform messages from one form to another and vice versa',1),(1928,'each data format is represented in camel as an interface in org',1),(1929,'dataformat containing two methods: ■ marshal—for marshaling a message into another form, such as marshaling java objects to xml, csv, edi, hl7, or other well-known data models■ unmarshal—for performing the reverse operation, which turns data from wel...',1),(1930,'6 using jaxb to serialize objects to and from xmldeclares jaxb data formatbtransforms from model to xmlctransforms from xml to modeld    www',1),(1931,'info78 chapter 3 transforming data with camelyou may already have realized that these two functions are opposites, meaning that one is capable of reversing what the other has done, as illustrated in figure 3',1),(1932,'we touched on data formats in section 3',1),(1933,'3, where we covered xml transformations',1),(1934,'this section will cover data formats in more depth and using other data types than xml, such as csv and json',1),(1935,'we’ll start our journey by briefly looking at the data formats camel provides out of the box',1),(1936,'1 data formats provided with camelcamel provides data formats for a range of well-known data models, as listed in table 3',1),(1937,'3 data formats provided out of the box with cameldata format data model artifact descriptionbindy csv, fix, fixed lengthcamel-bindy binds various data models to model objects using annotationscastor xml camel-castor uses castor for xml binding to and...',1),(1938,'x standard for xml binding to and from java objectsjackson json camel-jackson transforms to and from json using the ultra-fast jackson libraryprotobuf xml camel-protobuf transforms to and from xml using the google protocol buffers librarysoap xml cam...',1),(1939,'unmarshalattributeattributeclassfigure 3',1),(1940,'6 an object is marshaled to a binary representation; unmarshalcan be used to get the object back',1),(1941,'info79transforming with data formatsas you can see, camel provides 18 data formats out of the box',1),(1942,'we’ve picked 3 to cover in the following section',1),(1943,'they’re among the most commonly used, and what you learn about those will also apply for the remainder of the data formats',1),(1944,'you can read more about all these data formats at the camel website (http://camel',1),(1945,'2 using camel’s csv data formatthe camel-csv data format is capable of transforming to and from csv format',1),(1946,'it leverages apache commons csv to do the actual work',1),(1947,'suppose you need to consume csv files, split out each row, and send it to a jms queue',1),(1948,'sounds hard to do, but it’s possible with little effort in a camel route:from(\"file://rider/csvfiles\")',1),(1949,'unmarshal()',1),(1950,'csv()',1),(1951,'csv',1),(1952,'record\");all you have to do is unmarshal the csv files, which will read the file line by line and store all lines in the message body as a java',1),(1953,'list<list> type',1),(1954,'then you use the splitter to split up the body, which will break the java',1),(1955,'list<list<string>> into rows (each row represented as another list<string> containing the fields) and send each row to the jms queue',1),(1956,'you may not want to send each row as a list type to the jms queue, so you can transform the row before sending, perhaps using a processor',1),(1957,'the same example in spring xml is a bit different, as shown here:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(1958,'org/schema/spring\">    <route>        <from uri=\"file://rider/csvfiles\"/>        <unmarshal><csv/></unmarshal>serialization object camel-core uses java object serialization to transform objects to and from a serialized streamtidymarkup html camel-tag...',1),(1959,'3 data formats provided out of the box with camel (continued)data format data model artifact description    www',1),(1960,'info80 chapter 3 transforming data with camel        <split>            <simple>body</simple>            <to uri=\"activemq:queue',1),(1961,'csv',1),(1962,'record\"/>        </split>    </route> </camelcontext>the noticeable difference is how you tell <split> that it should split up the message body',1),(1963,'to do this you need to provide <split> with an expression, which is what the splitter should iterate when it performs the splitting',1),(1964,'to do so, you can use camel’s built-in expression language called simple (see appendix a), which knows how to do that',1),(1965,'note the splitter eip is fully covered in section 8',1),(1966,'1 of this book',1),(1967,'this example is in the source code for the book in the chapter3/order directory',1),(1968,'you can try the examples by running the following maven goals:mvn test -dtest=purchaseordercsvtest mvn test -dtest=purchaseordercsvspringtestat first, the data types that the csv data format uses may seem a bit confusing',1),(1969,'they’re listed in table 3',1),(1970,'one problem with camel-csv is that it uses generic data types, such as maps or lists, to represent csv records',1),(1971,'often you’ll already have model objects to represent your data in memory',1),(1972,'let’s look at how you can use model objects with the camel-bindy component',1),(1973,'3 using camel’s bindy data formatthe two existing csv-related data formats (camel-csv and camel-flatpack) are older libraries that don’t take advantage of the new features in java 1',1),(1974,'5, such as annotations and generics',1),(1975,'in light of this deficiency, charles moulliard stepped up and wrote the camel-bindy component to take advantage of these new possibilities',1),(1976,'it’s capable of binding csv, fix, and fixed-length formats to existing model objects using annotations',1),(1977,'this is similar to what jaxb does for xml',1),(1978,'4 data types that camel-csv uses when transforming to and from csv formatoperation from type to type descriptionmarshal map<string, object>outputstream contains a single row in csv formatmarshal list<map<string, object>>outputstream contains multiple...',1),(1979,'info81transforming with data formats suppose you have a model object that represents a purchase order',1),(1980,'by annotating the model object with camel-bindy annotations, you can easily transform messages between csv and java model objects',1),(1981,'csvrecord; import org',1),(1982,'datafield;@csvrecord(separator = \",\", crlf = \"unix\")            public class purchaseorder {    @datafield(pos = 1)                        private string name;    @datafield(pos = 2, precision = 2)        private bigdecimal price;    @datafield(pos =...',1),(1983,'then you annotate the fields with @datafield according to the layout of the csv record c',1),(1984,'using the pos attribute, you can dictate the order in which they’re outputted in csv; pos starts with a value of 1',1),(1985,'for numeric fields, you can additionally declare precision, which in this example is set to 2, indicating that the price should use two digits for cents',1),(1986,'bindy also has attributes for fine-grained layout of the fields, such as pattern, trim, and length',1),(1987,'you can use pattern to indicate a data pattern, trim to trim the input, and length to restrict a text description to a certain number of characters',1),(1988,'before we look at how to use bindy in camel routes, we need to take a step back and look at the data types bindy expects to use',1),(1989,'they’re listed in table 3',1),(1990,'5 is that bindy uses a map<string, object> to represent a csv row',1),(1991,'at first, this may seem odd',1),(1992,'why doesn’t it just use a single model object for that',1),(1993,'the answer is that you can have multiple model objects with the csvlisting 3',1),(1994,'7 model object annotated for csv transformationtable 3',1),(1995,'5 data types that bindy uses when transforming to and from csv formatoperation from type to type output descriptionmarshal list<map<string, object>>outputstream contains multiple rows in csv format where each row is separated by a \\n (newline)unmarsh...',1),(1996,'n data models contained in a mapmaps to csv recordbmaps to column in csv recordc    www',1),(1997,'info82 chapter 3 transforming data with camelrecord being scattered across those objects',1),(1998,'for example, you could have fields 1 to 3 in one model object, fields 4 to 9 in another, and fields 10 to 12 in a third',1),(1999,'the map entry <string, object> is distilled as follows:■ map key (string)—must contain the fully qualified class name of the model object■ map value (object)—must contain the model objectif this seems a bit confusing, don’t worry',1),(2000,'the following example should make it clearer',1),(2001,'public class purchaseorderbindytest extends testcase {public void testbindy() throws exception {    camelcontext context = new defaultcamelcontext();    context',1),(2002,'addroutes(createroute());    context',1),(2003,'getendpoint(\"mock:result\",                                            mockendpoint',1),(2004,'class);    mock',1),(2005,'expectedbodiesreceived(\"camel in action,49',1),(2006,'95,1\\n\");    purchaseorder order = new purchaseorder();            order',1),(2007,'sendbody(\"direct:tocsv\", order);              mock',1),(2008,'assertissatisfied(); }public routebuilder createroute() {    return new routebuilder() {        public void configure() throws exception {            from(\"direct:tocsv\")',1),(2009,'marshal()',1),(2010,'csv,                                  \"camelinaction',1),(2011,'to(\"mock:result\");        }    }; }in this listing, you first create and populate the order model using regular java setters b',1),(2012,'then you send the order model to the route by sending it to the direct:tocsv endpoint c that is used in the route',1),(2013,'the route will then marshal the order model to csv using bindy d',1),(2014,'notice how bindy is configured to use csv mode via bindytype',1),(2015,'csv',1),(2016,'to let bindy know how to map to order model object, you need to provide a package name that will be scanned for classes annotated with bindy annotations',1),(2017,'this is the same solution jaxb offers',1),(2018,'note listing 3',1),(2019,'8 uses mockendpoint to easily test that the csv record is as expected',1),(2020,'chapter 6 will covered testing with camel, and you’ll learn all about using mockendpoints',1),(2021,'listing 3',1),(2022,'8 using bindy to transform a model object to csv formatcreates model object as usualbstarts testctransforms model object to csvd    www',1),(2023,'info83transforming with data formatsyou can try this example from the chapter3/order directory using the following maven goal:mvn test –dtest=purchaseorderbindytestthe source code for the book also contains a reverse example of how to use bindy to tr...',1),(2024,'you can try it by using the following maven goal:mvn test –dtest=purchaseorderunmarshalbindytestcsv is only one of the well-known data formats that bindy supports',1),(2025,'bindy is equally capable of working with fixed-length and fix data formats, both of which follow the same principles as csv',1),(2026,'it’s now time to leave csv and look at a more modern format: json',1),(2027,'4 using camel’s json data formatjson (javascript object notation) is a data-interchange format, and camel provides two components that support the json data format: camel-xstream and camel-jackson',1),(2028,'in this section, we’ll focus on camel-jackson because jackson is a very popular json library',1),(2029,'back at rider auto parts, you now have to implement a new service that returns order summaries rendered in json format',1),(2030,'doing this with camel is fairly easy, because camel has all the ingredients needed to brew this service',1),(2031,'listing 3',1),(2032,'9 shows how you could ramp up a prototype',1),(2033,'<bean id=\"orderservice\" class=\"camelinaction',1),(2034,'orderservicebean\"/><camelcontext id=\"camel\" xmlns=\"http://camel',1),(2035,'org/schema/spring\">    <dataformats>        <json id=\"json\" library=\"jackson\"/>              </dataformats>    <route>        <from uri=\"jetty://http://0',1),(2036,'0:8080/order\"/>                       <bean ref=\"orderservice\" method=\"lookup\"/>            <marshal ref=\"json\"/>    </route> </camelcontext>first you need to set up the json data format and specify that the jackson library should be used b',1),(2037,'then you define a route that exposes the http service using the jetty endpoint',1),(2038,'this example exposes the jetty endpoint directly in the uri',1),(2039,'by using http://0',1),(2040,'0:8080/order, you tell jetty that any client can reach this service on port 8080',1),(2041,'whenever a request hits this http service, it’s routed to the orderservice bean c and the lookup method is invoked on that bean',1),(2042,'the result of this bean invocation is then marshaled to json format and returned back to the http client',1),(2043,'the order service bean could have a method signature such as this:public purchaseorder lookup(@header(name = \"id\") string id)listing 3',1),(2044,'9 an http service that returns order summaries rendered in json formatsets up json data formatbinvokes bean to retrieve data for replyc    www',1),(2045,'info84 chapter 3 transforming data with camelthis signature allows you to implement the lookup logic as you wish',1),(2046,'you’ll learn more about the @header annotation in section 4',1),(2047,'3, when we cover how bean parameter binding works in camel',1),(2048,'notice that the service bean can return a pojo that the json library is capable of marshaling',1),(2049,'for example, suppose you used the purchaseorder from listing 3',1),(2050,'7, and had json output as follows:{\"name\":\"camel in action\",\"amount\":1',1),(2051,'95}the http service itself can be invoked by an http get request with the id of the order as a parameter: http://0',1),(2052,'0:8080/order/service',1),(2053,'notice how easy it is with camel to bind the http id parameter as the string id parameter with the help of the @header annotation',1),(2054,'you can try this example yourself from chapter3/order directory by using the following maven goal',1),(2055,'mvn test –dtest=purchaseorderjsontestso far we’ve used data formats with their default settings',1),(2056,'but what if you need to configure the data format, such as to use another splitter character with the csv data format',1),(2057,'that’s the topic of the next section',1),(2058,'5 configuring camel data formatsin section 3',1),(2059,'2, you used the csv data format, but this data format offers many additional settings',1),(2060,'this listing shows how you can configure the csv data format',1),(2061,'public void configure() {    csvconfig custom = new csvconfig();             custom',1),(2062,'setdelimiter(\';\');                               custom',1),(2063,'setendtrimmed(true);                     custom',1),(2064,'addfield(new csvfield(\"id\"));            custom',1),(2065,'addfield(new csvfield(\"customerid\"));    custom',1),(2066,'addfield(new csvfield(\"date\"));           custom',1),(2067,'addfield(new csvfield(\"item\"));                custom',1),(2068,'addfield(new csvfield(\"amount\"));         custom',1),(2069,'addfield(new csvfield(\"description\"));    csvdataformat mycsv = new csvdataformat();          mycsv',1),(2070,'setconfig(custom);                                            mycsv',1),(2071,'setautogencolumns(false);    from(\"direct:tocsv\")',1),(2072,'marshal(mycsv)',1),(2073,'to(\"file://acme/outbox/csv\"); }configuring data formats in camel is done using regular java code; you use the api that the data format provides',1),(2074,'in listing 3',1),(2075,'10, the csv data format offers a csvconfig object b that is used to set the semicolon as a delimiter and to specify the order of thelisting 3',1),(2076,'10 configuring the csv data formatconfigures custom csv data formatbcreates custom csv data formatcuses csv data formatd    www',1),(2077,'info85transforming with data formatsfields',1),(2078,'the data format itself is then created c and set to use the configuration',1),(2079,'the use of the data format stays the same, so all you need to do is refer to it from the marshal d or unmarshal methods',1),(2080,'this same principle applies to all data formats in camel',1),(2081,'you can configure them using the apis they provide',1),(2082,'now that you know how to use data formats, let’s look at how you can write your own data format',1),(2083,'6 writing your own data formatyou may find yourself needing to transform data to and from a custom data format',1),(2084,'in this section, we’ll look at how you can develop a data format that can reverse strings',1),(2085,'developing your own data format is fairly easy, because camel provides a single api you must implement: org',1),(2086,'let’s look at how you could implement a string-reversing data format',1),(2087,'dataformat;public class reversedataformat implements dataformat {                     public void marshal(exchange exchange,                               object graph, outputstream stream) throws exception {        byte[] bytes = exchange',1),(2088,'class, graph);        string body = reversebytes(bytes);        stream',1),(2089,'getbytes());                                     }    public object unmarshal(exchange exchange,                              inputstream stream) throws exception {        byte[] bytes = exchange',1),(2090,'class, stream);          string body = reversebytes(bytes);        return body;                                                       }    private static string reversebytes(byte[] data) {        stringbuilder sb = new stringbuilder(data',1),(2091,'length - 1; i >= 0; i--) {            char ch = (char) data[i];            sb',1),(2092,'append(ch);        }        return sb',1),(2093,'tostring();    } }the custom data format must implement the dataformat interface, which forces you to develop two methods: marshal b and unmarshal c',1),(2094,'that’s no surprise, as they’relisting 3',1),(2095,'11 developing a custom data format that can reverse stringsmarshals to reverse stringbunmarshals to unreverse stringc    www',1),(2096,'info86 chapter 3 transforming data with camelthe same methods you use in the route',1),(2097,'the marshal method b needs to output the result to the outputstream',1),(2098,'to do this, you need to get the message payload as a byte[], and then reverse it with a helper method',1),(2099,'note that you use the camel type converters to return the message payload as a byte[]',1),(2100,'this is very powerful and saves you from doing a manual typecast in java or trying to convert the payload yourself',1),(2101,'the unmarshal method c is nearly the same',1),(2102,'you use the camel type-converter mechanism again to provide the message payload as a byte[]',1),(2103,'unmarshal also reverses the bytes to get the data back in its original order',1),(2104,'note that in this method you return the data instead of writing it to a stream',1),(2105,'tip as a best practice, use the camel type converters instead of typecasting or converting between types yourself',1),(2106,'we’ll cover camel’s type converters in section 3',1),(2107,'to use this new data format in a route, all you have to do is define it as a spring bean and refer to it from <marshal> and <unmarshal> as follows:<bean id=\"reverse\" class=\"camelinaction',1),(2108,'reversedataformat\"/><camelcontext id=\"camel\" xmlns=\"http://camel',1),(2109,'org/schema/spring\">    <route>        <from uri=\"direct:marshal\"/>        <marshal ref=\"reverse\"/>        <to uri=\"log:marshal\"/>    </route>    <route>        <from uri=\"direct:unmarshal\"/>        <unmarshal ref=\"reverse\"/>        <to uri=\"log:unmar...',1),(2110,'it’s time to say goodbye to data formats and take a look at how you can use templating with camel for data transformation',1),(2111,'templating is extremely useful when you need to generate automatic reply emails',1),(2112,'5 transforming with templatescamel provides slick integration with two different template languages:■ apache velocity—probably the best known templating language (http://camel',1),(2113,'info87transforming with templatesthese two templating languages are fairly similar to use, so we’ll only discuss velocity here',1),(2114,'1 using apache velocityrider auto parts has implemented a new order system that must send an email reply when a customer has submitted an order',1),(2115,'your job is to implement this feature',1),(2116,'the reply email could look like this:dear customerthank you for ordering x piece(s) of xxx at a cost of xxx',1),(2117,'this is an automated email, please do not reply',1),(2118,'there are three pieces of information in the email that must be replaced at runtime with real values',1),(2119,'what you need to do is adjust the email to use the velocity template language, and then place it into the source repository as src/test/resources/email',1),(2120,'vm:dear customerthank you for ordering ${body',1),(2121,'amount} piece(s) of ${body',1),(2122,'name} at a cost of ${body',1),(2123,'this is an automated email, please do not reply',1),(2124,'notice that we’ve inserted ${ } placeholders in the template, which instructs velocity to evaluate and replace them at runtime',1),(2125,'camel prepopulates the velocity context with a number of entities that are then available to velocity',1),(2126,'those entities are listed in table 3',1),(2127,'note the entities in table 3',1),(2128,'6 also apply for other templating languages, such as freemarker',1),(2129,'6 entities prepopulated in the velocity context and that are available at runtimeentity type descriptioncamelcontext org',1),(2130,'message the input message',1),(2131,'this can clash with a reserved word in some languages; use request instead',1),(2132,'request org',1),(2133,'message the input message',1),(2134,'object the input message body',1),(2135,'headers java',1),(2136,'map the input message headers',1),(2137,'response org',1),(2138,'message the output message',1),(2139,'message the output message',1),(2140,'this can clash with a reserved word in some languages; use response instead',1),(2141,'info88 chapter 3 transforming data with camelusing velocity in a camel route is as simple as this:from(\"direct:sendmail\")',1),(2142,'setheader(\"subject\", constant(\"thanks for ordering\"))',1),(2143,'setheader(\"from\", constant(\"donotreply@riders',1),(2144,'to(\"smtp://mail',1),(2145,'user=camel&password=secret\");all you have to do is route the message to the velocity endpoint that’s configured with the template you want to use, which is the rider/mail',1),(2146,'vm file that’s loaded from the classpath by default',1),(2147,'all the template components in camel leverage the spring resource loader, which allows you to load templates from the classpath, file paths, and other such locations',1),(2148,'you can use the same prefixes listed in table 3',1),(2149,'you can try this example by going to the chapter3/order directory in the book’s source code and running the following maven goal:mvn test -dtest=purchaseordervelocitytesttip for more details on the camel velocity component, consult the online documen...',1),(2150,'we’ll now leave data transformation and look at type conversion',1),(2151,'camel has a powerful type-converter mechanism that removes all need for boilerplate type-converter code',1),(2152,'6 about camel type converterscamel provides a built-in type-converter system that automatically converts between well-known types',1),(2153,'this system allows camel components to easily work together without having type mismatches',1),(2154,'and from the camel user’s perspective, type conversions are built into the api in many places without being invasive',1),(2155,'for example, you used it in listing 3',1),(2156,'1:string custom = exchange',1),(2157,'class);the getbody method is passed the type you want to have returned',1),(2158,'under the covers, the type-converter system converts the returned type to a string if needed',1),(2159,'in this section, we’ll take a look at the insides of the type-converter system',1),(2160,'we’ll explain how camel scans the classpath on startup to register type converters dynamically',1),(2161,'we’ll also show how you can use it from a camel route, and how to build your own type converters',1),(2162,'1 how the camel type-converter mechanism worksto understand the type-converter system, you first need to know what a type converter in camel is',1),(2163,'7 illustrates the relationship between the typeconverterregistry and the typeconverters it holds',1),(2164,'typeconverterregistry typeconverter0',1),(2165,'7the typeconverterregistrycontains many typeconverters    www',1),(2166,'info89about camel type convertersthe typeconverterregistry is where all the type converters are registered when camel is started',1),(2167,'at runtime, camel uses the typeconverterregistry’s lookup method to look up a suitable typeconverter:typeconverter lookup(class<',1),(2168,'> totype, class<',1),(2169,'> fromtype);by using the typeconverter, camel can then convert one type to another using typeconverter’s convertto method, which is defined as follows:<t> t convertto(class<t> type, object value);note camel implements about 150 or more type converter...',1),(2170,'loading type converters into the registryon startup, camel loads all the type converters into the typeconverterregistry by using a classpath-scanning solution',1),(2171,'this allows camel to pick up not only type converters from camel-core but also from any of the other camel components, including your camel applications—you’ll see this in section 3',1),(2172,'to scan and load the type converters, camel uses org',1),(2173,'to avoid scanning zillions of classes, it reads a service discovery file in the meta-inf folder: meta-inf/services/org/apache/ camel/typeconverter',1),(2174,'this is a plain text file that has a list of packages that contain camel type converters',1),(2175,'the special file is needed to avoid scanning every possible jar and all their packages, which would be time consuming',1),(2176,'this special file tells camel whether or not the jar file contains type converters',1),(2177,'for example, the file in camelcore contains the following three entries:org',1),(2178,'filethe annotationtypeconverterloader will scan those packages and their subpackages for classes that have been annotated with @converter, and it searches within them for public methods that are annotated with @converter',1),(2179,'each of those methods is considered a type converter',1),(2180,'this is best illustrated with an example',1),(2181,'the following code is a snippet from ioconverter class from camel-core jar:@converter public final class ioconverter {    @converter    public static inputstream toinputstream(url url) throws ioexception {        return url',1),(2182,'openstream();    } }camel will go over each method annotated with @converter and look at the method signature',1),(2183,'the first parameter is the from type, and the return type is the to type—in this example you have a typeconverter that can convert from a url to an inputstream',1),(2184,'info90 chapter 3 transforming data with cameldoing this, camel loads all the built-in type converters, including those from the camel components in use',1),(2185,'now that you know how the camel type converters are loaded, let’s look at using them',1),(2186,'2 using camel type convertersas we mentioned, the camel type converters are used throughout camel, often automatically',1),(2187,'but you might want to use them to force a specific type to be used in a route, such as before sending data back to a caller or a jms destination',1),(2188,'let’s look at how to do that',1),(2189,'suppose you need to route files to a jms queue using javax',1),(2190,'textmessage',1),(2191,'to do so, you can convert each file to a string, which forces the jms component to use textmessage',1),(2192,'this is easy to do in camel—you use the convertbodyto method, as shown here:from(\"file://riders/inbox\")',1),(2193,'class)',1),(2194,'to(\"activemq:queue:inbox\");if you’re using spring xml, you provide the type as an attribute instead, like this:<route>    <from uri=\"file://riders/inbox\"/>    <convertbodyto type=\"java',1),(2195,'prefix on the type, which can shorten the syntax a bit: <convertbodyto type=\"string\"/>',1),(2196,'another reason for using convertbodyto is to read files using a fixed encoding such as utf-8',1),(2197,'this is done by passing in the encoding as the second parameter:from(\"file://riders/inbox\")',1),(2198,'class, \"utf-8\")',1),(2199,'to(\"activemq:queue:inbox\");tip if you have trouble with a route because of the payload or its type, try using',1),(2200,'class) at the start of the route to convert to a string type, which is a well-supported type',1),(2201,'if the payload cannot be converted to the desired type, a notypeconversionavailableexception exception is thrown',1),(2202,'that’s all there is to using type converters in camel routes',1),(2203,'before we wrap up this chapter, though, let’s take a look at how you can write your own type converter',1),(2204,'3 writing your own type converterwriting your own type converter is easy in camel',1),(2205,'you already saw what a type converter looks like in section 3',1),(2206,'1, when we looked at how type converters work',1),(2207,'info91about camel type converters suppose you wanted to write a custom type converter that can convert a byte[] into a purchaseorder model object (an object you used in listing 3',1),(2208,'as you saw earlier, you need to create a @converter class containing the type-converter method',1),(2209,'@converter public final class purchaseorderconverter     @converter    public static purchaseorder topurchaseorder(byte[] data,                                                 exchange exchange) {         typeconverter converter = exchange',1),(2210,'gettypeconverter();                       string s = converter',1),(2211,'class, data);        if (s == null || s',1),(2212,'length() < 30) {            throw new illegalargumentexception(\"data is invalid\");        }        s = s',1),(2213,'replaceall(\"##start##\", \"\");             s = s',1),(2214,'substring(0, 9)',1),(2215,'trim();        string s2 = s',1),(2216,'substring(10, 19)',1),(2217,'trim();        bigdecimal price = new bigdecimal(s2);         price',1),(2218,'setscale(2);                                     string s3 = s',1),(2219,'substring(20)',1),(2220,'class, s3);        return new purchaseorder(name, price, amount);     } }in listing 3',1),(2221,'12, the exchange gives you access to the camelcontext and thus to the parent typeconverter b, which you use in this method to convert between strings and numbers',1),(2222,'the rest of the code is the logic for parsing the custom protocol and returning the purchaseorder c',1),(2223,'notice how you can use the converter to easily convert between well-known types',1),(2224,'all you need to do now is add the service discovery file, named typeconverter, in the meta-inf directory',1),(2225,'as explained previously, this file contains one line identifying each package to be scanned for @converter classes',1),(2226,'if you cat the magic file, you’ll see this:cat src/main/resources/meta-inf/services/org/apache/camel/typeconverter camelinactionthis example can be found in the chapter3/converter directory of the book’s source code, which you can try using the follo...',1),(2227,'listing 3',1),(2228,'12 a custom type converter to convert from byte[] to purchaseorder typegrabstypeconverter  to reusebconverts from string to purchaseorderc    www',1),(2229,'info92 chapter 3 transforming data with camel3',1),(2230,'7 summary and best practicesdata transformation is the cornerstone of any integration kit; it bridges the gap between different data types and formats',1),(2231,'it’s also essential in today’s industry because more and more disparate systems need to be integrated to support the ever-changing businesses and world we live in',1),(2232,'this chapter covered many of the possibilities camel offers for data transformation',1),(2233,'you learned how to format messages using eips and beans',1),(2234,'you also learned that camel provides special support for transforming xml documents using xslt components and xml-capable data formats',1),(2235,'camel provides data formats for well-known data models, which you learned to use, and it even allows you to build your own data formats',1),(2236,'we also took a look into the templating world, which can be used to format data in specialized cases, such as generating email bodies',1),(2237,'finally, we looked at how the camel type-converter mechanism works and learned that it’s used internally to help all the camel components work together',1),(2238,'you learned how to use it in routes and how to write your own converters',1),(2239,'here are a few key tips you should take away from this chapter:■ data transformation is often required',1),(2240,'integrating it systems often requires you to use different data formats when exchanging data',1),(2241,'camel can act as the mediator and has strong support for transforming data in any way possible',1),(2242,'use the various features in camel to aid with your transformation needs',1),(2243,'■ java is powerful',1),(2244,'using java code isn’t a worse solution than using a fancy mapping tool',1),(2245,'don’t underestimate the power of the java language',1),(2246,'even if it takes 50 lines of grunt boilerplate code to get the job done, you have a solution that can easily be maintained by fellow engineers',1),(2247,'■ prefer to use beans over processors',1),(2248,'if you’re using java code for data transformation, you can use beans or processors',1),(2249,'processors are more dependent on the camel api, whereas beans allow loose coupling',1),(2250,'we’ll cover how to use beans in chapter 4',1),(2251,'in the preceding two chapters, we’ve covered two crucial features of integration kits: routing and transformation',1),(2252,'the next chapter dives into the world of beans, and you’ll see how camel can easily adapt to and leverage your existing beans',1),(2253,'this allows a higher degree of reuse and loose coupling, so you can keep your business and integration logic clean and apart from camel and other middleware apis',1),(2254,'info93using beans with camelif you’ve been developing software for five years or longer, you’ve likely worked with different component models, such as corba, ejb, jbi, sca, and lately osgi',1),(2255,'some of these models, especially the earlier ones, imposed a great deal on the programming model, dictating what you could and couldn’t do, and they often required complex packaging and deployment models',1),(2256,'this left the everyday engineer with a lot of concepts to learn and master',1),(2257,'in some cases, much more time was spent working around the restrictive programming and deployment models than on the business application itself',1),(2258,'because of this growing complexity and the resulting frustrations, a simpler, more pragmatic programming model arose from the open source community: the pojo model',1),(2259,'later this was formalized as the spring framework',1),(2260,'the spring framework has opened the door to the enterprise, proving that the pojo programming model and a lightweight container indeed meet thethis chapter covers■ understanding the service activator eip■ how camel looks up beans using registries■ ho...',1),(2261,'info94 chapter 4 using beans with camelexpectations of today’s businesses',1),(2262,'in fact, the simple programming model and lightweight container concept proved superior to the heavyweight and over-complex enterprise application and integration servers that were used before',1),(2263,'so what does this have to do with camel',1),(2264,'well, camel doesn’t mandate using a specific component or programming model',1),(2265,'it doesn’t mandate a heavy specification that you must learn and understand to be productive',1),(2266,'camel doesn’t require you to repackage any of your existing libraries or require you to use the camel api to fulfill your integration needs',1),(2267,'camel is on the same page as the spring framework, with both of them being lightweight containers favoring the pojo programming model',1),(2268,'in fact, camel recognizes the power of the pojo programming model and goes great lengths to work with your beans',1),(2269,'by using beans, you fulfill an important goal in the software industry, which is to reduce coupling',1),(2270,'camel not only offers reduced coupling with beans, but you get the same loose coupling with camel routes',1),(2271,'for example, three teams can work simultaneously on their own sets of routes, which can easily be combined into one system',1),(2272,'we’ll start this chapter by showing you how not to use beans with camel, which will make it clearer how you should use beans',1),(2273,'after that, we’ll take a look at the theory behind the service activator eip and dive inside camel to see how this pattern is implemented',1),(2274,'finally, we’ll look at the bean-binding process, which gives you finegrained control over binding information to the parameters on the invoked method from within camel and the currently routed message',1),(2275,'it may sound confusing at first, but don’t worry—it will make sense shortly',1),(2276,'1 using beans the hard way and the easy wayin this section, we’ll walk through an example that shows how not to use beans with camel—the hard way to use beans',1),(2277,'then we’ll look at how to use beans the easy way',1),(2278,'suppose you have an existing bean that offers an operation (a service) you need to use in your integration application',1),(2279,'for example, hellobean offers the hello method as its service:public class hellobean {    public string hello(string name) {        return \"hello \" + name;    } }let’s look at some different ways you could use this bean in your application',1),(2280,'1 invoking a bean from pure javaby using a camel processor, you can invoke a bean from java code',1),(2281,'public class invokewithprocessorroute extends routebuilder {public void configure() throws exception {    from(\"direct:hello\")',1),(2282,'process(new processor() {           listing 4',1),(2283,'1 using a processor to invoke the hello method on the hellobeanuses a processorb    www',1),(2284,'info95using beans the hard way and the easy way            public void process(exchange exchange) throws exception {                string name = exchange',1),(2285,'class);                  hellobean hello = new hellobean();                 string answer = hello',1),(2286,'setbody(answer);            }        }); }listing 4',1),(2287,'1 shows a routebuilder, which defines the route',1),(2288,'you use an inlined camel processor b, which gives you the process method, in which you can work on the message with java code',1),(2289,'first, you must extract the message body from the input message, which is the parameter you’ll use when you invoke the bean later',1),(2290,'then you need to instantiate the bean and invoke it c',1),(2291,'finally you must set the output from the bean on the output message',1),(2292,'now that you’ve done it the hard way using the java dsl, let’s take a look at using spring xml',1),(2293,'2 invoking a bean defined in springyou’ll often use spring as a bean container and define beans using its xml files',1),(2294,'listings 4',1),(2295,'3 show how to revise listing 4',1),(2296,'1 to work with a spring bean this way',1),(2297,'<bean id=\"hellobean\" class=\"camelinaction',1),(2298,'hellobean\"/>    <bean id=\"route\" class=\"camelinaction',1),(2299,'invokewithprocessorspringroute\"/><camelcontext id=\"camel\" xmlns=\"http://camel',1),(2300,'org/schema/spring\">    <routebuilder ref=\"route\"/> </camelcontext>first you define hellobean in the spring xml file with the id hellobean b',1),(2301,'you still want to use the java dsl to build the route, so you need to declare a bean that contains the route',1),(2302,'finally, you define a camelcontext, which is the way you get spring and camel to work together',1),(2303,'now let’s take a closer look at the route',1),(2304,'public class invokewithprocessorspringroute extends routebuilder {    @autowired                                     private hellobean hello;    public void configure() throws exception {        from(\"direct:hello\")',1),(2305,'process(new processor() {                public void process(exchange exchange) throws exception {                    string name = exchange',1),(2306,'class);                    string answer = hello',1),(2307,'setbody(answer);listing 4',1),(2308,'2 setting up spring to use a camel route that uses the hellobeanlisting 4',1),(2309,'3 a camel route using a processor to invoke hellobeanc invokes hellobeandefines b hellobeaninjects hellobeanbinvokes hellobeanc    www',1),(2310,'info96 chapter 4 using beans with camel                }            });    } }the route in listing 4',1),(2311,'3 is nearly identical to the route in listing 4',1),(2312,'the difference is that now the bean is injected using the spring @autowired annotation b, and instead of instantiating the bean, you use the injected bean directly c',1),(2313,'you can try these examples on your own; they’re in the chapter4/bean directory of the book’s source code',1),(2314,'run maven with these goals to try the last two examples:mvn test -dtest=invokewithprocessortest mvn test -dtest=invokewithprocessorspringtestso far you’ve seen two examples of using beans with a camel route, and there’s a bit of plumbing to get it al...',1),(2315,'here are some reasons why it’s hard to work with beans:■ you must use java code to invoke the bean',1),(2316,'■ you must use the camel processor, which clutters the route, making it harder to understand what happens (route logic is mixed in with implementation logic)',1),(2317,'■ you must extract data from the camel message and pass it to the bean, and you must move any response from the bean back into the camel message',1),(2318,'■ you must instantiate the bean yourself, or have it dependency-injected',1),(2319,'now let’s look at the easy way of doing it',1),(2320,'3 using beans the easy waysuppose you were to define the camel route in the spring xml file instead of using a routebuilder class',1),(2321,'the following snippet shows how this might be done:<bean id=\"hellobean\" class=\"camelinaction',1),(2322,'hellobean\"/><camelcontext id=\"camel\" xmlns=\"http://camel',1),(2323,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>         < what goes here >                </route> </camelcontext>first you define the bean as a spring bean, and then you define the camel route with the direct:start input',1),(2324,'at b you want to invoke hellobean, but you’re in trouble— this is xml, and you can’t add java code in the xml file',1),(2325,'in camel, the easy way to use beans is to use the <bean> tag at b:<bean ref=\"hellobean\" method=\"hello\"/>that gives you the following route:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(2326,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>insert something here to use beansb    www',1),(2327,'info97the service activator pattern        <bean ref=\"hellobean\" method=\"hello\"/>    </route> </camelcontext>camel offers the same solution when using the java dsl',1),(2328,'you can simplify the route in listing 4',1),(2329,'3 like this:public void configure() throws exception {    from(\"direct:hello\")',1),(2330,'beanref(\"hellobean\", \"hello\"); }that’s a staggering reduction from eight lines of code to one',1),(2331,'and on top of that, the one code line is much easier to understand',1),(2332,'it’s all high-level abstraction, containing no low-level code details, which were required when using inlined processors',1),(2333,'you could even omit the hello method, because the bean only has a single method:public void configure() throws exception {    from(\"direct:hello\")',1),(2334,'beanref(\"hellobean\"); }using the <bean> tag is an elegant solution for working with beans',1),(2335,'without using that tag, you had to use a camel processor to invoke the bean, which is a tedious solution',1),(2336,'tip in the java dsl, you don’t have to preregister the bean in the registry',1),(2337,'instead, you can provide the class name of the bean, and camel will instantiate the bean on startup',1),(2338,'the previous example could be written simply as from(\"direct:hello\")',1),(2339,'class);',1),(2340,'now let’s look at how you can work with beans in camel from the eip perspective',1),(2341,'2 the service activator patternthe service activator pattern is an enterprise pattern described in hohpe and woolf’s enterprise integration patterns book (http://www',1),(2342,'enterpriseintegrationpatterns',1),(2343,'it describes a service that can be invoked easily from both messaging and non-messaging services',1),(2344,'1 illustrates this principle',1),(2345,'1 shows a service activator component that invokes a service based on an incoming request and returns an outbound reply',1),(2346,'the service activator acts as a mediator between the requester and the pojo service',1),(2347,'the requester sends a request to the service activator b, which is responsible for adapting the request to a format the pojo service understands (mediating) and passing the request on to the service c',1),(2348,'requester pojoserviceserviceactivatorrequestreplyb cdefigure 4',1),(2349,'1 the service activator mediates between the requestor and the pojo service',1),(2350,'info98 chapter 4 using beans with camelthe pojo service then returns a reply to the service activator d, which passes it back (requiring no translation on the way back) to the waiting requester e',1),(2351,'as you can see in figure 4',1),(2352,'1, the service is the pojo and the service activator is something in camel that can adapt the request and invoke the service',1),(2353,'that something is the camel bean component, which eventually uses the org',1),(2354,'beanprocessor to do the work',1),(2355,'we’ll look at how this beanprocessor works in section 4',1),(2356,'you should regard the camel bean component as the camel implementation of the service activator pattern',1),(2357,'1 to the camel route example we looked at in section 4',1),(2358,'3, as illustrated in figure 4',1),(2359,'2 shows how the camel route maps to the service activator eip',1),(2360,'the requester is the node that comes before the bean—it’s the from(\"direct:hello\") in our example',1),(2361,'the service activator itself is the bean node, which is represented by the beanprocessor in camel',1),(2362,'and the pojo service is the hellobean bean itself',1),(2363,'you now know the theory behind how camel works with beans—the service activator pattern',1),(2364,'but before you can use a bean, you need to know where to look for it',1),(2365,'this is where the registry comes into the picture',1),(2366,'let’s look at how camel works with different registries',1),(2367,'3 camel’s bean registrieswhen camel works with beans, it looks them up in a registry to locate them',1),(2368,'camel’s philosophy is to leverage the best of the available frameworks, so it uses a pluggable registry architecture to integrate them',1),(2369,'spring is one such framework, and figure 4',1),(2370,'3 illustrates how the registry works',1),(2371,'requester pojoserviceserviceactivatorrequestreplyfrom(\"direct:hello\") bean(hellobean',1),(2372,'class) hellobeanfigure 4',1),(2373,'2 relationship between a camel route and the service activator eiprequester registry applicationcontextlookupgetbeanbcdfigure 4',1),(2374,'3 a requester looks up a bean using the camel registry, which then uses the spring applicationcontextto determine where the bean resides',1),(2375,'info99camel’s bean registriesfigure 4',1),(2376,'3 shows that the camel registry is an abstraction that sits between the caller and the real registry',1),(2377,'when a requester needs to look up a bean b, it uses the camel registry',1),(2378,'the camel registry then does the lookup via the real registry c',1),(2379,'the bean is then returned to the requester d',1),(2380,'this structure allows loose coupling but also a pluggable architecture that integrates with multiple registries',1),(2381,'all the requester needs to know is how to interact with the camel registry',1),(2382,'the registry in camel is merely a service provider interface (spi) defined in the org',1),(2383,'registry interface, as follows:object lookup(string name);<t> t lookup(string name, class<t> type)<t> map<string, t> lookupbytype(class<t> type)you’ll most often use one of the first two methods to look up a bean by its name',1),(2384,'for example, to look up the hellobean, you would do this:hellobean hello = (hellobean) context',1),(2385,'getregistry()',1),(2386,'lookup(\"hellobean\");to get rid of that ugly typecast, you can use the second method instead:hellobean hello = context',1),(2387,'getregistry()',1),(2388,'class);note the second method offers typesafe lookups because you provide the expected class as the second parameter',1),(2389,'under the hood, camel uses its typeconverter mechanism to convert the bean to the desired type, if necessary',1),(2390,'the last method, lookupbytype, is mostly used internally by camel to support convention over configuration—it allows camel to look up beans by type without knowing the bean name',1),(2391,'the registry itself is an abstraction and thus an interface',1),(2392,'1 lists the four implementations shipped with camel',1),(2393,'1 registry implementations shipped with camelregistry descriptionsimpleregistry a simple implementation to be used when unit testing or running camel in the google app engine, where only a limited number of jdk classes are available',1),(2394,'jndiregistry an implementation that uses an existing java naming and directory interface (jndi) registry to look up beans',1),(2395,'applicationcontextregistry an implementation that works with spring to look up beans in the spring applicationcontext',1),(2396,'this implementation is automatically used when you’re using camel in a spring environment',1),(2397,'osgiserviceregistry an implementation capable of looking up beans in the osgi service reference registry',1),(2398,'this implementation is automatically used when using camel in an osgi environment',1),(2399,'info100 chapter 4 using beans with camelin the following sections, we’ll go over each of these four registries',1),(2400,'1 simpleregistrythe simpleregistry is a map-based registry that’s used for testing or when running camel standalone',1),(2401,'for example, if you wanted to unit test the hellobean example, you could use the simpleregistry to enlist the hellobean and refer to it from the route',1),(2402,'public class simpleregistrytest extends testcase {    private camelcontext context;    private producertemplate template;    protected void setup() throws exception {        simpleregistry registry = new simpleregistry();        registry',1),(2403,'put(\"hellobean\", new hellobean());                 context = new defaultcamelcontext(registry);            template = context',1),(2404,'addroutes(new routebuilder() {            public void configure() throws exception {                from(\"direct:hello\")',1),(2405,'start();    }    protected void teardown() throws exception {        template',1),(2406,'stop();    }    public void testhello() throws exception {        object reply = template',1),(2407,'requestbody(\"direct:hello\", \"world\");         assertequals(\"hello world\", reply);    } }first you create an instance of simpleregistry and populate it with hellobean under the hellobean name b',1),(2408,'then, to use this registry with camel, you pass the registry as a parameter to the defaultcamelcontext constructor c',1),(2409,'to aid when testing, you create a producertemplate, which makes it simple to send messages to camel, as can be seen in the test method',1),(2410,'finally, when the test is done, you clean up the resources by stopping camel d',1),(2411,'in the route, you use the beanref method to invoke hellobean by the hellobean name you gave it when it was enlisted in the registry b',1),(2412,'you can try this test by going to the chapter4/bean directory and running this maven goal: mvn test -dtest=simpleregistrytestnow let’s look at the next registry: jndiregistry',1),(2413,'listing 4',1),(2414,'4 using simpleregistry to unit test a camel route   uses simpleregistry with camelccleans up resources after testd    www',1),(2415,'info101camel’s bean registries4',1),(2416,'2 jndiregistrythe jndiregistry, as its name implies, integrates with a jndi-based registry',1),(2417,'it was the first registry that camel integrated, so it’s also the default registry if you create a camel instance without supplying a specific registry, as this code shows:camelcontext context = new defaultcamelcontext();the jndiregistry (like the si...',1),(2418,'many of the unit tests in camel use the jndiregistry because they were created before the simpleregistry was added to camel',1),(2419,'the jndiregistry is useful when you use camel together with a java ee application server that provides a jndi-based registry out of the box',1),(2420,'suppose you need to leverage the jndi registry of a websphere application server—you would have to set up the pieces as follows:protected camelcontext createcamelcontext() throws exception {    hashtable env = new hashtable();                        ...',1),(2421,'websphere',1),(2422,'wsninitialcontextfactory\");    env',1),(2423,'provider_url,            \"corbaloc:iiop:myhost',1),(2424,'security_principal, \"username\");       env',1),(2425,'security_credentials, \"password\");    context ctx = new initialcontext(env);             jndiregistry jndi = new jndiregistry(ctx);            return new defaultcamelcontext(jndi); }you need to use a hashtable b to store information about the jndi re...',1),(2426,'after this, it’s a matter of creating the javax',1),(2427,'context that the jndiregistry should use c',1),(2428,'camel also allows you to use the jndiregistry with spring xml',1),(2429,'all you have to do is define it as a spring bean and camel will automatically pick it up:<bean id=\"registry\" class=\"org',1),(2430,'jndiregistry\"/>you can use the usual spring lingo to pass the hashtable parameter in the jndiregistry constructor',1),(2431,'the next registry is for when you use spring together with camel',1),(2432,'3 applicationcontextregistrythe applicationcontextregistry is the default registry when camel is used with spring',1),(2433,'more precisely, it’s the default when you set up camel in the spring xml, as this snippet illustrates:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(2434,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>creates hashtable containing jndi configurationbc creates jndiregistry    www',1),(2435,'info102 chapter 4 using beans with camel        <bean ref=\"hellobean\" method=\"hello\"/>    </route> </camelcontext>defining camel using the <camelcontext> tag will automatically let camel use the applicationcontextregistry',1),(2436,'this registry allows you to define beans in spring xml files as you would normally do when using spring',1),(2437,'for example, you could define the hellobean bean as follows:<bean id=\"hellobean\" class=\"camelinaction',1),(2438,'hellobean\"/>it can hardly be simpler than that',1),(2439,'when you use camel with spring, you can keep on using spring beans as you would normally, and camel will use those beans seamlessly without any configuration',1),(2440,'the final registry applies when you use camel with osgi',1),(2441,'4 osgiserviceregistrywhen camel is used in an osgi environment, camel uses a two-step lookup process',1),(2442,'first, it will look up whether a service with the name exists in the osgi service registry',1),(2443,'if not, camel will fall back and look up the name in the regular registry, such as the spring applicationcontextregistry',1),(2444,'suppose you want to expose hellobean as an osgi service',1),(2445,'you could do it as follows:<osgi:service id=\"helloservice\" interface=\"camelinaction',1),(2446,'hellobean\"              ref=\"hellobean\"/>   <bean id=\"hellobean\" class=\"camelinaction',1),(2447,'hellobean\"/>with help from the osgi:service namespace provided by spring dynamic modules (spring dm; http://www',1),(2448,'springsource',1),(2449,'org/osgi), you export the hellobean into the osgi registry under the name helloservice',1),(2450,'you can use the hellobean from a camel route the same way you’ve already learned, by referring to its osg service name:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(2451,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>        <bean ref=\"helloservice\" method=\"hello\"/>    </route> </camelcontext>it’s that simple',1),(2452,'all you have to remember is the name with which the bean was exported',1),(2453,'camel will look it up in the osgi service registry and the spring bean container for you',1),(2454,'this is convention over configuration',1),(2455,'this concludes our tour of registries',1),(2456,'next we’ll focus on how camel selects which method to invoke on a given bean',1),(2457,'info103selecting bean methods4',1),(2458,'4 selecting bean methodsyou’ve seen how camel works with beans from the route perspective',1),(2459,'now it’s time to dig down and see the moving parts in action',1),(2460,'you first need to understand the mechanism camel uses to selects the method to invoke',1),(2461,'remember, camel acts as a service activator using the beanprocessor, which sits between the caller and the actual bean',1),(2462,'at compile time there are no direct bindings, and the jvm can’t link the caller to the bean—camel must resolve this at runtime',1),(2463,'4 illustrates how the beanprocessor leverages the registry to look up the bean to invoke',1),(2464,'at runtime, a camel exchange is routed, and at a given point in the route, it reaches the beanprocessor',1),(2465,'the beanprocessor then processes the exchange, performing these general steps:1 looks up the bean in the registry2 selects the method to invoke on the bean3 binds to the parameters of the selected method (for example, using the body of the input mess...',1),(2466,'5)4 invokes the method5 handles any invocation errors that occur (any exceptions thrown from the bean will be set on the camel exchange for further error handling)6 sets the method’s reply (if there is one) as the body on the output message on the ca...',1),(2467,'the next two steps (steps 2 and 3 in the preceding list) are more complex, and we’ll cover them in the remainder of this chapter',1),(2468,'the reason why this is more complex in camel is because camel has to compute which bean and method to invoke at runtime, whereas java code is linked at compile time',1),(2469,'registrybeanprocessor(service activator)beanmethod amethod b',1),(2470,'method zinput messageoutput messageexchangelookuplookupinvokerequestreplyfigure 4',1),(2471,'4 to invoke a bean in camel, the beanprocessor looks it up in the registry, selects and adapts a method, invokes it, and passes the returned value as the reply to the camel exchange',1),(2472,'info104 chapter 4 using beans with camelwe’ll first take a look at the algorithm camel uses to select the method',1),(2473,'then we’ll look at a couple of examples and see what could go wrong and how to avoid problems',1),(2474,'1 how camel selects bean methodsunlike at compile time, when the java compiler can link method invocations together, the camel beanprocessor has to select the method to invoke at runtime',1),(2475,'suppose you have the following class:public class echobean {    string echo(string name) {        return name + \" \" + name;    } }at compile time, you can express your code to invoke the echo method like this:echobean echo = new echobean();string rep...',1),(2476,'echo(\"camel\");this will ensure that the echo method is invoked at runtime',1),(2477,'on the other hand, suppose you use the echobean in camel in a route as follows:from(\"direct:start\")',1),(2478,'class, \"echo\")',1),(2479,'to(\"log:reply\");when the compiler compiles this code, it can’t see that you want to invoke the echo method on the echobean',1),(2480,'from the compiler’s point of view, echobean',1),(2481,'class and \"echo\" are parameters to the bean method',1),(2482,'all the compiler can check is that the echobean class exists; if you had misspelled the method name, perhaps typing \"ekko\", the compiler could not catch this mistake',1),(2483,'the mistake would end up being caught at runtime, when the beanprocessor would throw a methodnotfoundexception stating that the method named ekko does not exists',1),(2484,'camel also allows you not to explicitly name a method',1),(2485,'for example, you could write the previous route as follows:why does camel need to select a method',1),(2486,'why is there more than one possible method name when you invoke a method',1),(2487,'the answer is that beans can have overloaded methods, and in some cases the method name isn’t specified either, which means camel has to pick among all methods on the bean',1),(2488,'suppose you have the following methods:string echo(string s); int echo(int number); void dosomething(string something);there are a total of three methods for camel to select among',1),(2489,'if you explicitly tell camel to use the echo method, you’re still left with two methods to choose from',1),(2490,'we’ll look at how camel resolves this dilemma',1),(2491,'info105selecting bean methodsfrom(\"direct:start\")',1),(2492,'class)',1),(2493,'to(\"log:reply\");regardless of whether the method name is explicitly given or not, camel has to compute which method to invoke',1),(2494,'let’s look at how camel chooses',1),(2495,'2 camel’s method-selection algorithm the beanprocessor uses a complex algorithm to select which method to invoke on a bean',1),(2496,'you won’t need to understand or remember every step in this algorithm—we simply want to outline what goes on inside camel to make working with beans as simple as possible for you',1),(2497,'5 shows the first part of this algorithm, and it’s continued in figure 4',1),(2498,'here’s how the algorithm selects the method to invoke:1 if the camel message contains a header with the key camelbeanmethodname, its value is used as the explicit method name',1),(2499,'go to step 5',1),(2500,'2 if a method is explicitly defined, camel uses it, as we mentioned at the start of this section',1),(2501,'go to step 5',1),(2502,'12invokeprocessor34 invokebean5nonononoyesyesyesyesstartdoes it have a camelbeanmethodname header',1),(2503,'is the method name explicitly given',1),(2504,'can message body be converted to a processor',1),(2505,'is message body a beaninvocation instance',1),(2506,'continue to select best methodfigure 4',1),(2507,'5 how camel selects which method to invoke (part 1, continued in figure 4',1),(2508,'info106 chapter 4 using beans with camel3 if the bean can be converted to a processor using the camel type-converter mechanism, the processor is used to process the message',1),(2509,'this may seem a bit odd, but it allows camel to turn any bean into a message-driven bean equivalent',1),(2510,'for example, with this technique camel allows any javax',1),(2511,'messagelistener bean to be invoked directly by camel without any integration glue',1),(2512,'this method is rarely used by end users of camel, but it can be a useful trick',1),(2513,'4 if the body of the camel message can be converted into an org',1),(2514,'beaninvocation, that’s used to invoke the method and pass the arguments to the bean',1),(2515,'this is also rarely used by end users of camel',1),(2516,'5 continued in the second part of the algorithm, shown in figure 4',1),(2517,'56 throwmethodnotfoundexception7810 find bestmatching method11return selectedmethodthrowambigiousmethodcallexceptionnonoyesyesif an explicit method name was given,does at least one method exist with that name',1),(2518,'is there only one methodmarked with @handler annotation',1),(2519,'is there only one method marked withother kinds of camel annotations',1),(2520,'is there a single best matching method',1),(2521,'yes9yesis there only one methodwith a single parameter',1),(2522,'6 how camel selects which method to invoke (part 2, continued from figure 4',1),(2523,'info107selecting bean methodsfigure 4',1),(2524,'6 is a bit more complex, but its main goal is to narrow down the number of possible methods and select a method if one stands out',1),(2525,'don’t worry if you don’t entirely understand the algorithm; we’ll look at a couple of examples shortly that should make it much clearer',1),(2526,'let’s continue with the algorithm and cover the last steps:6 if a method name was given and no methods exist with that name, a methodnotfoundexception exception is thrown',1),(2527,'7 if only a single method has been marked with the @handler annotation, it’s selected',1),(2528,'8 if only a single method uses any of the other camel bean parameter-binding annotations, such as @body, @header, and so on, it’s selected',1),(2529,'(we’ll look at how camel binds to method parameters using annotations in section 4',1),(2530,')9 if, among all the methods on the bean, there’s only one method with exactly one parameter, that method is selected',1),(2531,'for example, this would be the situation for the echobean bean we looked at in section 4',1),(2532,'1, which has only the echo method with exactly one parameter',1),(2533,'single parameter methods are preferred because they map easily with the payload from the camel exchange',1),(2534,'10 now the computation gets a bit complex',1),(2535,'there are multiple candidate methods, and camel must determine whether there’s a single method that stands out as the best fit',1),(2536,'the strategy is to go over the candidate methods and filters out methods that don’t fit',1),(2537,'camel does this by trying to match the first parameter of the candidate method; if the parameter isn’t the same type and it’s not possible to coerce the types, the method is filtered out',1),(2538,'in the end, if there is only a single method left, that method is selected',1),(2539,'11 if camel can’t select a method, an ambigiousmethodcallexception exception is thrown with a list of ambiguous methods',1),(2540,'clearly camel goes through a lot to select the method to invoke on your bean',1),(2541,'over time you’ll learn to appreciate all this—it’s convention over configuration to the fullest',1),(2542,'note the algorithm laid out in this book is based on apache camel version 2',1),(2543,'this method-selection algorithm may change in the future to accommodate new features',1),(2544,'now it’s time to take a look at how this algorithm applies in practice',1),(2545,'3 some method-selection examplesto see how this algorithm works, we’ll use the echobean from section 4',1),(2546,'1 as an example, but we’ll add another method to it—the bar method—to better explain what happens when there are multiple candidate methods',1),(2547,'public class echobean {    public string echo(string echo) {        return echo + \" \" + eco;    }    www',1),(2548,'info108 chapter 4 using beans with camel    public string bar() {        return \"bar\";    } }and we’ll start with this route:from(\"direct:start\")',1),(2549,'class)',1),(2550,'to(\"log:reply\");if you send the string message \"camel\" to the camel route, the reply logger will surely output \"camel camel\" as expected',1),(2551,'despite the fact that echobean has two methods, echo and bar, only the echo method has a single parameter',1),(2552,'this is what step 9 in figure 4',1),(2553,'6 ensures—camel will pick the method with a single parameter if there is only one of them',1),(2554,'to make the example a bit more challenging, let’s change the bar method as follows:public string bar(string name) {    return \"bar \" + name; }what do you expect will happen now',1),(2555,'you now have two identical method signatures with a single method parameter',1),(2556,'in this case, camel can’t pick one over the other, so it throws an ambigiousmethodcallexception exception, according to step 11 in figure 4',1),(2557,'how can you resolve this',1),(2558,'one solution would be to provide the method name in the route, such as specifying the bar method:from(\"direct:start\")',1),(2559,'class, \"bar\")',1),(2560,'to(\"log:reply\");but there’s another solution that doesn’t involve specifying the method name in the route',1),(2561,'you can use the @handler annotation to select the method',1),(2562,'this solution is dealt with in step 7 of figure 4',1),(2563,'the @handler is a camel-specific annotation that you can add to a method',1),(2564,'it simply tells camel to use this method by default',1),(2565,'@handler public string bar(string name) {    return \"bar \" + name; }now the ambigiousmethodcallexception won’t be thrown because the @handler annotation tells camel to select the bar method',1),(2566,'tip it’s a good idea either to declare the method name in the route or to use the @handler annotation',1),(2567,'this ensures that camel picks the method you want, and you won’t be surprised if camel chooses another method',1),(2568,'suppose you change echobean to include two methods with different parameter types:public class echobean {    public string echo(string echo) {        return echo + \" \" + echo;    }    www',1),(2569,'info109selecting bean methods    public integer double(integer num) {        return num',1),(2570,'intvalue();    } }the echo method works with a string, and the double method with an integer',1),(2571,'if you don’t specify the method name, the beanprocessor will have to choose between these two methods at runtime',1),(2572,'6 allows camel to be smart about deciding which method stands out',1),(2573,'it does so by inspecting the message payloads of two or more candidate methods and comparing those with the message body type, checking whether there is an exact type match in any of the methods',1),(2574,'suppose you send in a message to the route that contains a string body with the word \"camel\"',1),(2575,'it’s not hard to guess that camel will pick the echo method, because it works with a string',1),(2576,'on the other hand, if you send in a message with the integer value of 5, camel will select the double method, because it uses the integer type',1),(2577,'despite this, things can still go wrong, so let’s go over a couple of common situations',1),(2578,'4 potential method-selection problemsthere are a few things that can go wrong when invoking beans at runtime:■ specified method not found—if camel can’t find any method with the specified name, a methodnotfoundexception exception is thrown',1),(2579,'this only happens when you have explicitly specified the method name',1),(2580,'■ ambiguous method—if camel can’t single out a method to call, an ambigiousmethodcallexception exception is thrown with a list of the ambiguous methods',1),(2581,'this can happen even when an explicit method name was defined because the method could potentially be overloaded, which means the bean would have multiple methods with the same name; only the number of parameters would vary',1),(2582,'■ type conversion failure—before camel invokes the selected method, it must convert the message payload to the parameter type required by the method',1),(2583,'if this fails, a notypeconversionavailableexception exception is thrown',1),(2584,'let’s take a look at examples of each of these three situations using the following echobean:public class echobean {    public string echo(string name) {        return name + name;    }    public string hello(string name) {        return \"hello \" + n...',1),(2585,'info110 chapter 4 using beans with camelfirst, you could specify a method that doesn’t exist by doing this:<bean ref=\"echobean\" method=\"foo\"/>here you try to invoke the foo method, but there is no such method, so camel throws a methodnotfoundexceptio...',1),(2586,'on the other hand, you could omit specifying the method name:<bean ref=\"echobean\"/>in this case, camel can’t single out a method to use because both the echo and hello methods are ambiguous',1),(2587,'when this happens, camel throws an ambigiousmethodcallexception exception containing a list of the ambiguous methods',1),(2588,'the last situation that could happen is when the message contains a body that can’t be converted to the type required by the method',1),(2589,'suppose you have the following orderservicebean:public class orderservicebean {    public string handlexml(document xml) {',1),(2590,'} }and suppose you need to use that bean in this route:from(\"jms:queue:orders\")',1),(2591,'to(\"jms:queue:handledorders\");the handlexml method requires a parameter to be of type org',1),(2592,'document, which is an xml type, but what if the jms queue contains a javax',1),(2593,'textmessage not containing any xml data, but just a plain text message, such as \"camel rocks\"',1),(2594,'at runtime you’ll get the following stracktrace:caused by: org',1),(2595,'notypeconversionavailableexception: no type converter available to convert from type: java',1),(2596,'messagesupport',1),(2597,'getmandatorybody(messagesupport',1),(2598,'53 morecaused by: org',1),(2599,'saxparseexception: content is not allowed in prolog',1),(2600,'instancemethodtypeconverter',1),(2601,'convertto (instancemethodtypeconverter',1),(2602,'54 morewhat happened is that camel tried to convert the javax',1),(2603,'textmessage to a org',1),(2604,'in this situation, camel wraps the error and throws it as a notypeconverterexception exception',1),(2605,'by further looking into this stacktrace, you may notice that the cause of this problem is that the xml parser couldn’t parse the data to xml',1),(2606,'it reports, “content is not allowed in prolog,” which is a common error indicating that the xml declaration (<',1),(2607,'xml version=\"1',1),(2608,'>) is missing',1),(2609,'you may wonder what would happen if such a situation occurred at runtime',1),(2610,'in this case, the camel error-handling system would kick in and handle it',1),(2611,'error handling is covered thoroughly in chapter 5',1),(2612,'that’s all you need to know about how camel selects methods at runtime',1),(2613,'now we need to look at the bean parameter-binding process, which happens after camel has selected the method',1),(2614,'5 bean parameter bindingin the last section, we covered the process that selects which method to invoke on a bean',1),(2615,'this section covers what happens next—how camel adapts to the parameters on the method signature',1),(2616,'any bean method can have multiple parameters and camel must somehow pass in meaningful values',1),(2617,'this process is known as bean parameter binding',1),(2618,'we’ve already seen parameter binding in action in the many examples so far in this chapter',1),(2619,'what those examples had in common was using a single parameter to which camel bound the input message body',1),(2620,'7 illustrates this using echobean as an example',1),(2621,'beanprocessor(service activator)echobeanstring echo(string name)invokeinput messageoutput messageexchangeuse bound tobcdfigure 4',1),(2622,'7 how beanprocessor binds the input message to the first parameter of the method being invoked    www',1),(2623,'info112 chapter 4 using beans with camelthe beanprocessor uses the input message b to bind its body to the first parameter of the method c, which happens to be the string name parameter',1),(2624,'camel does this by creating an expression that type-converts the input message body to the string type',1),(2625,'this ensures that when camel invokes the echo method d, the parameter matches the expected type',1),(2626,'this is important to understand, because most beans have methods with a single parameter',1),(2627,'the first parameter is expected to be the input message body, and camel will automatically convert the body to the same type as the parameter',1),(2628,'so what happens when a method has multiple parameters',1),(2629,'that’s what we’ll look at in the remainder of the chapter',1),(2630,'1 binding with multiple parametersfigure 4',1),(2631,'8 illustrates the principle of bean parameter binding when multiple parameters are used',1),(2632,'at first, figure 4',1),(2633,'8 may seem a bit overwhelming',1),(2634,'many new types come into play when you deal with multiple parameters',1),(2635,'the big box entitled “bean parameter bindings” contains the following four boxes:beanprocessor(service activator)echobeanstring echo(string name,            typeconverter converter,            @header(\"foo\") integer foo)camel built-in typescamelconte...',1),(2636,'camel annotations@body@header',1),(2637,'@headerscamel languageannotations@bean@xpath',1),(2638,'@groovy@ognlbean parameter bindingsusebound toinvokeinput messageoutput messageexchangefigure 4',1),(2639,'8 parameter binding with multiple parameters involves a lot more options than with single parameters',1),(2640,'info113bean parameter binding■ camel built-in types—camel provides special bindings for a series of camel concepts',1),(2641,'we’ll cover them in section 4',1),(2642,'■ exchange—this is the camel exchange, which allows binding to the input message, such as its body and headers',1),(2643,'the camel exchange is the source of the values that must be bound to the method parameters',1),(2644,'it will be covered in the sections to come',1),(2645,'■ camel annotations—when dealing with multiple parameters, you use annotations to distinguish them',1),(2646,'this is covered in section 4',1),(2647,'■ camel language annotations—this is a less commonly used feature that allows you to bind parameters to languages',1),(2648,'it’s ideal when working with xml messages that allow you to bind parameters to xpath expressions',1),(2649,'this is covered in section 4',1),(2650,'let’s start by looking at using the camel built-in types',1),(2651,'2 binding using built-in typescamel provides a set of fixed types that are always bound',1),(2652,'all you have to do is declare a parameter of one of the types listed in table 4',1),(2653,'2 parameter types that camel automatically bindstype descriptionexchange the camel exchange',1),(2654,'this contains the values that will be bound to the method parameters',1),(2655,'message the camel input message',1),(2656,'it contains the body that is often bound to the first method parameter',1),(2657,'this can be used in special circumstances when you need access to all camel’s moving parts',1),(2658,'typeconverter the camel type-converter mechanism',1),(2659,'this can be used when you need to convert types',1),(2660,'we covered the type-converter mechanism in section 3',1),(2661,'working with multiple parametersusing multiple parameters is more complex than using single parameters',1),(2662,'it’s generally a good idea to follow these rules of thumb:■ use the first parameter as the message body, which may or may not use the @body annotation',1),(2663,'■ use either a built-in type or add camel annotations for subsequent parameters',1),(2664,'in our experience, it becomes complicated when multiple parameters don’t follow these guidelines, but camel will make its best attempt to adapt the parameters to the method signature',1),(2665,'info114 chapter 4 using beans with camellet’s look at a couple of examples using the types from table 4',1),(2666,'first, suppose you add a second parameter that’s one of the built-in types to the echo method:public string echo(string echo, camelcontext context)in this example, you bind the camelcontext, which gives you access to all the moving parts of camel',1),(2667,'or you could bind the registry, in case you need to look up some beans:public string echo(string echo, registry registry) {   otherbean other = registry',1),(2668,'class);',1),(2669,'}you aren’t restricted to having only one additional parameter; you can have as many as you like',1),(2670,'for example, you could bind both the camelcontext and the registry:public string echo(string echo, camelcontext context, registry registry)so far, you’ve always bound to the message body; how would you bind to a message header',1),(2671,'the next section will explain that',1),(2672,'3 binding using camel annotationscamel provides a range of annotations to help bind from the exchange to bean parameters',1),(2673,'you should use these annotations when you want more control over the bindings',1),(2674,'for example, without these annotations, camel will always try to bind the method body to the first parameter, but with the @body annotation you can bind the body to any parameter in the method',1),(2675,'suppose you have the following bean method:public string orderstatus(integer customerid, integer orderid)and you have a camel message that contains the following data:■ body, with the order id, as a string type■ header with the customer id as an inte...',1),(2676,'3 lists all the camel parameter-binding annotations',1),(2677,'registry the bean registry',1),(2678,'this allows you to look up beans in the registry',1),(2679,'exception an exception, if one was thrown',1),(2680,'camel will only bind to this if the exchange has failed and contains an exception',1),(2681,'this allows you to use beans to handle errors',1),(2682,'2 parameter types that camel automatically binds (continued)type description    www',1),(2683,'info115bean parameter bindingyou’ve already seen the first two types in action, so let’s try a couple of examples with the other annotations',1),(2684,'for example, you could use @headers to bind the input headers to a map type: public string orderstatus(@body integer orderid, @headers map headers) {    integer customerid = (integer) headers',1),(2685,'get(\"customerid\");    string customertype = (string) headers',1),(2686,'get(\"customertype\");',1),(2687,'}you would use this when you have many headers, so you don’t have to add a parameter for every single header',1),(2688,'the @outheaders annotation is used when you’re working with request-response messaging (also identified as the inout message exchange pattern)',1),(2689,'@outheaders provides direct access to the output message headers, which means you can manipulate these headers directly from the bean',1),(2690,'here’s an example:public string orderstatus(@body integer orderid, @outheaders map headers) {',1),(2691,'put(\"status\", \"approved\");   headers',1),(2692,'put(\"confirmid\", \"444556\");   return \"ok\"; }notice that you use @outheaders as the second parameter',1),(2693,'unlike @headers, @outheaders is empty when the method is invoked',1),(2694,'the idea is that you put the headers that you want to preserve in the output message into this map',1),(2695,'finally, let’s look at camel’s language annotations, which bind parameters to a language',1),(2696,'4 binding using camel language annotationscamel provides additional annotations that allow you to use other languages as parameters',1),(2697,'this may sound a bit strange, but it will become clearer with an example',1),(2698,'3 parameter-binding annotations provided by camelannotation description@attachments binds the parameter to the message attachments',1),(2699,'the parameter must be a java',1),(2700,'@body binds the parameter to the message body',1),(2701,'@header(name) binds the parameter to the given message header',1),(2702,'@headers binds the parameter to all the input headers',1),(2703,'the parameter must be a java',1),(2704,'@outheaders binds the parameter to the output headers',1),(2705,'the parameter must be a java',1),(2706,'this allows you to add headers to the output message',1),(2707,'@property(name) binds the parameter to the given exchange property',1),(2708,'@properties binds the parameter to all the exchange properties',1),(2709,'the parameter must be a java',1),(2710,'info116 chapter 4 using beans with camel the most common language to use is xpath, which allows you to evaluate xpath expressions on the message body',1),(2711,'for example, suppose the message contains the following xml document:<order customerid=\"123\">  <status>in progress</status> </order>by using xpath expressions, you can extract parts of the document and bind them to parameters, like this:public void u...',1),(2712,'you can also mix and match annotations, so you can use @xpath for one parameter and @header for another',1),(2713,'4 lists the language annotations provided in camel 2',1),(2714,'in the future, we may add additional languages to camel, which often also means that a corresponding annotation for bean parameter binding is added as well',1),(2715,'it may seem a bit magical that you can use a @bean annotation when invoking a method, because the @bean annotation itself also invokes a method',1),(2716,'let’s try out an example',1),(2717,'suppose you already have a service that must be used to stamp unique order ids on incoming orders',1),(2718,'the service is implemented as follows',1),(2719,'4 camel’s language-based bean binding annotationsannotation description dependency@bean invokes a method on a bean camel-core@beanshell evaluates a bean shell script camel-script@el evaluates an el script (unified jsp and jsf scripts) camel-juel@groo...',1),(2720,'info117bean parameter bindingpublic document handleincomingorder(document xml, int customerid,                                    int orderid) {    attr attr = xml',1),(2721,'setvalue(\"\" + orderid);    node node = xml',1),(2722,'getelementsbytagname(\"order\")',1),(2723,'getattributes()',1),(2724,'setnameditem(attr);              return xml; }as you can see, the service creates a new xml attribute with the value of the given order id b',1),(2725,'then it inserts this attribute in the xml document c using the rather clumsy xml api from java c',1),(2726,'to generate the unique order id, you have the following class:public final class guidgenerator {    public static int generate() {        random ran = new random();        return ran',1),(2727,'nextint(10000000);    } }(in a real system, you’d generate unique order ids based on another scheme',1),(2728,') in camel, you have the following route that listens for new order files and invokes the service before sending the orders to a jms destination for further processing:<bean id=\"xmlorderservice\" class=\"camelinaction',1),(2729,'xmlorderservice\"/><camelcontext id=\"camel\" xmlns=\"http://camel',1),(2730,'org/schema/spring\">    <route>        <from uri=\"file://riderautoparts/order/inbox\"/>        <bean ref=\"xmlorderservice\"/>        <to uri=\"jms:queue:order\"/>    </route> </camelcontext>what is missing is the step that generates a unique id and provid...',1),(2731,'to do this, you need to declare a bean in the spring xml file with the id generator, as follows:<bean id=\"guid\" class=\"camelinaction',1),(2732,'guidgenerator\"/>now you’re ready to connect the last pieces of the puzzle',1),(2733,'you need to tell camel that it should invoke the generate method on the guid bean when it invokes the handleincomingorder method from listing 4',1),(2734,'to do this, you use the @bean annotation and change the method signature to the following:public document handleincomingorder(@body document xml,                    @xpath(\"/order/@customerid\") int customerid,                    @bean(ref = \"guid\", m...',1),(2735,'use the following maven goal from the chapter4/bean directory: mvn test -dtest=xmlordertestlisting 4',1),(2736,'5 a service that stamps an order id on an xml documentcreates orderid attributebadds orderid attribute to order nodec    www',1),(2737,'info118 chapter 4 using beans with camelwhen it’s running, you should see two log lines that output the xml order before and after the service has stamped the order id',1),(2738,'here’s an example:2009-10-28 16:18:58,485 [: filecomponent] info  beforeexchange[bodytype:org',1),(2739,'genericfile, body:<order customerid=\"4444\"><item>camel in action</item></order>] 2009-10-28 16:18:58,564 [: filecomponent] info  after exchange[bodytype:com',1),(2740,'deferreddocumentimpl, body:<order customerid=\"4444\" orderid=\"7303381\"><item>camel in action</item></order>]here you can see that the second log line has an orderid attribute with the value of 7303381, whereas the first doesn’t',1),(2741,'if you run it again, you’ll see a different order id because it’s a random value',1),(2742,'you can experiment with this example, perhaps changing how the order id is generated',1),(2743,'using namespaces with @xpathin the preceding example the xml order did not include a namespace',1),(2744,'when using namespaces the bean parameter binding must include the namespace(s) in the method signature as highlighted:public document handleincomingorder(    @body document xml,    @xpath(        value = \"/c:order/@customerid\",         namespaces = @...',1),(2745,'com/order\")) int customerid,    @bean(ref = \"guid\", method = \"generate\") int orderid);the namespace is defined using the @namespaceprefix annotation embedded in the @xpath annotation',1),(2746,'notice the xpath expression value must use the prefix, which means the expression is changed from /order/@customerid to /c:order/@customerid',1),(2747,'the prefix value isn’t required to be a certain value; instead of c you can use any value you like',1),(2748,'the source code for the book contains this example in the chapter4/bean directory; you can try using the following maven goal:mvn test -dtest=xmlordernamespacetestif your xml document includes multiple namespaces, you can define those as well in the ...',1),(2749,'bean binding summarycamel’s rules for bean parameter binding can be summarized as follows:■ all parameters having a camel annotation will be bound (table 4',1),(2750,'4)■ all parameters of a camel built-in type will be bound (table 4',1),(2751,'2)■ the first parameter is assumed to be the message in body (if not already bound)■ all remaining parameters will be unbound, and camel will pass in empty values    www',1),(2752,'info119summary and best practicesyou’ve seen all there is to bean binding',1),(2753,'camel has a flexible mechanism that adapts to your existing beans, and when you have multiple parameters, camel provides annotations to bind the parameters properly',1),(2754,'6 summary and best practiceswe’ve now covered another cornerstone of using beans with camel',1),(2755,'it’s important that end users of camel can use the pojo programming model and have camel easily leverage those beans (pojos)',1),(2756,'beans are just java code, which is a language you’re likely to feel comfortable using',1),(2757,'if you hit a problem that you can’t work around or figure out how to resolve using camel and eips, you can always resort to using a bean and letting camel invoke it',1),(2758,'we unlocked the algorithm used by camel to select which method to invoke on a bean',1),(2759,'you learned why this is needed—camel must resolve method selection at runtime, whereas regular java code can link method invocations at compile time',1),(2760,'we also covered what bean parameter binding is and how you can bind a camel exchange to any bean method and its parameters',1),(2761,'you learned how to use annotations to provide fine-grained control over the bindings, and even how camel can help bind xpath expressions to parameters, which is a great feature when working with xml messages',1),(2762,'let’s pull out some of the key practices you should take away from this chapter:■ use beans',1),(2763,'beans are java code and they give you all the horsepower of java',1),(2764,'■ use loose coupling',1),(2765,'prefer using beans that don’t have a strong dependency on the camel api',1),(2766,'camel is capable of adapting to existing bean method signatures, so you can leverage any existing api you may have, even if it has no dependency on the camel api',1),(2767,'unit testing is also easier because your beans don’t depend on any camel api',1),(2768,'you can even have developers with no camel experience develop the beans, and then have developers with camel experience use those beans',1),(2769,'■ prefer simple method signatures',1),(2770,'camel bean binding is much simpler when method signatures have as few parameters as possible',1),(2771,'tell camel which method you intend to invoke, so camel doesn’t have to figure this out itself',1),(2772,'you can also use @handler in the bean to tell camel which method it should pick and use',1),(2773,'■ use bean parameter annotations',1),(2774,'use the powers that the various camel bean parameter annotations offer',1),(2775,'we’ve now covered three crucial features of integration kits: routing, transformations, and using beans',1),(2776,'we’ll now take a leap into another world, one that’s often tackled as an afterthought in integration projects: how to handle situations when things go wrong',1),(2777,'we’ve devoted an entire chapter to camel’s extensive support for error handling',1),(2778,'info120error handlingin the last three chapters, we’ve covered three key functions that any integration kit should provide: routing, transformation, and mediation',1),(2779,'in this chapter, we turn our focus to what happens when things go wrong',1),(2780,'we want to introduce you to error handling early in this book, because we firmly believe that error handling should not be an afterthought but a key piece in your design from the start',1),(2781,'writing applications that integrate disparate systems are a challenge when it comes to handling unexpected events',1),(2782,'in a single system that you fully control, you can handle these events and recover',1),(2783,'but systems that are integrated over the network have additional risks: the network connection could be broken, a remote system might not respond in a timely manner, or it might even fail for no apparentthis chapter covers■ the difference between rec...',1),(2784,'info121understanding error handlingreason',1),(2785,'even on your local server, unexpected events can occur, such as the server’s disk filling up or the server running out of memory',1),(2786,'regardless of which errors occur, your application should be prepared to handle them',1),(2787,'in these situations, log files are often the only evidence of the unexpected event, so logging is important',1),(2788,'camel has extensive support for logging and for handling errors to ensure your application can continue to operate',1),(2789,'in this chapter, you’ll discover how flexible, deep, and comprehensive camel’s error handling is and how to tailor it to deal with most situations',1),(2790,'we’ll cover all the error handlers camel provides out of the box, and when they’re best used, so you can pick the ones best suited to your applications',1),(2791,'you’ll also learn how to configure and master redelivery, so camel can try to recover from particular errors',1),(2792,'we’ll also look at exception policies, which allow you to differentiate among errors and handle specific ones, and at how scopes can help you define general rules for implementing routescoped error handling',1),(2793,'finally, we’ll look at what camel offers when you need finegrained control over error handling, so that it only reacts under certain conditions',1),(2794,'1 understanding error handlingbefore jumping into the world of error handling with camel, we need to take a step back and look at errors more generally',1),(2795,'there are two main categories of errors, recoverable and irrecoverable, and we need to look at where and when error handling starts, because there are some prerequisites that must happen beforehand',1),(2796,'1 recoverable and irrecoverable errorswhen it comes to errors, we can divide them into recoverable and irrecoverable errors, as illustrated in figure 5',1),(2797,'an irrecoverable error is an error that remains an error now matter how many times you try to perform the same action again',1),(2798,'in the integration space, that could mean trying to access a database table that doesn’t exist, which would cause the jdbc driver to throw an sqlexception',1),(2799,'a recoverable error, on the other hand, is a temporary error that might not cause a problem on the next attempt',1),(2800,'a good example of such an error is a problem with the network connection resulting in a java',1),(2801,'on a subsequent attempt, the network issue could be resolved and your application could continue to operate',1),(2802,'1 errors can be categorized as either recoverable or irrecoverable',1),(2803,'irrecoverable errors continue to be errors on subsequent attempts; recoverable errors may be quickly resolved on their own',1),(2804,'info122 chapter 5 error handlingin your daily life as a java developer, you won’t encounter this division of errors into recoverable and irrecoverable often',1),(2805,'generally, exception handling code uses one of the two patterns illustrated in the following two code snippets',1),(2806,'the first snippet illustrates a common error-handling idiom, where all kinds of exceptions are considered irrecoverable and you give up immediately, throwing the exception back to the caller, often wrapped:public void handleorder(order order) throws ...',1),(2807,'sendorder(order);    } catch (exception e) {        throw new orderfailedexception(e);       } }the next snippet improves on this situation by adding a bit of logic to handle redelivery attempts before eventually giving up: public void handleorder(or...',1),(2808,'done) {                              try {            service',1),(2809,'sendorder(order);               done = true;        } catch (exception e) {            if (--retries == 0) {                   throw new orderfailedexception(e);            }        }    } }around the invocation of the service is the logic that attem...',1),(2810,'after five attempts, it gives up and throws the exception',1),(2811,'what the preceding example lacks is logic to determine whether the error is recoverable or irrecoverable, and to react accordingly',1),(2812,'in the recoverable case, you could try again, and in the irrecoverable case, you could give up immediately and rethrow the exception',1),(2813,'in camel, a recoverable error is represented as a plain throwable or exception that can be set or accessed from org',1),(2814,'exchange using one of the following two methods:void setexception(throwable cause);orexception getexception();note the setexception method on exchange accepts a throwable type, whereas the getexception method returns an exception type',1),(2815,'getexception also doesn’t return a throwable type because of api compatibility',1),(2816,'attempts redeliveryb    www',1),(2817,'info123understanding error handlingan irrecoverable error is represented as a message with a fault flag that can be set or accessed from org',1),(2818,'for example, to set \"unknown customer\" as a fault message, you would do the following:message msg = exchange',1),(2819,'getout(); msg',1),(2820,'setfault(true); msg',1),(2821,'setbody(\"unknown customer\");the fault flag must be set using the setfault(true) method',1),(2822,'so why are the two types of errors represented differently',1),(2823,'there are two reasons: first, the camel api was designed around the java business integration (jbi) specification, which includes a fault message concept',1),(2824,'second, camel has error handling built into its core, so whenever an exception is thrown back to camel, it catches it and sets the thrown exception on the exchange as a recoverable error, as illustrated here:try {    processor',1),(2825,'process(exchange); } catch (throwable e) {   exchange',1),(2826,'setexception(e); }using this pattern allows camel to catch and handle all exceptions that are thrown',1),(2827,'camel’s error handling can then determine how to deal with the errors—retry, propagate the error back to the caller, or do something else',1),(2828,'end users of camel can set irrecoverable errors as fault messages, and camel can react accordingly and stop routing the message',1),(2829,'now that you’ve seen recoverable and irrecoverable errors in action, let’s summarize how they’re represented in camel:■ exceptions are represented as recoverable errors',1),(2830,'■ fault messages are represented as irrecoverable errors',1),(2831,'now let’s look at when and where camel’s error handling applies',1),(2832,'2 where camel’s error handling appliescamel’s error handling doesn’t apply everywhere',1),(2833,'to understand why, take a look at figure 5',1),(2834,'file fileconsumermessagetranslator file producerexchangecamelcamel error-handling boundarieschangedfilefigure 5',1),(2835,'2 camel’s error handling only applies within the lifecycle of an exchange',1),(2836,'2 shows a simple route that translates files',1),(2837,'you have a file consumer and producer as the input and output facilities, and in between is the camel routing engine, which routes messages encompassed in an exchange',1),(2838,'it’s during the lifecycle of this exchange that the camel error handling applies',1),(2839,'that leaves a little room on the input side where this error handling can’t operate—the file consumer must be able to successfully read the file, instantiate the exchange, and start the routing before the error handling can function',1),(2840,'this applies to any kind of camel consumer',1),(2841,'so what happens if the file consumer can’t read the file',1),(2842,'the answer is componentspecific, and each camel component must deal with this in its own way',1),(2843,'some components will ignore and skip the message, others will retry a number of times, and others will gracefully recover',1),(2844,'note there are a number of camel components that provide minor errorhandling features: file, ftp, mail, ibatis, rss, atom, jpa, and snmp',1),(2845,'these components are based on the scheduledpollconsumer class, which offers a pluggable pollingconsumerpollstrategy that you can use to create your own error-handling strategy',1),(2846,'you can learn more about this on the camel website, at http://camel',1),(2847,'org/polling-consumer',1),(2848,'that’s enough background information—let’s dig into how error handling in camel works',1),(2849,'in the next section, we’ll start by looking at the different error handlers camel provides',1),(2850,'2 error handlers in camelin the previous section you learned that camel regards all exceptions as recoverable and stores them on the exchange using the setexception(throwable cause) method',1),(2851,'this means error handlers in camel will only react to exceptions set on the exchange',1),(2852,'by default, they won’t react if an irrecoverable error has been set as a fault message',1),(2853,'the rule of thumb is that error handlers in camel only trigger when exchange',1),(2854,'note in section 5',1),(2855,'4, you’ll learn how you can instruct camel error handlers to react to fault messages as well',1),(2856,'camel provides a range of error handlers',1),(2857,'they’re listed in table 5',1),(2858,'1 the error handlers provided in camelerror handler descriptiondefaulterrorhandler this is the default error handler that’s automatically enabled, in case no other has been configured',1),(2859,'deadletterchannel this error handler implements the dead letter channel eip',1),(2860,'transactionerrorhandler this is a transaction-aware error handler extending the default error handler',1),(2861,'transactions are covered in chapter 9 and are only briefly touched on in this chapter',1),(2862,'we’ll revisit this error handler in chapter 9',1),(2863,'info125error handlers in camelat first glance, having five error handlers may seem overwhelming, but you’ll learn that the default error handler is used in most cases',1),(2864,'the first three error handlers in table 5',1),(2865,'that class contains the majority of the error-handling logic that the first three error handlers all leverage',1),(2866,'the latter two error handlers have limited functionality and don’t extend redeliveryerrorhandler',1),(2867,'we’ll look at each of these error handlers in turn',1),(2868,'1 the default error handlercamel is preconfigured to use the defaulterrorhandler, which covers most use cases',1),(2869,'to understand it, consider the following route:from(\"direct:neworder\")',1),(2870,'beanref(\"orderservice, \"store\");the default error handler is preconfigured and doesn’t need to be explicitly declared in the route',1),(2871,'so what happens if an exception is thrown from the validate method on the order service bean',1),(2872,'to answer this, we need to dive into camel’s inner processing, where the error handler lives',1),(2873,'in every camel route, there is a channel that sits between each node in the route graph, as illustrated in figure 5',1),(2874,'the channel is in between each node of the route path, which ensures it can act as a controller that monitors and controls the routing at runtime',1),(2875,'this is the feature that allows camel to enrich the route with error handling, message tracing, interceptors, and much more',1),(2876,'for now, you just need to know that this is where the error handler lives',1),(2877,'turning back to the example route, imagine that an exception was thrown from the order service bean during invocation of the validate method',1),(2878,'3, the processor d would throw an exception, which would be propagated back to the previous channel c, where the error handler would catch it',1),(2879,'this gives camel the chance to react accordingly',1),(2880,'for example, camel could try again (redeliver), or it could routenoerrorhandler this handler is used to disable error handling altogether',1),(2881,'loggingerrorhandler this error handler just logs the exception',1),(2882,'1 the error handlers provided in camel (continued)error handler descriptionconsumer channel processor channel processorfrom(\"direct:neworder\") beanref(\"orderserive\",     \"validate\")beanref(\"orderservice\",  \"store\")b c d e ffigure 5',1),(2883,'3 a detailed view of a route path, where channels act as controllers between the processors    www',1),(2884,'info126 chapter 5 error handlingthe message to another route path (detour using exception policies), or it could give up and propagate the exception back to the caller',1),(2885,'with the default settings, camel will propagate the exception back to the caller',1),(2886,'the default error handler is configured with these settings:■ no redelivery■ exceptions are propagated back to the callerthese settings match what happens when you’re working with exceptions in java, so camel’s behavior won’t surprise camel end users',1),(2887,'let’s continue with the next error handler, the dead letter channel',1),(2888,'2 the dead letter channel error handlerthe deadletterchannel error handler is similar to the default error handler except for the following differences:■ the dead letter channel is the only error handler that supports moving failed messages to a dedi...',1),(2889,'■ unlike the default error handler, the dead letter channel will, by default, handle exceptions and move the failed messages to the dead letter queue',1),(2890,'■ the dead letter channel supports using the original input message when a message is moved to the dead letter queue',1),(2891,'let’s look at each of these in a bit more detail',1),(2892,'the dead letter channelthe deadletterchannel is an error handler that implements the principles of the dead letter channel eip',1),(2893,'this pattern states that if a message can’t be processed or delivered, it should be moved to a dead letter queue',1),(2894,'4 illustrates this pattern',1),(2895,'as you can see, the consumer b consumes a new message that is supposed to be routed to the processor d',1),(2896,'the channel c controls the routing between b and d, and if the message can’t be delivered to d, the channel invokes the deal letter channel error handler, which moves the message to the dead letter queue e',1),(2897,'this keeps the message safe and allows the application to continue operating',1),(2898,'this pattern is often used with messaging',1),(2899,'instead of allowing a failed message to block new messages from being picked up, the message is moved to a dead letter queue to get it out of the way',1),(2900,'consumer channel processordead letter queueb c defigure 5',1),(2901,'4 the dead letter channel eip moves failed messages to a dead letter queue',1),(2902,'info127error handlers in camelthe same idea applies to the dead letter channel error handler in camel',1),(2903,'this error handler has an associated dead letter queue, which is based on an endpoint, allowing you to use any camel endpoint you choose',1),(2904,'for example, you can use a database, a file, or just log the failed messages',1),(2905,'when you choose to use the dead letter channel error handler, you must configure the dead letter queue as an endpoint so the handler knows where to move the failed messages',1),(2906,'this is done a bit differently in the java dsl and spring xml',1),(2907,'for example, here is how you’d log the message at error level in java dsl:errorhandler(deadletterchannel(\"log:dead',1),(2908,'level=error\"));and here is how you’d do it in spring xml:<errorhandler id=\"myerrorhandler\" type=\"deadletterchannel\"              deadletteruri=\"log:dead',1),(2909,'level=error\"/>now, let’s look at how the dead letter channel error handler handles exceptions when it moves the message to the dead letter queue',1),(2910,'handling exceptions by defaultby default, camel handles exceptions by suppressing them; it removes the exceptions from the exchange and stores them as properties on the exchange',1),(2911,'after a message has been moved to the dead letter queue, camel stops routing the message and the caller regards it as processed',1),(2912,'when a message is moved to the dead letter queue, you can obtain the exception from the exchange using the exchange',1),(2913,'class);now let’s look at using the original message',1),(2914,'using the original message with the dead letter channelsuppose you have a route in which the message goes through a series of processing steps, each altering a bit of the message before it reaches its final destination, as in the following code:error...',1),(2915,'to(\"jms:queue:order\");now imagine that an exception occurs at the validate method, and the dead letter channel error handler moves the message to the dead letter queue',1),(2916,'suppose a new message arrives and an exception occurs at the enrich method, and this message is also moved to the same dead letter queue',1),(2917,'if you want to retry those messages, can you just drop them into the inbox queue',1),(2918,'in theory, you could do this, but the messages that were moved to the dead letter queue no longer match the messages that originally arrived at the inbox queue—they    www',1),(2919,'info128 chapter 5 error handlingwere altered as the messages were routed',1),(2920,'what you want instead is for the original message content to have been moved to the dead letter queue, so that you have the original message to retry',1),(2921,'the useoriginalmessage option instructs camel to use the original message when it moves messages to the dead letter queue',1),(2922,'you configure the error handler to use the useoriginalmessage option as follows:errorhandler(deadletterchannel(\"jms:queue:dead\")',1),(2923,'useoriginalmessage());in spring xml, you would do this:<errorhandler id=\"myerrorhandler\" type=\"deadletterchannel\"              deadletteruri=\"jms:queue:dead\" useoriginalmessage=\"true\"/>let’s move on to the transaction error handler',1),(2924,'3 the transaction error handlerthe transactionerrorhandler is built on top of the default error handler and offers the same functionality, but it’s tailored to support transacted routes',1),(2925,'chapter 9 focuses on transactions and discusses this error handler in detail, so we won’t say much about it here',1),(2926,'for now, you just need to know that it exists and it’s a core part of camel',1),(2927,'the remaining two error handlers are seldom used and are much simpler',1),(2928,'4 the no error handlerthe noerrorhandler is used to disable error handling',1),(2929,'the current architecture of camel mandates that an error handler must be configured, so if you want to disable error handling, you need to provide an error handler that’s basically an empty shell with no real logic',1),(2930,'that’s the noerrorhandler',1),(2931,'5 the logging error handlerthe loggingerrorhandler logs the failed message along with the exception',1),(2932,'the logger uses standard log format from log kits such as log4j, commons logging, or the java util logger',1),(2933,'camel will, by default, log the failed message and the exception using the log name org',1),(2934,'processor',1),(2935,'you can, of course, customize this',1),(2936,'that covers the five error handlers provided with camel',1),(2937,'let’s now look at the major features these error handlers provide',1),(2938,'6 features of the error handlersthe default, dead letter channel, and transaction error handlers are all built on the same base, org',1),(2939,'processor',1),(2940,'redeliveryerrorhandler, so they all have several major features in common',1),(2941,'these features are listed in table 5',1),(2942,'at this point, you may be eager to see the error handlers in action',1),(2943,'in section 5',1),(2944,'6 we’ll build a use case that introduces error handling, so there will be    www',1),(2945,'info129using error handlers with redeliveryplenty of opportunities to try this on your own',1),(2946,'but first, let’s look at the major features',1),(2947,'we’ll look at redelivery and scope in section 5',1),(2948,'exception policies and error handling will be covered in section 5',1),(2949,'3 using error handlers with redeliverycommunicating with remote servers relies on network connectivity that can be unreliable and have outages',1),(2950,'luckily these disruptions cause recoverable errors—the network connection could be reestablished in a matter of seconds or minutes',1),(2951,'remote services can also be the source of temporary problems, such as when the service is restarted by an administrator',1),(2952,'to help address these problems, camel supports a redelivery mechanism that allows you to control how recoverable errors are dealt with',1),(2953,'in this section, we’ll take a look at a real-life error-handling scenario, and then focus on how camel controls redelivery and how you can configure and use it',1),(2954,'we’ll also take a look at how you can use error handlers with fault messages',1),(2955,'we’ll end this section by looking at error-handling scope and how it can be used to support multiple error handlers scoped at different levels',1),(2956,'1 an error-handling use casesuppose you have developed an integration application at rider auto parts that once every hour should upload files from a local directory to an http server, and your boss asks why the files haven’t been updated in the last...',1),(2957,'you’re surprised, because the application has been running for the last month without a problem',1),(2958,'this could well be a situation where neither error handling nor monitoring was in place',1),(2959,'here’s the java file that contains the integration route:from(\"file:/riders/files/upload',1),(2960,'user=gear&password=secret\");this route will periodically scan for files in the /riders/files/upload folder, and if any files exist, it will upload them to the receiver’s http server using the http endpoint',1),(2961,'2 noteworthy features provided by the error handlersfeature descriptionredelivery policies redelivery policies allow you to define policies for whether or not redelivery should be attempted',1),(2962,'the policies also define settings such as the maximum number of redelivery attempts, delays between attempts, and so on',1),(2963,'scope camel error handlers have two possible scopes: context (high level) and route (low level)',1),(2964,'the context scope allows you to reuse the same error handler for multiple routes, whereas the route scope is used for a single route only',1),(2965,'exception policies exception policies allow you to define special policies for specific exceptions',1),(2966,'error handling this option allows you to specify whether or not the error handler should handle the error',1),(2967,'info130 chapter 5 error handling but there is no explicit error handling configured, so if an error occurs, the default error handler is triggered',1),(2968,'that handler doesn’t handle the exception but instead propagates it back to the caller',1),(2969,'because the caller is the file consumer, it will log the exception and do a file rollback, meaning that any picked-up files will be left on the file system, ready to be picked up in the next scheduled poll',1),(2970,'at this point, you need to reconsider how errors should be handled in the application',1),(2971,'you aren’t in major trouble, because you haven’t lost any files—camel will only move successfully processed files out of the upload folder—failed files will just stack up',1),(2972,'the error occurs when sending the files to the http server, so you look into the log files and quickly determine that camel can’t connect to the remote http server due to network issues',1),(2973,'your boss decides that the application should retry uploading the files if there’s an error, so the files won’t have to wait for the next hourly upload',1),(2974,'to implement this, you can configure the error handler to redeliver up to 5 times with 10-second delays:errorhandler(defaulterrorhandler()',1),(2975,'maximumredeliveries(5)',1),(2976,'redeliverydelay(10000));configuring redelivery can hardly get any simpler than that',1),(2977,'but let’s take a closer look at how to use redelivery with camel',1),(2978,'2 using redeliverythe first three error handlers in table 5',1),(2979,'1 all support redelivery',1),(2980,'this is implemented in the redeliveryerrorhandler class, which they extend',1),(2981,'the redeliveryerrorhandler must then know whether or not to attempt redelivery; this is what the redelivery policy is for',1),(2982,'a redelivery policy defines how and whether redelivery should be attempted',1),(2983,'3 outlines the options supported by the redelivery policy and what the default settings are',1),(2984,'3 options provided in camel for configuring redeliveryoption type default descriptionmaximumredeliveries int 0 maximum number of redelivery attempts allowed',1),(2985,'0 is used to disable redelivery, and -1 will attempt redelivery forever until it succeeds',1),(2986,'redeliverydelay long 1000 fixed delay in milliseconds between each redelivery attempt',1),(2987,'maximumredeliverydelay long 60000 an upper bound in milliseconds for redelivery delay',1),(2988,'this is used when you specify nonfixed delays, such as exponential backoff, to avoid the delay growing too large',1),(2989,'info131using error handlers with redeliveryasyncdelayedredelivery boolean false dictates whether or not camel should use asynchronous delayed redelivery',1),(2990,'when a redelivery is scheduled to be redelivered in the future, camel would normally have to block the current thread until it’s time for redelivery',1),(2991,'by enabling this option, you let camel use a scheduler so that an asynchronous thread will perform the redelivery',1),(2992,'this ensures that no thread is blocked while waiting for redelivery',1),(2993,'0 exponential backoff multiplier used to multiply each consequent delay',1),(2994,'redeliverydelay is the starting delay',1),(2995,'exponential backoff is disabled by default',1),(2996,'collisionavoidancefactor double 0',1),(2997,'15 a percentage to use when calculating a random delay offset (to avoid using the same delay at the next attempt)',1),(2998,'will start with the redeliverydelay as the starting delay',1),(2999,'collision avoidance is disabled by default',1),(3000,'delaypattern string - a pattern to use for calculating the delay',1),(3001,'the pattern allows you to specify fixed delays for interval groups',1),(3002,'for example, the pattern \"0:1000; 5:5000;10:30000\" will use a 1 second delay for attempts 0 to 4, 5 seconds for attempts 5 to 9, and 30 seconds for subsequent attempts',1),(3003,'retryattemptedloglevel logginglevel debug log level used when a redelivery attempt is performed',1),(3004,'retriesexhaustedloglevel logginglevel error log level used when all redelivery attempts have failed',1),(3005,'logstacktrace boolean true specifies whether or not stacktraces should be logged when all redelivery attempts have failed',1),(3006,'logretrystacktrace boolean false specifies whether or not stacktraces should be logged when a delivery has failed',1),(3007,'logretryattempted boolean true specifies whether or not redelivery attempts should be logged',1),(3008,'logexhausted boolean true specifies whether or not the exhaustion of redelivery attempts (when all redelivery attempts have failed) should be logged',1),(3009,'loghandled boolean false specifies whether or not handled exceptions should be logged',1),(3010,'3 options provided in camel for configuring redelivery (continued)option type default description    www',1),(3011,'info132 chapter 5 error handlingin the java dsl, camel has fluent builder methods for configuring the redelivery policy on the error handler',1),(3012,'for instance, if you want to redeliver up to five times, use exponential backoff, and have camel log at warn level when it attempts a redelivery, you could use this code:errorhandler(defaulterrorhandler()',1),(3013,'maximumredeliveries(5)',1),(3014,'warn));configuring this in spring xml is done as follows:<errorhandler id=\"myerrorhandler\" type=\"defaulterrorhandler\"    <redeliverypolicy maximumredeliveries=\"5\"                      retryattemptedloglevel=\"warn\"                      backoffmultipli...',1),(3015,'by using the type option on the <errorhandler> tag, you select which type of error handler to use',1),(3016,'in this example, it’s the default error handler',1),(3017,'you also have to enable exponential backoff explicitly by setting the useexponentialbackoff option to true',1),(3018,'we’ve now established that camel uses the information from the redelivery policy to determine whether and how to do redeliveries',1),(3019,'but what happens inside camel',1),(3020,'as you’ll recall from figure 5',1),(3021,'3, camel includes a channel between every processing step in a route path, and there is functionality in these channels, such as error handlers',1),(3022,'the error handler detects every exception that occurs and acts on it, deciding what to do, such as redeliver or give up',1),(3023,'now that you know a lot about the defaulterrorhandler, it’s time to try a little example',1),(3024,'using the defaulterrorhandler with redelivery in the source code for the book, you’ll see an example in the chapter5/errorhandler directory',1),(3025,'the example uses the following route configuration: errorhandler(defaulterrorhandler()',1),(3026,'maximumredeliveries(2)',1),(3027,'warn));    from(\"seda:queue',1),(3028,'order\");this configuration first defines a context-scoped error handler b that will attempt at most two redeliveries using a 1-second delay',1),(3029,'when it attempts the redelivery, it will log this at the warn level (as you’ll see in a few seconds)',1),(3030,'the example is constructed to fail when the message reaches the enrich method c',1),(3031,'configures error handlerbinvokes enrich methodc    www',1),(3032,'info133using error handlers with redelivery you can run this example using the following maven goal from the chapter5/ errorhandler directory: mvn test -dtest=defaulterrorhandlertestwhen running the example, you’ll see the following log entries outpu...',1),(3033,'notice how camel logs the redelivery attempts:2009-12-16 14:28:16,959 [a://queue',1),(3034,'orderexception: activemq in action is out of stock2009-12-16 14:28:17,960 [a://queue',1),(3035,'orderexception: activemq in action is out of stockthese log entries show that camel failed to deliver a message, which means the entry is logged after the attempt is made',1),(3036,'on delivery attempt: 0 identifies the first attempt; attempt 1 is the first redelivery attempt',1),(3037,'camel also logs the exchangeid (which you can use to correlate messages) and the exception that caused the problem (without the stacktrace, by default)',1),(3038,'when camel performs a redelivery attempt it does this at the point of origin',1),(3039,'in the preceding example the error occurred when invoking the enrich method c, which means camel will redeliver by retrying the',1),(3040,'beanref(\"orderservice\", \"enrich\") step in the route',1),(3041,'after all redelivery attempts have failed, we say it’s exhausted, and camel logs this at the error level by default',1),(3042,'(you can customize this with the options listed in table 5',1),(3043,') when the redelivery attempts are exhausted, the log entry is similar to the previous ones, but camel explains that it’s exhausted after three attempts:2009-12-16 14:28:18,961 [a://queue',1),(3044,'exhausted after delivery attempt: 3 caught: camelinaction',1),(3045,'orderexception: activemq in action is out of stocktip the default error handler has many options, which are listed in table 5',1),(3046,'we encourage you to try loading this example into your ide and playing with it',1),(3047,'change the settings on the error handler and see what happens',1),(3048,'the preceding log output identifies the number of redelivery attempts, but how does camel know this',1),(3049,'camel stores this information on the exchange',1),(3050,'4 reveals where this information is stored',1),(3051,'4 headers on the exchange related to error handlingheader type descriptionexchange',1),(3052,'redelivered boolean whether this exchange is being redelivered',1),(3053,'redelivery_exhausted boolean whether this exchange has attempted (exhausted) all redeliveries and has still failed',1),(3054,'4 is only available when camel performs a redelivery; these headers are absent on the regular first attempt',1),(3055,'it’s only when a redelivery is triggered that these headers are set on the exchange',1),(3056,'using asynchronous delayed redeliveryin the previous example, the error handler was configured to use delayed redelivery with a 1-second delay between attempts',1),(3057,'when a redelivery is to be conducted, camel will wait for 1 second before carrying out the redelivery',1),(3058,'if you look at the console output, you can see the redelivery log entries are 1 second apart, and it’s the same thread processing the attempts; this can be identified by the [a://queue',1),(3059,'this is known as synchronous delayed redelivery',1),(3060,'there will also be situations where you want to use asynchronous delayed redelivery',1),(3061,'so what does that mean',1),(3062,'suppose two orders are sent to the seda:queue:inbox endpoint',1),(3063,'the consumer will pick up the first order from the queue and process it',1),(3064,'if it fails, it’s scheduled for redelivery',1),(3065,'in the synchronous case, the consumer thread is blocked while waiting to carry out the redelivery',1),(3066,'this means the second order on the queue can only be processed when the first order has been completed',1),(3067,'this isn’t the case in asynchronous mode',1),(3068,'instead of the consumer thread being blocked, it will break out and be able to pick up the second order from the queue and continue processing it',1),(3069,'this helps achieve higher scalability because threads aren’t blocked and doing nothing',1),(3070,'instead the threads are being put to use servicing new requests',1),(3071,'tip we’ll cover the threading model in chapter 10, which will explain how camel can schedule redeliveries for the future to be processed by other threads',1),(3072,'the delayer and throttler eips have similar asynchronous delayed modes, which you can leverage by enabling the asyncdelayed option',1),(3073,'the source code for the book contains an example that illustrates the difference between synchronous and asynchronous delayed redelivery, in the chapter5/ errorhandler directory',1),(3074,'you can try it using the following maven goal:mvn test -dtest=syncvsasyncdelayedredeliverytestthe example contains two methods: one for the synchronous mode and another for the asynchronous',1),(3075,'the console output for the synchronous mode should be displayed in the following order:[a://queue',1),(3076,'inbox] info - received order amount=1,name=camel in action,id=123,status=ok    www',1),(3077,'info135using error handlers with redeliverycompare that with the following output from the asynchronous mode:[a://queue',1),(3078,'inbox] info - received order amount=1,name=camel in action,id=123,status=ok [rredeliverytask] warn - failed delivery for exchangeid: xxxx [rredeliverytask] warn - failed delivery for exchangeid: xxxxnotice how the camel in action order is processed i...',1),(3079,'also pay attention to the thread name that executes the redelivery, identified by [rredeliverytask] being logged',1),(3080,'as you can see, it’s not the consumer anymore; its a redelivery task',1),(3081,'3 error handlers and scopesscopes can be used to define error handlers at different levels',1),(3082,'camel supports two scopes: a context scope and a route scope',1),(3083,'camel allows you to define a global context-scoped error handler that’s used by default, and, if needed, you can also configure a route-scoped error handler that applies only for a particular route',1),(3084,'this is illustrated in listing 5',1),(3085,'maximumredeliveries(2)',1),(3086,'beanref(\"orderservice\", \"tocsv\")',1),(3087,'to(\"seda:queue',1),(3088,'inbox\"); from(\"seda:queue',1),(3089,'maximumredeliveries(5)',1),(3090,'order\");listing 5',1),(3091,'1 is an improvement over the previous error-handling example',1),(3092,'the default error handler is configured as in the previous example b, but you have a new route that picks up files, processes them, and sends them to the second route',1),(3093,'this first route will use the default error handler b because it doesn’t have a route-scoped error handler configured, but the second route has a route-scoped error handler c',1),(3094,'it’s a dead letter channel that will send failed messages to a log',1),(3095,'notice that it has different options configured than the former error handler',1),(3096,'the source code for the book includes this example, which you can run using the following maven goal from the chapter5/errorhandler directory: mvn test -dtest=routescopetestlisting 5',1),(3097,'1 using two error handlers at different scopesdefines context-scoped error handlerbdefines route-scoped error handlercinvokes enrich methodd    www',1),(3098,'info136 chapter 5 error handlingthis example should fail for some messages when the enrich d method is invoked',1),(3099,'this demonstrates how the route-scoped error handler is used as error handler',1),(3100,'the most interesting part of this test class is the testorderactivemq method, which will fail in the second route and therefore show the dead letter channel in action',1),(3101,'there are a couple of things to notice about this, such as the exponential backoff, which causes camel to double the delay between redelivery attempts, starting with 250 milliseconds and ending with 4 seconds',1),(3102,'the following snippets show what happens at the end when the error handler is exhausted',1),(3103,'orderexception: activemq in action is out of stock2009-12-16 17:03:44,541 [a://queue',1),(3104,'exhausted after delivery attempt: 6 caught: camelinaction',1),(3105,'orderexception: activemq in action is out of stock',1),(3106,'processed by failure processor: sendto(endpoint[log://dlc])as you can see, the dead letter channel moves the message to its dead letter queue, which is the log://dlc endpoint',1),(3107,'after this, camel also logs an error line indicating that this move was performed',1),(3108,'we encourage you to try this example and adjust the configuration settings on the error handlers to see what happens',1),(3109,'so far, the error-handling examples we’ve looked at have used the java dsl',1),(3110,'let’s take a look at configuring error handling with spring xml',1),(3111,'using error handling with spring xml let’s revise the example in listing 5',1),(3112,'1 to use spring xml',1),(3113,'here’s how that’s done',1),(3114,'<bean id=\"orderservice\" class=\"camelinaction',1),(3115,'orderservice\"/> <camelcontext id=\"camel\" errorhandlerref=\"defaulteh\"                     xmlns=\"http://camel',1),(3116,'org/schema/spring\"><errorhandler id=\"defaulteh\">                                           <redeliverypolicy maximumredeliveries=\"2\" redeliverydelay=\"1000\"                      retryattemptedloglevel=\"warn\"/> </errorhandler><errorhandler id=\"dlc\"    ...',1),(3117,'2 using error handling with spring xmlspecifies context-scoped error handlerbsets up route-scoped error handlerd sets up context-scoped errorhandler c    www',1),(3118,'info137using error handlers with redelivery<route>     <from uri=\"file://target/orders',1),(3119,'delay=10000\"/>    <bean ref=\"orderservice\" method=\"tocsv\"/>    <to uri=\"mock:file\"/>    <to uri=\"seda:queue',1),(3120,'inbox\"/> </route><route errorhandlerref=\"dlc\">                    <from uri=\"seda:queue',1),(3121,'order\"/> </route></camelcontext>to use a context-scoped error handler in spring xml, you must configure it using an errorhandlerref attribute b on the camelcontext tag',1),(3122,'the errorhandlerref refers to an <errorhandler>, which in this case is the default error handler with id \"defaulteh\" c',1),(3123,'there’s another error handler, a deadletterchannel error handler d, that is used at route scope in the second route e',1),(3124,'as you can see, the differences between the java dsl and spring xml mostly result from using the errorhandlerref attribute to reference the error handlers in spring xml, whereas java dsl can have route-scoped error handlers within the routes',1),(3125,'you can try this example by running the following maven goal from the chapter5/ errorhandler directory: mvn test -dtest=springroutescopetestthe spring xml file is located in the src/test/resources/camelinaction directory',1),(3126,'this concludes our discussion of scopes and redelivery',1),(3127,'we’ll now look at how you can use camel error handlers to handle faults',1),(3128,'4 handling faultsin the introduction to section 5',1),(3129,'2, we mentioned that by default the camel error handlers will only react to exceptions',1),(3130,'because a fault isn’t represented as an exception but as a message that has the fault flag enabled, faults will not be recognized and handled by camel error handlers',1),(3131,'there may be times when you want the camel error handlers handle faults as well',1),(3132,'suppose a camel route invokes a remote web service that returns a fault message, and you want this fault message to be treated like an exception and moved to a dead letter queue',1),(3133,'we’ve implemented this scenario as a unit test, simulating the remote web service using a bean:errorhandler(deadletterchannel(\"mock:dead\"));from(\"seda:queue',1),(3134,'order\");specifies route-scoped error handlere    www',1),(3135,'info138 chapter 5 error handlingnow, imagine that the orderservice bean returns the following soap fault:<',1),(3136,'xml version=\"1',1),(3137,'0\" encoding=\"utf-8\" standalone=\"yes\"',1),(3138,'> <ns2:envelope xmlns:ns2=\"http://schemas',1),(3139,'xmlsoap',1),(3140,'org/soap/envelope/\"              xmlns:ns3=\"http://www',1),(3141,'org/2003/05/soap-envelope\">    <ns2:body>        <ns2:fault>            <faultcode>ns3:receiver</faultcode>            <faultstring>activemq in action is out of stock</faultstring>        </ns2:fault>    </ns2:body> </ns2:envelope>under normal situat...',1),(3142,'to make it do so, you have to instruct camel by enabling fault handling',1),(3143,'to enable fault handling on the camelcontext (context scope), you simply do this:getcontext()',1),(3144,'sethandlefault(true);to enable it on a per route basis (route scope), do this:from(\"seda:queue',1),(3145,'order\");once fault handling is enabled, the camel errors handlers will recognize the soap faults and react',1),(3146,'under the hood, the soap fault is converted into an exception with the help of an interceptor',1),(3147,'you can enable fault handling in spring xml as follows:<route handlefault=\"true\">    <from uri=\"seda:queue',1),(3148,'order\"/> </route>the source code for the book contains this example in the chapter5/errorhandler directory, which you can try using the following maven goals:mvn test -dtest=handlefaulttest mvn test -dtest=springhandlefaulttesttip you can enable faul...',1),(3149,'we’ll continue in the next section to look at the other two major features that error handlers provide, as listed in table 5',1),(3150,'2: exception policies and error handling',1),(3151,'4 using exception policiesexception policies are used to intercept and handle specific exceptions in particular ways',1),(3152,'for example, exception policies can influence, at runtime, the redelivery policies the error handler is using',1),(3153,'they can also handle an exception or even detour a message',1),(3154,'info139using exception policiesnote in camel, exception policies are specified with the onexception method in the route, so we’ll use the term onexception interchangeably with “exception policy',1),(3155,'” we’ll cover exception policies piece by piece, looking at how they catch exceptions, how they works with redelivery, and how they handle exceptions',1),(3156,'then we’ll take a look at custom error handling and put it all to work in an example',1),(3157,'1 understanding how onexception catches exceptionswe’ll start by looking at how camel inspects the exception hierarchy to determine how to handle the error',1),(3158,'this will give you a better understanding of how you can use onexception to your advantage',1),(3159,'imagine you have this exception hierarchy being thrown:org',1),(3160,'runtimecamelexception (wrapper by camel) + com',1),(3161,'orderfailedexception  + java',1),(3162,'connectexceptionthe real cause is a connectexception, but it’s wrapped in an orderfailedexception and yet again in a runtimecamelexception',1),(3163,'camel will traverse the hierarchy from the bottom up to the root searching for an onexception that matches the exception',1),(3164,'in this case, camel will start with java',1),(3165,'for each of those three exceptions, camel will compare the exception to the defined onexceptions to select the best matching onexception policy',1),(3166,'if no suitable policy can be found, camel relies on the configured error handler settings',1),(3167,'we’ll drill down and look at how the matching works, but for now you can think of this as camel doing a big instanceof check against the exceptions in the hierarchies, following the order in which the onexceptions were defined',1),(3168,'suppose you have a route with the following onexception:onexception(orderfailedexception',1),(3169,'class)',1),(3170,'maximumredeliveries(3);the aforementioned connectexception is being thrown, and the camel error handler is trying to handle this exception',1),(3171,'because you have an exception policy defined, it will check whether the policy matches the thrown exception or not',1),(3172,'the matching is done as follows:1 camel starts with the java',1),(3173,'connectexception and compares it to onexception(orderfailedexception',1),(3174,'class)',1),(3175,'camel checks whether the two exceptions are exactly the same type, and in this case they’re not—connectionexception and orderfailedexception aren’t the same type',1),(3176,'2 camel checks whether connectexception is a subclass of orderfailedexception, and this isn’t true either',1),(3177,'so far, camel has not found a match',1),(3178,'3 camel moves up the exception hierarchy and compares again with orderfailedexception',1),(3179,'this time there is an exact match, because they’re both of the type orderfailedexception',1),(3180,'info140 chapter 5 error handlingno more matching takes place—camel got an exact match, and the exception policy will be used',1),(3181,'when an exception policy has been selected, its configured policy will be used by the error handler',1),(3182,'in this example, the policy defines the maximum redeliveries to be 3, so the error handler will attempt at most 3 redeliveries when this kind of exception is thrown',1),(3183,'any value configured on the exception policy will override options configured on the error handler',1),(3184,'for example, suppose the error handler had the maximumredeliveries option configured as 5',1),(3185,'because the onexception has the same option configured, its value of 3 will be used instead',1),(3186,'note the book’s source code has an example that demonstrates what you’ve just learned',1),(3187,'take a look at the onexceptiontest class in chapter5/onexception',1),(3188,'it has multiple test methods, each showing a scenario of how onexception works',1),(3189,'let’s make the example a bit more interesting and add a second onexception definition:onexception(orderfailedexception',1),(3190,'class)',1),(3191,'maximumredeliveries(3); onexception(connectexception',1),(3192,'class)',1),(3193,'maximumredeliveries(10);if the same exception hierarchy is thrown as in the previous example, camel would select the second onexception because it directly matches the connectionexception',1),(3194,'this allows you to define different strategies for different kinds of exceptions',1),(3195,'in this example, it is configured to use more redelivery attempts for connection exceptions than for order failures',1),(3196,'tip this example demonstrates how onexception can influence the redelivery polices the error handler uses',1),(3197,'if an error handler was configured to perform only 2 redelivery attempts, the preceding onexception would overload this with 10 redelivery attempts in the case of connection exceptions',1),(3198,'let’s look at another example',1),(3199,'this time, imagine that a java',1),(3200,'ioexception exception was thrown',1),(3201,'camel will do its matching, and because orderfailedexception isn’t a direct match, and ioexception isn’t a subclass of it, it’s out of the game',1),(3202,'the same applies for the connectexception',1),(3203,'in this case, there are no onexception definitions that match, and camel will fall back to using the configuration of the current error handler',1),(3204,'you can see this in action by running the following maven goal from chapter 5/ onexception directory:mvn test -dtest=onexceptionfallbacktestonexception and gap detectioncan camel do better if there isn’t a direct hit',1),(3205,'yes, it can, because camel uses a gapdetection mechanism that calculates the gaps between a thrown exception and the onexceptions and then selects the onexception with the lowest gap as the winner',1),(3206,'this may sound confusing, so let’s look at an example',1),(3207,'info141using exception policies suppose you have these three onexception definitions, each having a different redelivery policy:onexception(connectexception',1),(3208,'class)',1),(3209,'maximumredeliveries(5); onexception(ioexception',1),(3210,'class)',1),(3211,'maximumredeliveries(3)',1),(3212,'class)',1),(3213,'maximumredeliveries(1)',1),(3214,'redeliverydelay(5000);and imagine this exception is thrown:org',1),(3215,'orderfailedexception + java',1),(3216,'filenotfoundexceptionwhich of those three onexceptions would be selected',1),(3217,'camel starts with the java',1),(3218,'filenotfoundexception and compares it to the onexception definitions',1),(3219,'because there are no direct matches, camel uses gap detection',1),(3220,'in this example, only onexception(ioexception',1),(3221,'class) and onexception(exception',1),(3222,'class) partly match, because java',1),(3223,'filenotfoundexception is a subclass of java',1),(3224,'here’s the exception hierarchy for filenotfoundexception: java',1),(3225,'exception + java',1),(3226,'ioexception  + java',1),(3227,'filenotfoundexceptionlooking at this exception hierarchy, you can see that java',1),(3228,'filenotfoundexception is a direct subclass of java',1),(3229,'exception, so the gap is computed as 1',1),(3230,'filenotfoundexception is 2',1),(3231,'at this point, the best candidate has a gap of 1',1),(3232,'camel will then go the same process with the next exception from the thrown exception hierarchy, which is orderfailedexception',1),(3233,'this time, it’s only the onexception(exception',1),(3234,'class) that partly matches, and the gap between orderfailedexception and exception is also 1:java',1),(3235,'exception + ordernotfoundexceptionso what now',1),(3236,'you have two gaps, both calculated as 1',1),(3237,'in the case of a tie, camel will always pick the first match, because the cause exception is most likely the last in the hierarchy',1),(3238,'in this case, it’s a filenotfoundexception, so the winner will be onexception(ioexception',1),(3239,'class)',1),(3240,'this example is provided in the source code for the book in the chapter5/onexception directory',1),(3241,'you can try it using the following maven goal:mvn test -dtest=onexceptiongaptestgap detection allows you to define coarse-grained policies and also to have a few finegrained policies that overrule the coarse-grained ones',1),(3242,'does this sound familiar',1),(3243,'yes, it’s related to the scoping that we covered in section 5',1),(3244,'info142 chapter 5 error handlingmultiple exceptions per onexceptionso far, you’ve only seen examples with one exception per onexception, but you can define multiple exceptions in the same onexception:onexception(xpathexception',1),(3245,'class, transformerexception',1),(3246,'class)',1),(3247,'class, sqlexception',1),(3248,'class, jmsexception',1),(3249,'class)',1),(3250,'maximumredeliveries(5)',1),(3251,'redeliverydelay(3000);here’s the same example using spring xml:<camelcontext xmlns=\"http://camel',1),(3252,'org/schema/spring\">    <onexception>         <exception>javax',1),(3253,'transform',1),(3254,'transformerexception</exception>         <to uri=\"log:xml',1),(3255,'jmsexception</exception>         <redeliverpolicy maximumredeliveries=\"5\" redeliverydelay=\"3000\"/>    </onexception> </camelcontext>our next topic is how onexception works with redelivery',1),(3256,'even though we’ve touched on this already in our examples, we’ll go into the details in the next section',1),(3257,'2 understanding how onexception works with redeliveryonexception works with redeliveries, but there are a couple of things you need to be aware of that might not be immediately obvious',1),(3258,'suppose you have the following route: from(\"jetty:http://0',1),(3259,'0/orderservice\")',1),(3260,'beanref(\"orderbean\", \"preparereply\");you use the camel jetty component to expose an http service where statuses of pending orders can be queried',1),(3261,'the order status information is retrieved from a remote erp system by the mina component using low-level socket communication',1),(3262,'you’ve learned how to configure this on the error handler itself, but it’s also possible to configure this on the onexception',1),(3263,'suppose you want camel to retry invoking the external tcp service, in case there has been an io-related error, such as a lost network connection',1),(3264,'to do this, you can simply add the onexception and configure the redelivery policy as you like',1),(3265,'in the following example, the redelivery tries at most 5 times:onexception(ioexception',1),(3266,'class)',1),(3267,'maximumredeliveries(5);you’ve already learned that onexception(ioexception',1),(3268,'class) will catch those iorelated exceptions and act accordingly',1),(3269,'info143using exception policies in this example, the delay will be 1 second',1),(3270,'camel will use the default redelivery policy settings outlined in table 5',1),(3271,'3 and then override those values with values defined in the onexception',1),(3272,'because the delay was not overridden in the onexception, the default value of 1 second is used',1),(3273,'tip when you configure redelivery policies, they override the existing redelivery policies set in the current error handler',1),(3274,'this is convention over configuration, because you only need to configure the differences, which is often just the number of redelivery attempts or a different redelivery delay',1),(3275,'now let’s make it a bit more complicated: errorhandler(defaulterrorhandler()',1),(3276,'maximumredeliveries(3)',1),(3277,'class)',1),(3278,'maximumredeliveries(5);from(\"jetty:http://0',1),(3279,'0/orderservice\")',1),(3280,'yes, it’s 3 seconds, because onexception will fall back and use the redelivery policies defined by the error handler, and its value is configured as delay(3000)',1),(3281,'now let’s remove the maximumredeliveries(5) option from the onexception, so it’s defined as onexception(ioexception',1),(3282,'class):errorhandler(defaulterrorhandler()',1),(3283,'maximumredeliveries(3)',1),(3284,'class);from(\"jetty:http://0',1),(3285,'0/orderservice\")',1),(3286,'i am sure you’ll say the answer is 3—the value defined on the error handler',1),(3287,'in this case, though, the answer is 0',1),(3288,'camel won’t attempt to do any redelivery because any onexception will override the maximumredeliveries to 0 by default (redelivery is disabled by default) unless you explicitly set the maximumredeliveries option',1),(3289,'the reason why camel implements this behavior is our next topic: using onexception to handle exceptions',1),(3290,'3 understanding how onexception can handle exceptionssuppose you have a complex route that processes a message in multiple steps',1),(3291,'each step does some work on the message, but any step can throw an exception to indicate that the message can’t be processed and that it should be discarded',1),(3292,'this is where handling exceptions with onexception comes into the game',1),(3293,'handling an exception with onexception is similar to exception handling in java itself',1),(3294,'you can think of it as being like using a try',1),(3295,'info144 chapter 5 error handling this is best illustrated with an example',1),(3296,'imagine you need to implement an erp server-side service that serves order statuses',1),(3297,'this is the erp service you called from the previous section: public void configure() {    try {        from(\"mina:tcp://0',1),(3298,'process(new validateorderid())',1),(3299,'to(\"jms:queue:order',1),(3300,'status\")',1),(3301,'process(new generateresponse());                         } catch (jmsexception e) {',1),(3302,'process(new generatefailureresponse());            } }this snippet of pseudocode involves multiple steps in generating the response',1),(3303,'if something goes wrong, you catch the exception and return a failure response b',1),(3304,'we call this pseudocode because it shows your intention but the code won’t compile',1),(3305,'this is because the java dsl uses the fluent builder syntax, where method calls are stacked together to define the route',1),(3306,'catch mechanism in java works at runtime to catch exceptions that are thrown when the configure() method is executed, but in this case the configure() method is only invoked once, when camel is started (when it initializes and builds up the route pat...',1),(3307,'don’t despair',1),(3308,'camel has a counterpart to the classic try',1),(3309,'finally block in its dsl: dotry',1),(3310,'using dotry, docatch, and dofinallylisting 5',1),(3311,'3 shows how you can make the code compile and work at runtime as you would expect with a try',1),(3312,'process(new validateorderid())',1),(3313,'to(\"jms:queue:order',1),(3314,'status\")',1),(3315,'process(new generateresponse());',1),(3316,'docatch(jmsexception',1),(3317,'class)',1),(3318,'process(new generatefailureresponse())',1),(3319,'docatch block was a bit of a sidetrack, but it’s useful because it helps bridge the gap between thinking in regular java code and thinking in eips',1),(3320,'docatch block has one limitation—it’s only route scoped',1),(3321,'the blocks only work in the route in which they’re defined',1),(3322,'onexception, on the other hand, works in both context and route scopes, so you can try revising listing 5',1),(3323,'3 using onexception',1),(3324,'this is illustrated in listing 5',1),(3325,'listing 5',1),(3326,'3 using dotry',1),(3327,'docatch with camel routingrethrows caught exceptionb    www',1),(3328,'info145using exception policiesonexception(jmsexception',1),(3329,'class)',1),(3330,'process(new generatefailueresponse());from(\"mina:tcp://0',1),(3331,'process(new validateorderid())',1),(3332,'to(\"jms:queue:order',1),(3333,'status\")',1),(3334,'process(new generateresponse());a difference between docatch and onexception is that docatch will handle the exception, whereas onexception will, by default, not handle it',1),(3335,'that’s why you use handled(true) b to instruct camel to handle this exception',1),(3336,'as a result, when a jmsexception is thrown, the application acts as if the exception were caught in a catch block using the regular java try',1),(3337,'catch mechanism',1),(3338,'in listing 5',1),(3339,'4, you should also notice how the concerns are separated and the normal route path is laid out nicely and simply; it isn’t mixed up with the exception handling',1),(3340,'imagine that a message arrives on the tcp endpoint, and the camel application routes the message',1),(3341,'the message passes the validate processor and is about to be sent to the jms queue, but this operation fails and a jmsexception is thrown',1),(3342,'5 is a sequence diagram showing the steps that take place inside camel in such a situation',1),(3343,'it shows how onexception is triggered to handle the exception',1),(3344,'5 shows how the jmsproducer throws the jmsexception to the channel, which is where the error handler lives',1),(3345,'the route has an onexception defined that reacts when a jmsexception is thrown, and it processes the message',1),(3346,'the generatefailureresponse processor generates a custom failure message that is supposed to be returnedlisting 5',1),(3347,'4 using onexception in context scopehandles all jmsexceptionsbjmsproducervalidateprocessor channel onexceptiongeneratefailureresponsejmsexceptionprocessprocessonexception(jmsexception',1),(3348,'class)processhandled and break outbreak outreturnexceptionthrownfigure 5',1),(3349,'5 sequence diagram of a message being routed and a jmsexception being thrown from the jmsproducer, which is handled by the onexception',1),(3350,'onexception generates a failure that is to be returned to the caller',1),(3351,'because the onexception was configured to handle exceptions— handled(true)—camel will break out from continuing the routing and will return the failure message to the initial consumer, which in turn returns the custom reply message',1),(3352,'note onexception doesn’t handle exceptions by default, so listing 5',1),(3353,'4 uses handled(true) to indicate that onexception should handle the exception',1),(3354,'this is important to remember, because it must be specified when you want to handle the exception',1),(3355,'handling an exception will not continue routing from the point where the exception was thrown',1),(3356,'if you want to ignore the exception and continue routing, you must use continued(true), which will be discussed in section 5',1),(3357,'before we move on, let’s take a minute to look at the example from listing 5',1),(3358,'4 revised to use spring xml',1),(3359,'the syntax is a bit different, as you can see:<camelcontext xmlns=\"http://camel',1),(3360,'org/schemas/spring\">    <onexception>        <exception>javax',1),(3361,'jmsexception</exception>         <handled><constant>true</constant></handled>              <process ref=\"failureresponse\"/>     </onexception>    <route>        <from uri=\"mina:tcp://0',1),(3362,'textline=true\"/>        <process ref=\"validateorder\"/>        <to uri=\"jms:queue:order',1),(3363,'status\"/>        <process ref=\"generateresponse\"/>    </route></camelcontext><bean id=\"failureresponse\"                                  class=\"camelinaction',1),(3364,'failureresponseprocessor\"/><bean id=\"validateorder\" class=\"camelinaction',1),(3365,'validateprocessor\"/><bean id=\"generateresponse\" class=\"camelinaction',1),(3366,'responseprocessor\"/>notice how onexception is set up—you must define the exceptions in the exception tag',1),(3367,'also, handled(true) b is a bit longer because you must enclose it in the <constant> expression',1),(3368,'there are no other noteworthy differences in the rest of the route',1),(3369,'listing 5',1),(3370,'5 uses a custom processor to generate a failure response c',1),(3371,'let’s take a closer look at that',1),(3372,'4 custom exception handlingsuppose you want to return a custom failure message, as in listing 5',1),(3373,'5, that indicates not only what the problem was but that also includes details from the current camel message',1),(3374,'listing 5',1),(3375,'5 laid out how to do this using onexception',1),(3376,'listing 5',1),(3377,'6 shows how the failure processor could be implemented',1),(3378,'listing 5',1),(3379,'5 spring xml revision of listing 5',1),(3380,'4handles all jmsexceptionsbprocessor generates failure responsec    www',1),(3381,'info147using exception policiespublic class failureresponseprocessor implements processor {    public void process(exchange exchange) throws exception {        string body = exchange',1),(3382,'class);        exception e = exchange',1),(3383,'class);               stringbuilder sb = new stringbuilder();        sb',1),(3384,'append(\"error: \");        sb',1),(3385,'getmessage());        sb',1),(3386,'append(\"\\nbody: \");        sb',1),(3387,'setbody(sb',1),(3388,'tostring());    } }first, you grab the information you need: the message body and the exception b',1),(3389,'it may seem a bit odd that you get the exception as a property and not using exchange',1),(3390,'you do that because you’ve marked onexception to handle the exception; this was done at b in listing 5',1),(3391,'when you do that, camel moves the exception from the exchange to the exchange',1),(3392,'the rest of the processor builds the custom failure message that’s to be returned to the caller',1),(3393,'you may wonder whether there are other properties camel sets during error handling, and there are',1),(3394,'they’re listed in table 5',1),(3395,'but from an end-user perspective, it’s only the first two properties in table 5',1),(3396,'the other two properties are used internally by camel in its error-handling and routing engine',1),(3397,'one example of when the failure_endpoint property comes in handy is when you route messages through the recipient list eip, which sends a copy of the message to a dynamic number of endpoints',1),(3398,'without this information, you wouldn’t know precisely which of those endpoints failed',1),(3399,'it’s worth noting that in listing 5',1),(3400,'6 you use a camel processor, which forces you to depend on the camel api',1),(3401,'you can use a bean instead, as follows: listing 5',1),(3402,'6 using a processor to create a failure response to be returned to the callertable 5',1),(3403,'5 properties on the exchange related to error handlingproperty type descriptionexchange',1),(3404,'exception_ caughtexception the exception that was caught',1),(3405,'failure_ endpointstring the url of the endpoint that failed if a failure occurred when sending to an endpoint',1),(3406,'if the failure did not occur while sending to an endpoint, this property is null',1),(3407,'or true if the exchange was moved to a dead letter queue',1),(3408,'gets the exceptionb    www',1),(3409,'info148 chapter 5 error handlingpublic class failureresponsebean {    public string failmessage(string body, exception e) {             stringbuilder sb = new stringbuilder();        sb',1),(3410,'append(\"error: \");        sb',1),(3411,'getmessage());        sb',1),(3412,'append(\"\\nbody: \");        sb',1),(3413,'append(body);        return sb',1),(3414,'tostring();    } }as you can see, you can use camel’s parameter binding b to declare the parameter types you want to use',1),(3415,'the first parameter is the message body, and the second is the exception',1),(3416,'there will be situations where you’ll want to simply ignore the exception and continue routing',1),(3417,'5 ignoring exceptionsin section 5',1),(3418,'handling an exception means that camel will break out of the route',1),(3419,'but there are times when all you want is to catch the exception and continue routing',1),(3420,'this is possible to do in camel using continued',1),(3421,'all you have to do is to use continued(true) instead of handled(true)',1),(3422,'suppose we want to ignore any validationexception which may be thrown in the route, laid out in listing 5',1),(3423,'listing 5',1),(3424,'7 shows how we can do this',1),(3425,'onexception(jmsexception',1),(3426,'class)',1),(3427,'process(new generatefailueresponse());onexception(validationexception',1),(3428,'class)',1),(3429,'process(new validateorderid())',1),(3430,'to(\"jms:queue:order',1),(3431,'status\")',1),(3432,'process(new generateresponse());as you can see, all you have to do is add another onexception that leverages continued(true) b',1),(3433,'note you can’t use both handled and continued on the same onexception; continued automatically implies handled',1),(3434,'now imagine that a message once again arrives on the tcp endpoint, and the camel application routes the message',1),(3435,'but this time the validate processor throws a validationexception',1),(3436,'this situation is illustrated in figure 5',1),(3437,'when the validateprocessor throws the validationexception, it’s propagated back to the channel, which lets the error handler kick in',1),(3438,'the route has an onexception defined that instructs the channel to continue routing the message—continued(true)',1),(3439,'listing 5',1),(3440,'7 using continued to ignore validationexceptionsexception provided as parameterbignores all validationexceptionsb    www',1),(3441,'info149using exception policieswhen the message arrives at the next channel, it’s as if the exception were not thrown',1),(3442,'this is much different from what you saw in section 5',1),(3443,'3 when using handled(true), which causes the processing to break out and not continue routing',1),(3444,'you’ve learned a bunch of new stuff, so let’s continue with the error handler example and put your knowledge into practice',1),(3445,'6 implementing an error handler solutionsuppose your boss brings you a new problem',1),(3446,'this time, the remote http server used for uploading files is unreliable, and he wants you to implement a secondary failover to transfer the files by ftp to a remote ftp server',1),(3447,'you have been studying camel in action, and you’ve learned that camel has extensive support for error handling and that you could leverage onexception to provide this kind of feature',1),(3448,'with great confidence, you fire up the editor and alter the route as shown in listing 5',1),(3449,'maximumredeliveries(5)',1),(3450,'class)',1),(3451,'maximumredeliveries(3)',1),(3452,'password=secret\");                  from(\"file:/rider/files/upload',1),(3453,'user=gear&password=secret\");this listing adds an onexception b to the route, telling camel that in the case of an ioexception, it should try redelivering up to 3 times using a 10-second delay',1),(3454,'if there is still an error after the redelivery attempts, camel will handle the exception andlisting 5',1),(3455,'8 route using error handling with failover to ftpvalidateprocessorminaconsumer channel onexceptionvalidationexceptionprocessprocessonexception(validationexception',1),(3456,'class)continuedchannelprocessexceptionthrownfigure 5',1),(3457,'6 sequence diagram of a message being routed and a validationexception being thrown from the validateprocessor',1),(3458,'the exception is handled and continued by the onexception policy, causing the message to continue being routed as if the exception were not thrown',1),(3459,'info150 chapter 5 error handlingreroute the message to the ftp endpoint instead',1),(3460,'the power and flexibility of the camel routing engine shines here',1),(3461,'the onexception is just another route, and camel will continue on this route instead of the original route',1),(3462,'note in listing 5',1),(3463,'8, it’s only when onexception is exhausted that it will reroute the message to the ftp endpoint b',1),(3464,'the onexception has been configured to redeliver up till 3 times before giving up and being exhausted',1),(3465,'the book’s source code contains this example in the chapter5/usecase directory, and you can try it out yourself',1),(3466,'the example contains a server and a client that you can start using maven:mvn exec:java -pserver mvn exec:java -pclientboth the server and client output instructions on the console about what to do next, such as copying a file to the target/rider fol...',1),(3467,'before we finish up this chapter, we must take a look at a few more error-handling features',1),(3468,'they’re used rarely, but they provide power in situations where you need more fine-grained control',1),(3469,'5 other error-handling featureswe’ll end this chapter by looking at some of the other features camel provides for error handling: ■ onwhen—allows you to dictate when an exception policy is in use■ onredeliver—allows you to execute some code before th...',1),(3470,'1 using onwhenthe onwhen predicate filter allows more fine-grained control over when an onexception should be triggered',1),(3471,'suppose a new problem has emerged with your application in listing 5',1),(3472,'this time the http service rejects the data and returns an http 500 response with the constant text “illegal data”',1),(3473,'your boss wants you to handle this by moving the file to a special folder where it can be manually inspected to see why it was rejected',1),(3474,'first, you need to determine when an http error 500 occurs and whether it contains the text “illegal data”',1),(3475,'you decide to create a java method that can test this, as shown in listing 5',1),(3476,'public final class myhttputil {    public static boolean isillegaldataerror(                              httpoperationfailedexception cause) {     listing 5',1),(3477,'info151other error-handling features        int code = cause',1),(3478,'getstatuscode();                 if (code',1),(3479,'= 500) {            return false;        }        return \"illegal data\"',1),(3480,'equals(cause',1),(3481,'getresponsebody()',1),(3482,'tostring());    } }when the http operation isn’t successful, the camel http component will throw an org',1),(3483,'the getstatuscode() method on httpoperationfailedexception b, returns the http status code',1),(3484,'this allows you to determine if it’s an http error code 500 with the “illegal data” body text',1),(3485,'next, you need to use the utility class from listing 5',1),(3486,'9 in your existing route from listing 5',1),(3487,'but first you add the onexception to handle the httpoperationfailedexception and detour the message to the illegal folder:onexception(httpoperationfailedexception',1),(3488,'class)',1),(3489,'to(\"file:/rider/files/illegal\");now, whenever an httpoperationfailedexception is thrown, camel moves the message to the illegal folder',1),(3490,'it would be better if you had more fine-grained control over when this onexception triggers',1),(3491,'how could you incorporate your code from listing 5',1),(3492,'i am sure you have guessed where we’re going—yes, you can use the onwhen predicate',1),(3493,'all you need to do is insert the onwhen into the onexception, as shown here:onexception(httpoperationfailedexception',1),(3494,'class)',1),(3495,'class, \"isillegaldata\"))',1),(3496,'to(\"file:/acme/files/illegal\");camel adapts to your pojo classes and uses them as is, thanks to the power of camel’s parameter binding, which we covered in the previous chapter',1),(3497,'this is a powerful way to develop your application without being tied to the camel api',1),(3498,'onwhen is a general function that also exists in other camel features, such as interceptors and oncompletion, so you can use this technique in various situations',1),(3499,'next, let’s look at onredeliver, which allows fine-grained control when a redelivery is about to occur',1),(3500,'2 using onredeliverthe purpose of onredeliver is to allow some code to be executed before a redelivery is performed',1),(3501,'this gives you the power to do custom processing on the exchange before camel makes a redelivery attempt',1),(3502,'you can, for instance, use it to add custom headers to indicate to the receiver that this is a redelivery attempt',1),(3503,'onredeliver uses an org',1),(3504,'processor, in which you implement the code to be executed',1),(3505,'onredeliver can be configured on the error handler, on onexception, or on both, as follows:gets http status codeb    www',1),(3506,'maximumredeliveries(3)',1),(3507,'onredeliver(new myonredeliveryprocessor());onexception(ioexception',1),(3508,'class)',1),(3509,'maximumredeliveries(5)',1),(3510,'onredeliver(new myotheronredeliveryprocessor());onredeliver is also scoped, so if an onredeliver is set on an onexception, it overrules any onredeliver set on the error handler',1),(3511,'in spring dsl, onredeliver is configured as a reference to a spring bean, as follows:<onexception onredeliveryref=\"myotherredelivery\">    <exception>java',1),(3512,'ioexception</exception> </onexception><bean id=\"myotherredelivery\"                                                 class=\"com',1),(3513,'myotheronredeliveryproceossor\"/>finally, let’s look at one last feature: retrywhile',1),(3514,'3 using retrywhileretrywhile is used when you want fine-grained control over the number of redelivery attempts',1),(3515,'it’s also a predicate that’s scoped, so you can define it on the error handler or on onexception',1),(3516,'you can use retrywhile to implement your own generic retry ruleset that determines how long it should retry',1),(3517,'listing 5',1),(3518,'10 shows some skeleton code demonstrating how this can be done',1),(3519,'public class myretryruleset {public boolean shouldretry(                   @header(exchange',1),(3520,'redelivery_counter) integer counter,                   exception causedby) {',1),(3521,'}using your own myretryruleset class, you can implement your own logic determining whether it should continue retrying or not',1),(3522,'if the method returns true, a redelivery attempt is conducted; if it returns false, it give up',1),(3523,'to use your ruleset, you configure retrywhile on the onexception as follows:onexception(ioexception',1),(3524,'class)',1),(3525,'retrywhile(bean(myretryruletset',1),(3526,'class));in spring xml you configure retrywhile as shown:<onexception>  <exception>java',1),(3527,'ioexception</exception>  <retrywhile><method ref=\"myretryruleset\"/></retrywhile> </onexception><bean id=\"myretryruleset\" class=\"com',1),(3528,'myretryruleset\"/>listing 5',1),(3529,'10 skeleton code to illustrate principle of using retrywhile    www',1),(3530,'info153summary and best practicesthat gives you fine-grained control over the number of redelivery attempts performed by camel',1),(3531,'that’s it',1),(3532,'we’ve now covered all the features camel provides for fine-grained control over error handling',1),(3533,'6 summary and best practicesin this chapter, you saw how recoverable and irrecoverable errors are represented in camel',1),(3534,'we also looked at all the provided error handlers, focusing on the most important of them',1),(3535,'you saw how camel can control how exceptions are dealt with, using redelivery policies to set the scene and exception policies to handle specific exceptions differently',1),(3536,'finally, we looked at what camel has to offer when it comes to fine-grained control over error handling, putting you in control of error handling in camel',1),(3537,'let’s revisit some of the key ideas from this chapter, which you can take away and apply to your own camel applications:■ error handling is hard',1),(3538,'realize from the beginning that the unexpected can happen and that dealing with errors is hard',1),(3539,'the challenge keeps rising when businesses have more and more of their it portfolio integrated and operate it 24/7/365',1),(3540,'■ error handling isn’t an afterthought',1),(3541,'when it systems are being integrated, they exchange data according to agreed-upon protocols',1),(3542,'those protocols should also specify how errors will be dealt with',1),(3543,'camel allows you to separate routing logic from error-handling logic',1),(3544,'this avoids cluttering up your logic, which otherwise could become harder to maintain',1),(3545,'use camel features such as error handlers, onexception, and dotry',1),(3546,'some errors are recoverable, such as connection errors',1),(3547,'you should apply strategies to recover from these errors',1),(3548,'■ use asynchronous delayed redelivery',1),(3549,'if the order of messages processed from consumers doesn’t matter, leverage asynchronous redelivery to achieve higher scalability',1),(3550,'■ handle fault messages',1),(3551,'if you use components such as jbi, cxf, or soap, which may return fault messages, you can enable fault handling in camel to let the error handlers react to those faults',1),(3552,'■ use monitoring tooling',1),(3553,'use tooling to monitor your camel applications so it can react and alert personnel if severe errors occur',1),(3554,'chapter 12 covers such strategies',1),(3555,'■ build unit tests',1),(3556,'build unit tests that simulate errors to see if your error-handling strategies are up to the task',1),(3557,'3 shows how to do this',1),(3558,'in the next chapter, we’ll look at a topic that can help make you a successful integration specialist, and without it, you’ll almost certainly be in trouble: testing with camel',1),(3559,'we’ll also look at how you can simulate errors to test whether your error handling strategies work as expected',1),(3560,'info154testing with camelin the last chapter, we covered error handling and learned that it’s hard to handle and cater for all difficulties that can possibly arise',1),(3561,'to help address this problem, you can test as many situations as possible',1),(3562,'in this chapter, we’ll look at how to test with camel—not only testing your projects when everything goes well, but also simulating errors and testing whether your error handling strategies are up to the job',1),(3563,'testing is vital to ensuring that your integration projects are successful',1),(3564,'junit has become the standard api for unit testing, and the camel test kit builds on top of junit, leveraging the existing junit tooling',1),(3565,'if you aren’t familiar with junit, you can read about it in junit in action, second edition (http://www',1),(3566,'this chapter covers■ introducing and using the camel test kit■ testing using multiple environments■ using mocks■ simulating real components■ simulating errors■ testing without mocks    www',1),(3567,'info155introducing the camel test kit a good way to perform unit testing on a camel application is to start the application, send messages to the application, and verify that the messages are routed as expected',1),(3568,'this is illustrated in figure 6',1),(3569,'you send a message to the application, which transforms the message to another format and returns the output',1),(3570,'you can then verify that the output is as expected',1),(3571,'this is how the camel test kit is used for testing',1),(3572,'you’ll learn to set up expectations as preconditions for your unit tests, start the tests by sending in messages, and verify the results to determine whether the tests passed',1),(3573,'the mock component is based on this principle, and we’ll cover it thoroughly',1),(3574,'then we’ll look at several techniques for simulating errors, so you can test your error handling as well',1),(3575,'let’s get started',1),(3576,'1 introducing the camel test kitcamel provides rich facilities for testing your projects, and it includes a test kit that gets you writing unit tests quickly in familiar waters using the regular junit api',1),(3577,'in fact, it’s the same test kit that camel uses for testing itself',1),(3578,'2 gives a high-level overview of the camel test kit',1),(3579,'2 boils down to three parts',1),(3580,'the junit extensions are a number of classes on top of junit that make unit testing with camel much easier',1),(3581,'we’ll cover them in the next section',1),(3582,'the mock component is covered in section 6',1),(3583,'and you’re already familiar with the producertemplate—it’s a convenient feature that allows you to easily send messages to camel when testing',1),(3584,'let’s now look at the camel junit extensions and see how to use them to write camel unit tests',1),(3585,'1 the camel junit extensionsso what are the camel junit extensions',1),(3586,'they are six classes in a small jar file, cameltest',1),(3587,'jar, that ships with camel',1),(3588,'the classes are listed in table 6',1),(3589,'of the six classes listed in table 6',1),(3590,'1, you’ll often only use the ones suited for unit testing either the older junit 3',1),(3591,'x version',1),(3592,'let’s get started using the camel test kit',1),(3593,'camel-test camel-corejunitextensionsmockcomponentproducertemplatefigure 6',1),(3594,'2 the camel test kit is provided in two jar files containing the junit extensions, mock component, and producer template',1),(3595,'1 testing a camel application by sending a message to the application and then verifying the returned output    www',1),(3596,'info156 chapter 6 testing with camel6',1),(3597,'2 using the camel test kitwe’ll start simply and use the following route for testing:from(\"file:inbox\")',1),(3598,'to(\"file:outbox\");this is the “hello world” example for integration kits that moves files from one folder to another',1),(3599,'so how do you go about unit testing this route',1),(3600,'you could do it the traditional way and write unit test code with the plain junit api',1),(3601,'this would require at least 30 lines of code, because the api for file handling in java is very low level, and you need a fair amount of code when working with files',1),(3602,'an easier solution is to use the camel test kit',1),(3603,'in the next couple of sections, you’ll work with the cameltestsupport class—it’s the easiest to get started with',1),(3604,'then in section 6',1),(3605,'5 you’ll try the camelspringtestsupport class and see how you can do unit testing based on spring routes',1),(3606,'3 unit testing with the cameltestsupport classin this chapter, we’ve kept the dependencies low when using the camel test kit',1),(3607,'all you need to include is the following dependency in the maven pom',1),(3608,'camel</groupid>    <artifactid>camel-test</artifactid>    <version>2',1),(3609,'0</version>    <scope>test</scope> </dependency><dependency>    <groupid>junit</groupid>    <artifactid>junit</artifactid>table 6',1),(3610,'1 classes in the camel test kit, provided in camel-test',1),(3611,'jarclass descriptionorg',1),(3612,'test',1),(3613,'testsupportjunit 3',1),(3614,'x abstract base test class with additional assertion methods',1),(3615,'test',1),(3616,'cameltestsupportjunit 3',1),(3617,'x base test class prepared for testing camel routes',1),(3618,'this is the test class you should use when using junit 3',1),(3619,'test',1),(3620,'camelspringtestsupportjunit 3',1),(3621,'x base test class prepared for testing camel routes defined using spring dsl',1),(3622,'this class extends cameltestsupport and has additional spring-related methods',1),(3623,'test',1),(3624,'testsupportjunit 4',1),(3625,'x abstract base test class with additional assertion methods',1),(3626,'test',1),(3627,'cameltestsupportjunit 4',1),(3628,'x base test class prepared for testing camel routes',1),(3629,'this is the test class you should use when using junit 4',1),(3630,'test',1),(3631,'camelspringtestsupportjunit 4',1),(3632,'x base test class prepared for testing camel routes defined using spring dsl',1),(3633,'this class extends cameltestsupport and has additional spring-related methods',1),(3634,'info157introducing the camel test kit    <version>4',1),(3635,'1</version>    <scope>test</scope> </dependency>warning spring 2',1),(3636,'5 only works with junit 4',1),(3637,'0 works with higher versions of junit such as 4',1),(3638,'1, used in the preceding code',1),(3639,'we won’t go into detail here on how to set up your java editor for developing with camel; chapter 11 will cover this in detail',1),(3640,'for now, you just need to know that the camel test kit lives in the camel-test-2',1),(3641,'jar file and that the other jars needed are junit and camel-core, which are implied',1),(3642,'let’s try it',1),(3643,'you want to build a unit test to test a camel route that copies files from one directory to another',1),(3644,'the unit test is shown in listing 6',1),(3645,'test',1),(3646,'cameltestsupport; import org',1),(3647,'test;public class firsttest extends cameltestsupport {     @override             protected routebuilder createroutebuilder() throws exception {    return new routebuilder() {        @override        public void configure() throws exception {         ...',1),(3648,'to(\"file://target/outbox\");        }    }; }@test public void testmovefile() throws exception {         template',1),(3649,'txt\");        asserttrue(\"file not moved\", target',1),(3650,'exists());       } }the firsttest class must extend the org',1),(3651,'cameltestsupport class to conveniently leverage the camel test kit',1),(3652,'by overriding the createroutebuilder method, you can provide any route builder you wish',1),(3653,'you use an inlined route builder, which allows you to write the route directly within the unit test class',1),(3654,'all you need to do is override the configure method b and include your route',1),(3655,'the test methods are regular junit methods, so the method must be annotated with @test to be included when testing',1),(3656,'you’ll notice that the code in this method islisting 6',1),(3657,'1 a first unit test using the camel test kitdefines route to testbcreates hello',1),(3658,'txt filecverifies file is movedd    www',1),(3659,'info158 chapter 6 testing with camelfairly short',1),(3660,'instead of using the low-level java file api, this example leverages camel as a client by using producertemplate to send a message to a file endpoint c, which writes the message as a file',1),(3661,'in the test, you sleep one second after dropping the file in the inbox folder; this gives camel a bit of time to react and route the file',1),(3662,'by default, camel scans twice per second for incoming files, so you wait one second to be on the safe side',1),(3663,'finally you assert that the file was moved to the outbox folder d',1),(3664,'the book’s source code includes this example',1),(3665,'you can try it on your own by running the following maven goal from the chapter6/firsttest directory: mvn test -dtest=firsttestwhen you run this example, it should output the result of the test as shown here:tests run: 1, failures: 0, errors: 0, skip...',1),(3666,'6 onward it’s now even easier to debug camel routes from within the ide',1),(3667,'see more details at http://camel',1),(3668,'improving the unit testthe unit test in listing 6',1),(3669,'1 could be improved in a few areas, such as ensuring that the starting directory is empty and that the written file’s content is what you expect',1),(3670,'the former is easy, because the cameltestsupport class has a method to delete a directory',1),(3671,'you can do this in the setup method:public void setup() throws exception {    deletedirectory(\"target/inbox\");    deletedirectory(\"target/outbox\");    super',1),(3672,'setup(); }camel can also test the written file’s content to ensure it’s what you expect',1),(3673,'you may remember that camel provides a very elaborate type converter system, and that this system goes beyond converting between simple types and literals',1),(3674,'the camel type system includes file-based converters, so there is no need to fiddle with the various cumbersome java io file streams',1),(3675,'all you need to do is ask the type converter system to grab the file and return it to you as a string',1),(3676,'just as you had access to the template in listing 6',1),(3677,'1, the camel test kit also gives you direct access to the camelcontext',1),(3678,'the testmovefile method in listing 6',1),(3679,'1 could have been written as follows:@test public void testmovefile() throws exception {         template',1),(3680,'txt\");    asserttrue(\"file not moved\", target',1),(3681,'exists());    string content = context',1),(3682,'info159introducing the camel test kit',1),(3683,'class, target);    assertequals(\"hello world\", content); }the preceding examples cover the case where the route is defined in the unit test class as an anonymous inner class',1),(3684,'how do you go about unit testing that route instead',1),(3685,'let’s look at that next',1),(3686,'4 unit testing an existing routebuilder classit’s common to define camel routes in separate routebuilder classes, as in the filemoveroute class here:package camelinaction;import org',1),(3687,'routebuilder;public class filemoveroute extends routebuilder {    @override    public void configure() throws exception {        from(\"file://target/inbox\")',1),(3688,'to(\"file://target/outbox\");    } }how could you unit test this route from the filemoveroute class',1),(3689,'fortunately, it’s quite easy to set up unit tests that use the filemoveroute, as you can see here:protected routebuilder createroutebuilder() throws exception {    return new filemoveroute(); }yes, it’s that simple',1),(3690,'just return a new instance of your route class',1),(3691,'now you have learned how to use cameltestsupport for unit testing routes based on the java dsl',1),(3692,'but there is also a spring-based camelspringtestsupport class to be used for spring xml routes',1),(3693,'the next section shows how to test using spring xml– based routes',1),(3694,'5 unit testing with the springcameltestsupport classspringcameltestsupport is a base test class that’s used to unit test routes based on spring xml',1),(3695,'we’ll look at unit testing the route in listing 6',1),(3696,'2, which is a spring version of the route in listing 6',1),(3697,'<beans xmlns=\"http://www',1),(3698,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(3699,'org/2001/xmlschema-instance\"       xsi:schemalocation=\"           http://www',1),(3700,'org/schema/beans           http://www',1),(3701,'org/schema/beans/spring-beans-2',1),(3702,'xsd           http://camel',1),(3703,'org/schema/springlisting 6',1),(3704,'2 a spring-based version of the route in listing 6',1),(3705,'1 (firststep',1),(3706,'info160 chapter 6 testing with camel           http://camel',1),(3707,'org/schema/spring/camel-spring',1),(3708,'xsd\">    <camelcontext id=\"camel\" xmlns=\"http://camel',1),(3709,'org/schema/spring\">        <route>               <from uri=\"file://target/inbox\"/>            <to uri=\"file://target/outbox\"/>        </route>    </camelcontext></beans>notice that the route is the same route defined in listing 6',1),(3710,'so how can you unit test this route',1),(3711,'ideally you should be able to use unit tests regardless of the language used to define the route',1),(3712,'camel is able to handle this; the difference between using springcameltestsupport and cameltestsupport is just a matter of how the route is loaded',1),(3713,'the unit test in listing 6',1),(3714,'3 illustrates this point',1),(3715,'test',1),(3716,'camelspringtestsupport; import org',1),(3717,'test; import org',1),(3718,'abstractxmlapplicationcontext; import org',1),(3719,'classpathxmlapplicationcontext;public class springfirsttest extends camelspringtestsupport {    protected abstractxmlapplicationcontext createapplicationcontext() {        return new classpathxmlapplicationcontext(                       \"camelinactio...',1),(3720,'xml\");           }    @test    public void testmovefile() throws exception {        template',1),(3721,'txt\");        asserttrue(\"file not moved\", target',1),(3722,'exists());        string content = context',1),(3723,'class, target);        assertequals(\"hello world\", content);    } }you extend the camelspringtestsupport class so you can unit test with spring xml– based routes',1),(3724,'and unlike listing 6',1),(3725,'1, you need to use a spring-based mechanism to load the routes b; you use the classpathxmlapplicationcontext, which loads your route from the classpath',1),(3726,'this mechanism is entirely spring-based, so you can also uselisting 6',1),(3727,'3 a first unit test using spring xml routesloads spring xml fileb    www',1),(3728,'info161introducing the camel test kitthe filesystemxmlapplicationcontext, include multiple xml files, and so on— camel doesn’t impose any restrictions',1),(3729,'the testmovefile method is exactly the same as it was in listing 6',1),(3730,'1, which means you can use the same unit testing code regardless of how the route is defined',1),(3731,'in real life projects, you’ll have different deployment environments, such as local, test, preproduction, and production',1),(3732,'in the next section, we’ll look at how you can test the same project in those different environments with minimal effort',1),(3733,'6 unit testing in multiple environmentsa camel route is often tested in different environments—you may want to test it locally on your laptop, then later on a dedicated test platform, and so forth',1),(3734,'but you don’t want to rewrite tests every time you move to a new environment',1),(3735,'that’s why you externalize dynamic parts',1),(3736,'we’ll cover two solutions for externalizing dynamic parts using property files',1),(3737,'the first solution is based on the camel properties component and the second leverages spring property placeholders',1),(3738,'using the camel properties componentcamel has a properties component to support externalizing properties defined in the routes',1),(3739,'the properties component works in much the same way as spring property placeholders, but it has a few noteworthy improvements:■ it is built in the camel-core jar, which means it can be leveraged without the need for spring or any third-party framework',1),(3740,'■ it can be used in all the dsls, such as the java dsl, and is not limited to spring xml files',1),(3741,'■ it supports using placeholders in property files',1),(3742,'note for more details on the properties component, see the camel documentation: http://camel',1),(3743,'suppose you wanted to test the file-move unit test in two environments: production and test',1),(3744,'to use the camel properties component in spring xml, you have to declare it as a spring bean with the id properties, as shown:<bean id=\"properties\"      class=\"org',1),(3745,'propertiescomponent\">    <property name=\"location\" value=\"classpath:rider-prod',1),(3746,'properties\"/> </bean>in the rider-prod',1),(3747,'properties file, you define the externalized properties as key/value pairs:file',1),(3748,'inbox=rider/files/inbox file',1),(3749,'outbox=rider/files/outboxthe camelcontext element can then take advantage of the externalized properties directly in the endpoint uri, as shown in bold in this route:    www',1),(3750,'info162 chapter 6 testing with camel<camelcontext id=\"camel\" xmlns=\"http://camel',1),(3751,'org/schema/spring\">    <route>        <from uri=\"{{file',1),(3752,'outbox}}\"/>    </route> </camelcontext>you should notice that the camel syntax for property placeholders is a bit different than for spring property placeholders',1),(3753,'the camel properties component uses the {{key}} syntax, whereas spring uses ${key}',1),(3754,'instead of using a spring bean to define the camel properties component, you can use a specialized <propertyplaceholder> within the camelcontext, as follows:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(3755,'org/schema/spring\">    <propertyplaceholder id=\"properties\"                         location=\"classpath:rider-prod',1),(3756,'properties\"/>    <route>        <from uri=\"{{file',1),(3757,'outbox}}\"/>    </route> </camelcontext>your next goal is to create a reusable unit test that, with minimal effort, can be configured to test in either environment',1),(3758,'listing 6',1),(3759,'4 shows how this can be done',1),(3760,'public class camelridertest extends camelspringtestsupport {private string inboxdir; private string outboxdir;@endpointinject(uri = \"file:{{file',1),(3761,'inbox}}\")        private producertemplate inbox;public void setup() throws exception {    super',1),(3762,'resolvepropertyplaceholders(                    \"{{file',1),(3763,'resolvepropertyplaceholders(                   \"{{file',1),(3764,'outbox}}\");                  deletedirectory(inboxdir);    deletedirectory(outboxdir); }@override protected abstractxmlapplicationcontext createapplicationcontext() {    return new classpathxmlapplicationcontext(new string[]        {\"camelinaction/ri...',1),(3765,'xml\",          \"camelinaction/rider-came-test',1),(3766,'xml\"});           }@test public void testmovefile() throws exception {    inbox',1),(3767,'sendbodyandheader(\"hello world\",listing 6',1),(3768,'4 a reusable unit test for the test and production environmentsinjects producertemplatebc looks up properties usedloads spring xml filesd    www',1),(3769,'info163introducing the camel test kit                            exchange',1),(3770,'sleep(1000);    file target = new file(outboxdir + \"/hello',1),(3771,'txt\");    asserttrue(\"file not moved\", target',1),(3772,'exists());    string content = context',1),(3773,'class, target);    assertequals(\"hello world\", content); } }in the testmovefile method, you start the unit test by creating a file in the inbox directory, and to help with that you retrieve the producertemplate',1),(3774,'note that you use the @endpointinject annotation and refer to the inbox endpoint by the placeholder b',1),(3775,'in the setup method, you use the camelcontext to resolve the placeholders c, because you’ll later need to know the actual values for file',1),(3776,'the createapplicationcontext method loads the spring xml files',1),(3777,'you load two files d to minimize effort',1),(3778,'spring allows you to load multiple files and have the next file override the previous file—the idea is to define the camelcontext once, in the rider-camel-prod',1),(3779,'because rider-camel-test',1),(3780,'xml is defined as the second file, it will override identical beans from the former files',1),(3781,'you leverage this to override the properties bean and instruct it to load a different properties file, the rider-test',1),(3782,'properties file',1),(3783,'the rider-camel-test',1),(3784,'xml file is short and simple:<bean id=\"properties\"      class=\"org',1),(3785,'propertiescomponent\">    <property name=\"location\" value=\"classpath:rider-test',1),(3786,'properties\"/> </bean> this way, camelcontext is only defined once',1),(3787,'if you had the route defined in multiple files targeted for specific environments, you’d put the burden on yourself to synchronize those routes if you change something in the route',1),(3788,'by using this approach, you can unit test the route in different environments with minimal effort',1),(3789,'all you have to do is specify the files in the createapplicationcontext method targeted for the environment you’re testing',1),(3790,'this example is included in the book’s source code in the chapter6/firsttest directory',1),(3791,'you can try it using the following maven goal:mvn test -dtest=camelridertesttip if you’re not using spring xml, you can still reuse camel routes and unit tests for multiple environments',1),(3792,'you can use @endpointinject in your routebuilder class to dynamically inject endpoints for the environment you wish to test',1),(3793,'the camel properties component can also be used without spring',1),(3794,'the following listing sets up the camel properties component and uses it in a java dsl–based route',1),(3795,'the setup and testmovefile methods are omitted because they’re the same as in listing 6',1),(3796,'info164 chapter 6 testing with camelpublic class camelriderjavadslprodtest extends cameltestsupport {    protected camelcontext createcamelcontext() throws exception {        camelcontext context = super',1),(3797,'createcamelcontext();        propertiescomponent prop = context',1),(3798,'getcomponent(\"properties\",                                           propertiescomponent',1),(3799,'class);        prop',1),(3800,'setlocation(\"classpath:rider-prod',1),(3801,'properties\");        return context;    }    protected routebuilder createroutebuilder() throws exception {        return new routebuilder() {            public void configure() throws exception {                from(\"file:{{file',1),(3802,'outbox}}\");            }        };    } }to ensure that the property placeholder is loaded and in use as early as possible, you have to configure the propertiescomponent when the camelcontext is created',1),(3803,'you can do this by overriding the createcamelcontext method, which ensures the properties component is available to the routebuilder when it encounters the property placeholders in the endpoints used in the route',1),(3804,'you can run try this example using the following maven goals from the chapter6/ firsttest directory:mvn test -dtest=camelriderjavadsltest mvn test -dtest=camelriderjavadslprodtesttip you can use the jasypt component to encrypt sensitive information i...',1),(3805,'for example, you may not want to have passwords in clear text in the properties file',1),(3806,'you can read about the jasypt component at the camel website: http://camel',1),(3807,'org/jasypt',1),(3808,'we’ll now cover the same example but using spring property placeholders instead of the camel properties component',1),(3809,'using spring property placeholdersthe spring framework supports externalizing properties defined in the spring xml files using a feature known as spring property placeholders',1),(3810,'we’ll review the example from the previous section using spring property placeholders instead of the camel properties component',1),(3811,'the first thing you need to do is set up the route having the endpoint uris externalized',1),(3812,'this could be done as follows',1),(3813,'notice that spring uses the ${key} syntax',1),(3814,'<context:property-placeholder properties-ref=\"properties\"/><util:properties id=\"properties\"                 location=\"classpath:rider-prod',1),(3815,'properties\"/>   <camelcontext id=\"camel\" xmlns=\"http://camel',1),(3816,'org/schema/spring\">    <route>listing 6',1),(3817,'5 using the camel properties component with the java dsl    www',1),(3818,'info165introducing the camel test kit        <from uri=\"${file',1),(3819,'outbox}\"/>    </route>unfortunately the spring framework doesn’t support using placeholders directly in endpoint uris in the route, so you must define endpoints that include those placeholders by using the <endpoint> tag',1),(3820,'the following code snippet shows how this is done:<context:property-placeholder properties-ref=\"properties\"/>   <util:properties id=\"properties\"                                              location=\"classpath:rider-prod',1),(3821,'properties\"/>   <camelcontext id=\"camel\" xmlns=\"http://camel',1),(3822,'org/schema/spring\">    <endpoint id=\"inbox\" uri=\"file:${file',1),(3823,'outbox}\"/>    <route>        <from ref=\"inbox\"/>              <to ref=\"outbox\"/>    </route> </camelcontext>to use spring property placeholders, you must declare the <context:property-placeholder> tag where you refer to a properties bean b that will ...',1),(3824,'note that this xml file is based on the production environment',1),(3825,'in the camelcontext element, you define two endpoints c that use placeholders for dynamic file paths',1),(3826,'inbox} is a spring property placeholder that refers to a property with the key file',1),(3827,'the same goes for ${file',1),(3828,'outbox}, which refers to the file',1),(3829,'in the route, you must refer to these endpoints d instead of using the regular uri notations',1),(3830,'notice the use of the ref attribute in the <from> and <to> tags',1),(3831,'properties properties file contains the following two lines:file',1),(3832,'inbox=rider/files/inbox file',1),(3833,'outbox=rider/files/outboxthis example is included in the book’s source code in the chapter6/firsttest directory',1),(3834,'you can try it using the following maven goal:mvn test -dtest=springridertestloads properties from external filebdefines endpoints using property placeholderscrefers to endpoints in routedthe camel properties component versus spring property placehol...',1),(3835,'the latter only works when defining routes using spring xml, and you have to declare the endpoints in dedicated <endpoint> tags for the property placeholders to work',1),(3836,'the camel properties component is provided out of the box, which means you can use it without using spring at all',1),(3837,'and it supports the various dsl languages you can use to define routes, such as java, spring xml, groovy, and scala',1),(3838,'on top of that, you can declare the placeholders anywhere in the route definitions',1),(3839,'info166 chapter 6 testing with camelyou have now seen the camel test kit and learned to use its junit extension to write your first unit tests',1),(3840,'camel helps a lot when working with files, but things get more complex when you use more protocols—especially complex ones such as java message service (jms) messaging',1),(3841,'testing an application that leverages many protocols has always been challenging',1),(3842,'this is why mocks were invented',1),(3843,'by using mocks, you can simulate real components and reduce the number of variables in your tests',1),(3844,'mock components are the topic of the next section',1),(3845,'2 using the mock componentthe mock component is a cornerstone when testing with camel—it makes testing much easier',1),(3846,'in much the same way as a car designer uses a crash test dummy to simulate vehicle impact on humans, the mock component is used to simulate real components in a controlled way',1),(3847,'mock components are useful in several situations:■ when the real component doesn’t yet exist or isn’t reachable in the development and test phases',1),(3848,'for example, if you only have access to the component in preproduction and production phases',1),(3849,'■ when the real component is slow or requires much effort to set up and initialize, such as a database',1),(3850,'■ when you would have to incorporate special logic into the real component for testing purposes, which isn’t practical or possible',1),(3851,'■ when the component returns nondeterministic results, such as the current time, which would make it difficult to unit test at any given time of day',1),(3852,'■ when you need to simulate errors caused by network problems or faults from the real component',1),(3853,'without the mock component, your only option would be to test using the real component, which is usually much harder',1),(3854,'you may already have used mocking before; there are many frameworks out there that blend in well with testing frameworks like junit',1),(3855,'camel takes testing very seriously, and the mock component was included in the first release of camel',1),(3856,'the fact that it resides in camel-core jar indicates its importance—the mock component is used rigorously in unit testing camel itself',1),(3857,'in this section, we’ll look at how to use the mock component in unit tests and how to add mocking to existing unit tests',1),(3858,'then we’ll spend some time on how you can use mocks to set expectations to verify test results, as this is where the mock component excels',1),(3859,'let’s get started',1),(3860,'info167using the mock component6',1),(3861,'1 introducing the mock componentthe three basic steps of testing are illustrated in figure 6',1),(3862,'before the test is started, you set the expectations of what should happen b',1),(3863,'then you run the test c',1),(3864,'finally, you verify the outcome of the test against the expectations d',1),(3865,'the camel mock component allows you to easily implement these steps when testing camel applications',1),(3866,'on the mock endpoints, you can set expectations that are used to verify the test results when the test completes',1),(3867,'mock components can verify a rich variety of expectations, such as the following:■ that the correct number of messages are received on each endpoint■ that the messages arrive in the correct order■ that the correct payloads are received■ that the test...',1),(3868,'let’s get started and try using the mock component',1),(3869,'2 unit testing with the mock componentas we look at how to use the mock component, we’ll use the following basic route to keep things simple:from(\"jms:topic:quote\")',1),(3870,'to(\"mock:quote\");this route will consume messages from a jms topic, named quote, and route the messages to a mock endpoint with the name quote',1),(3871,'the mock endpoint is implemented in camel as the org',1),(3872,'mockendpoint class; it provides a large number of methods for setting expectations',1),(3873,'2 lists the most commonly used methods on the mock endpoint',1),(3874,'the expectedmessagecount method is exactly what you need to set the expectation that one message should arrive at the mock:quote endpoint',1),(3875,'you can do this as shown in listing 6',1),(3876,'set expectations run test verify resultbody == \'hello\'header(foo) == 123body == \'hello\'header(foo) == 123okokinput outputtestb c dfigure 6',1),(3877,'3 three steps for testing: set expectations, run the test, and verify the result',1),(3878,'info168 chapter 6 testing with camelpackage camelinaction;import org',1),(3879,'test',1),(3880,'cameltestsupport;public class firstmocktest extends cameltestsupport {    @override    protected routebuilder createroutebuilder() throws exception {        return new routebuilder() {            @override            public void configure() throws ex...',1),(3881,'to(\"mock:quote\");            }        };    }    @test    public void testquote() throws exception {        mockendpoint quote = getmockendpoint(\"mock:quote\");             quote',1),(3882,'expectedmessagecount(1);                               template',1),(3883,'sendbody(\"jms:topic:quote\", \"camel rocks\");            quote',1),(3884,'assertissatisfied();                             } }to obtain the mockendpoint, you use the getmockendpoint method from the cameltestsupport class',1),(3885,'then you set your expectations—in this case, you expect one message to arrive b',1),(3886,'you start the test by sending a message to the jms topic, and the mock endpoint verifies whether the expectations were met or not by using the assertissatisfied method c',1),(3887,'if a single expectation fails, camel throws a java',1),(3888,'assertionerror stating the failure',1),(3889,'2 commonly used methods in the mockendpoint classmethod descriptionexpectedmessagecount(int count) specifies the expected number of messages arriving at the endpointexpectedminimummessagecount (int count)specifies the expected minimum number of messa...',1),(3890,'bodies)specifies the expected message bodies and their order arriving at the endpointexpectedbodiesreceivedinanyorder (object',1),(3891,'bodies)specifies the expected message bodies arriving at the endpoint; ordering doesn’t matterassertissatisfied() validates that all expectations set on the endpoint are satisfiedlisting 6',1),(3892,'6 using mockendpoint in unit testingexpects one messagebverifies expectationsc    www',1),(3893,'info169using the mock component you can compare what happens in listing 6',1),(3894,'6 to what you saw in figure 6',1),(3895,'3: you set expectations, ran the test, and verified the results',1),(3896,'it can’t get any simpler than that',1),(3897,'note by default, the assertissatisfied method runs for 10 seconds before timing out',1),(3898,'you can change the wait time with the setresultwaittime(long timeinmillis) method if you have unit tests that run for a long time',1),(3899,'replacing jms with sedalisting 6',1),(3900,'6 uses jms, but, for now, let’s keep things simple by simulating jms using the seda component',1),(3901,'(we’ll look at testing jms with activemq in section 6',1),(3902,') note for details about the seda component, see the camel documentation: http://camel',1),(3903,'org/seda',1),(3904,'you can simulate jms by registering the seda component as the jms component, like this:@override protected camelcontext createcamelcontext() throws exception {    camelcontext context = super',1),(3905,'addcomponent(\"jms\", context',1),(3906,'getcomponent(\"seda\"));    return context; }you override the createcamelcontext method and add the seda component as the jms component',1),(3907,'by doing this, you fool camel into using the seda component when you refer to the jms component',1),(3908,'the book’s source code contains this test',1),(3909,'you can try it by running the following maven goal from the chapter6/firsttest directory:mvn test -dtest=firstmocktestyou may have noticed in listing 6',1),(3910,'5 that the expectation was coarse-grained in the sense that you just expected a message to arrive',1),(3911,'you did not specify anything about the message’s content or other characteristics, so you don’t know whether the message that arrived was the same “camel rocks” message that was sent',1),(3912,'the next section covers how to test this',1),(3913,'3 verifying that the correct message arrivedthe expectedmessagecount method can only be used to verify that a certain number of messages arrived',1),(3914,'it doesn’t dictate anything about the content of the message',1),(3915,'let’s improve the unit test in listing 6',1),(3916,'6 so that it expects the message being sent to match the message that arrives at the mock endpoint',1),(3917,'you can do this using the expectedbodiesreceived method, as follows:@test public void testquote() throws exception {    mockendpoint mock = getmockendpoint(\"mock:quote\");    www',1),(3918,'info170 chapter 6 testing with camel    mock',1),(3919,'expectedbodiesreceived(\"camel rocks\");         template',1),(3920,'sendbody(\"jms:topic:quote\", \"camel rocks\");    mock',1),(3921,'assertissatisfied(); }this is intuitive and easy to understand, but the method states bodies in plural as if there could be more bodies',1),(3922,'camel does support expectations of multiple messages, so you could send in two messages',1),(3923,'here’s a revised version of the test:@test public void testquotes() throws exception {    mockendpoint mock = getmockendpoint(\"mock:quote\");    mock',1),(3924,'expectedbodiesreceived(\"camel rocks\", \"hello camel\");      template',1),(3925,'sendbody(\"jms:topic:quote\", \"camel rocks\");    template',1),(3926,'sendbody(\"jms:topic:quote\", \"hello camel\");    mock',1),(3927,'assertissatisfied(); }camel now expects two messages to arrive in the specified order',1),(3928,'camel will fail the test if the “hello camel” message arrives before the “camel rocks” message',1),(3929,'in cases where the order doesn’t matter, you can use the expectedbodiesreceivedinanyorder method instead, like this:mock',1),(3930,'expectedbodiesreceivedinanyorder(\"camel rocks\", \"hello camel\");it could hardly be any easier than that',1),(3931,'but if you expect a much larger number of messages to arrive, the bodies you pass in as an argument will be very large',1),(3932,'the answer is to use a list containing the expected bodies as a parameter:list bodies =',1),(3933,'expectedbodiesreceived(bodies);the mock component has many other features we need to cover, so let’s continue and see how you can use expressions to set fine-grained expectations',1),(3934,'4 using expressions with mockssuppose you want to set an expectation that a message should contain the word “camel” in its content',1),(3935,'one way of doing this is shown in listing 6',1),(3936,'@test public void testiscamelmessage() throws exception {    mockendpoint mock = getmockendpoint(\"mock:quote\");    mock',1),(3937,'expectedmessagecount(2);                             template',1),(3938,'sendbody(\"jms:topic:quote\", \"hello camel\");    template',1),(3939,'sendbody(\"jms:topic:quote\", \"camel rocks\");   listing 6',1),(3940,'7 using expressions with mockendpoint to set expectationsexpects 2 messagesb    www',1),(3941,'info171using the mock component    assertmockendpointssatisfied();                              list<exchange> list = mock',1),(3942,'getreceivedexchanges();    string body1 = list',1),(3943,'class);            string body2 = list',1),(3944,'class);            asserttrue(body1',1),(3945,'contains(\"camel\"));                  asserttrue(body2',1),(3946,'contains(\"camel\"));              }first you set up your expectation that the mock:quote endpoint will receive two messages b',1),(3947,'you then send in two messages to the jms topic to start the test',1),(3948,'then you assert that the mock received the two messages by using the assertmockendpointssatisfied method c, which is a one-stop method for asserting all mocks',1),(3949,'this method is more convenient to use than having to invoke the assertissatisfied method on every mock endpoint you may have in use',1),(3950,'at this point, you can use the getreceivedexchanges method to access all the exchanges the mock:quote endpoint has received d',1),(3951,'you use this method to get hold of the two received message bodies so you can assert that they contain the word “camel”',1),(3952,'at first you may think it a bit odd to define expectations in two places—before and after the test has run',1),(3953,'is it not possible to define the expectations in one place, such as before you run the test',1),(3954,'yes, of course it is, and this is where camel expressions come into the game',1),(3955,'note the getreceivedexchanges method still has its merits',1),(3956,'it allows you to work with the exchanges directly, giving you the ability to do whatever you want with them',1),(3957,'3 lists some additional mockendpoint methods that let you use expressions to set expectations',1),(3958,'3 expression-based methods commonly used on mockendpointmethod descriptionmessage(int index) defines an expectation on the n’th message receivedallmessages() defines an expectation on all messages receivedexpectsascending(expression expression) expec...',1),(3959,'info172 chapter 6 testing with camelyou can use the message method to improve the unit test in listing 6',1),(3960,'7 and group all your expectations together, as shown here:@test public void testiscamelmessage() throws exception {    mockendpoint mock = getmockendpoint(\"mock:quote\");    mock',1),(3961,'expectedmessagecount(2);    mock',1),(3962,'message(0)',1),(3963,'contains(\"camel\");        mock',1),(3964,'message(1)',1),(3965,'contains(\"camel\");    template',1),(3966,'sendbody(\"jms:topic:quote\", \"hello camel\");    template',1),(3967,'sendbody(\"jms:topic:quote\", \"camel rocks\");    assertmockendpointssatisfied(); }notice that you can use the message(int index) method to set an expectation that the body of the message should contain the word “camel”',1),(3968,'instead of doing this for each message based on its index, you can use the allmessages() method to set the same expectation for all messages:mock',1),(3969,'allmessages()',1),(3970,'contains(\"camel\");so far you’ve only seen expectations based on the message body, but what if you want to set an expectation based on a header',1),(3971,'that’s easy—you use header(name), as follows:mock',1),(3972,'message(0)',1),(3973,'isequalto(4);you probably noticed the contains and isequalto methods we used in the preceding couple of code snippets',1),(3974,'they’re builder methods used to create predicates for expectations',1),(3975,'4 lists all the builder methods available',1),(3976,'expectsnoduplicates(expression expression) expects no duplicate messagesexpects(runable runable) defines a custom expectationtable 6',1),(3977,'4 builder methods for creating predicates to be used as expectationsmethod descriptioncontains(object value) sets an expectation that the message body contains the given valueisinstanceof(class type) sets an expectation that the message body is an in...',1),(3978,'3 expression-based methods commonly used on mockendpoint (continued)method description    www',1),(3979,'info173using the mock componentat first it may seem odd that the methods in table 6',1),(3980,'4 often use object as the parameter type—why not a specialized type such as string',1),(3981,'this is because of camel’s strong type-converter mechanism, which allows you to compare apples to oranges—camel can regard both of them as fruit and evaluate them accordingly',1),(3982,'you can compare strings with numeric values without having to worry about type mismatches, as illustrated by the following two code lines:mock',1),(3983,'message(0)',1),(3984,'isequalto(4); mock',1),(3985,'message(0)',1),(3986,'isequalto(\"4\");now suppose you want to create an expectation that all messages contain the word “camel” and end with a period',1),(3987,'you could use a regular expression to set this in a single expectation:mock',1),(3988,'allmessages()',1),(3989,'$\");this will work, but camel allows you to enter multiple expectations, so instead of using the regex method, you can create a more readable solution:mock',1),(3990,'allmessages()',1),(3991,'contains(\"camel\"); mock',1),(3992,'allmessages()',1),(3993,'endswith(\"',1),(3994,'\");endswith(object value) sets an expectation that the message body ends with the given valuein(object',1),(3995,'values) sets an expectation that the message body is equal to any of the given valuesisequalto(object value) sets an expectation that the message body is equal to the given valueisnotequalto(object value) sets an expectation that the message body isn...',1),(3996,'4 builder methods for creating predicates to be used as expectations (continued)method description    www',1),(3997,'info174 chapter 6 testing with camelyou have learned a lot about how to set expectations, including fine-grained ones using the builder methods listed in table 6',1),(3998,'now it’s time to move on and test the ordering of the messages received',1),(3999,'5 testing the ordering of messagessuppose you need to test that messages arrive in sequence-number order',1),(4000,'for example, messages arriving in the order 1, 2, 3 are accepted, whereas the order 1, 3, 2 is invalid and the test should fail',1),(4001,'the mock component provides features to test ascending and descending orders',1),(4002,'for example, you can use the expectsascending method like this:mock',1),(4003,'expectsascending(header(\"counter\"));the preceding expectation will test that the received messages are in ascending order, judged by the counter value in the message header, but it doesn’t dictate what the starting value must be',1),(4004,'if the first message that arrives has a value of 5, the expectation tests whether or not the next message has a value greater than 5, and so on',1),(4005,'what if you must test that the first message has a value of 1',1),(4006,'in that case, you can add another expectation that tests the first message, using message(0), as follows:mock',1),(4007,'message(0)',1),(4008,'isequalto(1); mock',1),(4009,'expectsascending(header(\"counter\"));together these expectations test that messages arrive in the order 1, 2, 3,',1),(4010,', but orders such as 1, 2, 4, 5, 6, 8, 10,',1),(4011,'also pass the test',1),(4012,'that’s because the expectsascending and expectsdescending methods don’t detect whether there are gaps between messages',1),(4013,'these methods use generic comparison functions that work on any types, not only numbers',1),(4014,'to detect gaps in the sequence, you need to use a custom expression that implements gap-detection logic',1),(4015,'using a custom expressionwhen the provided expressions and predicates don’t cut it, you can use a custom expression',1),(4016,'by using a custom expression, you have the full power of java code at your fingertips to implement your assertions',1),(4017,'let’s look at the problem of gap detection',1),(4018,'camel doesn’t provide any expressions for that, so you must do it with a custom expression',1),(4019,'listing 6',1),(4020,'8 shows how this can be done',1),(4021,'@test public void testgap() throws exception {    final mockendpoint mock = getmockendpoint(\"mock:quote\");    mock',1),(4022,'expectedmessagecount(3);    mock',1),(4023,'expects(new runnable() {                       public void run() {            int last = 0;listing 6',1),(4024,'8 using a custom expression to detect gaps in message orderingcustom expression to detect gapsb    www',1),(4025,'info175using the mock component            for (exchange exchange : mock',1),(4026,'getexchanges()) {                   int current = exchange',1),(4027,'class);                   if (current <= last) {                    fail(\"counter is not greater than last counter\");                 } else if (current - last',1),(4028,'= 1) {                    fail(\"gap detected: last: \" + last                        + \" current: \" + current);                  }                last = current;            }        }    });    template',1),(4029,'sendbodyandheader(\"jms:topic:quote\", \"a\", \"counter\", 1);    template',1),(4030,'sendbodyandheader(\"jms:topic:quote\", \"b\", \"counter\", 2);    template',1),(4031,'sendbodyandheader(\"jms:topic:quote\", \"c\", \"counter\", 4);    mock',1),(4032,'assertisnotsatisfied(); }to set up a custom expression, you use the expects method, which allows you to provide your own logic as a runnable b',1),(4033,'in the runnable, you can loop through the exchanges received and extract the current counter header',1),(4034,'then you can verify whether all the counters are incremented by one and don’t have any gaps',1),(4035,'you can use the junit fail method to fail when a gap is detected',1),(4036,'to test whether this works, you send in three messages, each of which contains a counter',1),(4037,'notice that there is a gap in the sequence: 1, 2, 4',1),(4038,'you expect this unit test to fail, so you instruct the mock to not be satisfied using the assertisnotsatisfied method',1),(4039,'next, you test a positive situation where no gaps exist',1),(4040,'to do so, you use the assertissatisfied method and send in three messages in sequence, as follows:template',1),(4041,'sendbodyandheader(\"seda:topic:quote\", \"a\", \"counter\", 1); template',1),(4042,'sendbodyandheader(\"seda:topic:quote\", \"b\", \"counter\", 2); template',1),(4043,'sendbodyandheader(\"seda:topic:quote\", \"c\", \"counter\", 3);mock',1),(4044,'assertissatisfied();that’s all there is to developing and using a custom expression',1),(4045,'now let’s get back to the mock components and learn about using mocks to simulate real components',1),(4046,'this is useful when the real component isn’t available or isn’t reachable from a local or test environment',1),(4047,'6 using mocks to simulate real componentssuppose you have a route like the following one, in which you expose an http service using jetty so clients can obtain an order status: from(\"jetty:http://web',1),(4048,'com/service/order\")',1),(4049,'process(new orderqueryprocessor())',1),(4050,'process(new orderresponseprocessor());    www',1),(4051,'info176 chapter 6 testing with camelclients send an http get, with the order id as a query parameter, to the http:// web',1),(4052,'com/service/order url',1),(4053,'camel will use the orderqueryprocessor to transform the message into a format that rider auto parts’ mainframe (named miranda) understands',1),(4054,'the message is then sent to miranda using tcp, and camel waits for the reply to come back',1),(4055,'the reply message is then processed using the orderresponseprocessor before it’s returned to the http client',1),(4056,'now suppose you have been asked to write a unit test to verify that clients can obtain the order status',1),(4057,'the challenge is that you don’t have access to miranda, which contains the actual order status',1),(4058,'you have been asked to simulate this server by replying with a canned response',1),(4059,'camel provides the two methods listed in table 6',1),(4060,'5 to help simulate a real component',1),(4061,'you can simulate a real endpoint by mocking it with the mock component and controlling the reply using the methods in table 6',1),(4062,'to do this, you need to replace the actual endpoint in the route with the mocked endpoint, which is done by replacing it with mock:miranda',1),(4063,'because you want to run the unit test locally, you also need to change the http hostname to localhost, allowing you to run the test locally on your own laptop',1),(4064,'from(\"jetty:http://localhost:9080/service/order\")',1),(4065,'process(new orderqueryprocessor())',1),(4066,'process(new orderresponseprocessor());the unit test that leverages the preceding route follows',1),(4067,'public class mirandatest extends cameltestsupport {    private string url = \"http://localhost:9080/service/order',1),(4068,'id=123\";    @override    protected routebuilder createroutebuilder() throws exception {        return new routebuilder() {            @override            public void configure() throws exception {                                  from(\"jetty:http://...',1),(4069,'process(new orderqueryprocessor())',1),(4070,'process(new orderresponseprocessor());table 6',1),(4071,'5 methods to control responses when simulating a real componentmethod descriptionwhenanyexchangereceived (processor processor)uses a custom processor to set a canned replywhenexchangereceived (int index, processor processor)uses a custom processor to...',1),(4072,'9 simulating a real component by using a mock endpoint    www',1),(4073,'info177using the mock component            }        };    }    @test    public void testmiranda() throws exception {        mockendpoint mock = getmockendpoint(\"mock:miranda\");        mock',1),(4074,'expectedbodiesreceived(\"id=123\");        mock',1),(4075,'whenanyexchangereceived(new processor() {                  public void process(exchange exchange) throws exception {                exchange',1),(4076,'requestbody(url, null, string',1),(4077,'class);          assertequals(\"in progress\", out);             assertmockendpointssatisfied();      }    private class orderqueryprocessor                      implements processor {                      public void process(exchange exchange) throws ...',1),(4078,'class);            exchange',1),(4079,'setbody(\"id=\" + id);        }    }    private class orderresponseprocessor                      implements processor {                         public void process(exchange exchange) throws exception {            string body = exchange',1),(4080,'class);            string reply = objecthelper',1),(4081,'setbody(reply);        }    } }in the testmiranda method, you obtain the mock:miranda endpoint, which is the mock that simulates the miranda server, and you set an expectation that the input message contains the body \"id=123\"',1),(4082,'to return a canned reply, you use the whenanyexchangereceived method b, which allows you to use a custom processor to set the canned response',1),(4083,'this response is set to be \"id=123,status=in progress\"',1),(4084,'then you start the unit test by sending a message to the http://localhost:9080/service/order',1),(4085,'id=123 endpoint; the message is an http get using the requestbody method from the template instance',1),(4086,'you then assert that the reply is \"in progress\" using the regular junit assertequals method c',1),(4087,'you use two processors (d and e) to transform the data to and from the format that the miranda server understands',1),(4088,'you can find the code for this example in the chapter6/miranda folder of the book’s source code, which you can try using the following maven goal:mvn test -dtest=mirandatestyou’ve now learned all about the camel test kit and how to use it for unit te...',1),(4089,'we looked at using the mock component to easily write tests with expectations,returns canned responsebverifies expected replyctransforms to format understood by mirandadtransforms to response formate    www',1),(4090,'info178 chapter 6 testing with camelrun tests, and have camel verify whether the expectations were satisfied',1),(4091,'you also saw how to use the mock component to simulate a real component',1),(4092,'you may wonder whether there is a more cunning way to simulate a real component than by using a mock, and there is',1),(4093,'we’re going to look at how to simulate errors next, but the techniques involved could also be applied to simulating a real component',1),(4094,'3 simulating errorsin the previous chapter, you learned how to use error handling to act upon errors',1),(4095,'now the question is how to test that your code works when errors happen',1),(4096,'you could test for errors by unplugging network cables and swinging an axe at the servers, but that’s a bit extreme',1),(4097,'instead we’ll look at how to simulate errors in unit tests using the three different techniques listed in table 6',1),(4098,'the following three sections cover these three techniques',1),(4099,'1 simulating errors using a processorerrors are simulated in camel by throwing exceptions, which is exactly how errors occur in real life',1),(4100,'for example, java will throw an exception if it can’t connect to a remote server',1),(4101,'throwing such an exception is easy—you can do that from any java code, such as from a processor',1),(4102,'that’s the topic of this section',1),(4103,'to illustrate this, we’ll take the use case from the previous chapter—you’re uploading reports to a remote server using http, and you’re using ftp as a fallback method',1),(4104,'this allows you to simulate errors with http connectivity',1),(4105,'the route from listing 5',1),(4106,'8 is repeated here',1),(4107,'maximumredeliveries(5)',1),(4108,'class)',1),(4109,'maximumredeliveries(3)table 6',1),(4110,'6 three techniques for simulating errorstechnique summaryprocessor using processors is easy, and they give you full control, as a developer',1),(4111,'this technique is covered in section 6',1),(4112,'mock using mocks is a good overall solution',1),(4113,'mocks are fairly easy to apply, and they provide a wealth of other features for testing, as you saw in section 6',1),(4114,'this technique is covered in section 6',1),(4115,'interceptor this is the most sophisticated technique because it allows you to use an existing route without modifying it',1),(4116,'interceptors aren’t tied solely to testing; they can be used anywhere and anytime',1),(4117,'we’ll cover interceptors in section 6',1),(4118,'listing 6',1),(4119,'10 route using error handling with a failover to ftp     www',1),(4120,'password=secret\");from(\"file:/rider/files/upload',1),(4121,'user=gear&password=secret\");what you want to do now is simulate an error when sending a file to the http service, and you’ll expect that it will be handled by onexception and uploaded using ftp instead',1),(4122,'this will ensure that the route is working correctly',1),(4123,'because you want to concentrate the unit test on the error-handling aspect and not on the actual components used, you can just mock the http and ftp endpoints',1),(4124,'this frees you from the burden of setting up http and ftp servers, and leaves you with a simpler route for testing:errorhandler(defaulterrorhandler()',1),(4125,'maximumredeliveries(5)',1),(4126,'class)',1),(4127,'maximumredeliveries(3)',1),(4128,'to(\"mock:http\");this route also reduces the redelivery delay from 10 seconds to 1 second, to speed up unit testing',1),(4129,'notice that the file endpoint is stubbed with a direct endpoint that allows you to start the test by sending a message to the direct endpoint; this is much easier than writing an actual file',1),(4130,'to simulate a communication error when trying to send the file to the http endpoint, you add a processor to the route that forces an error by throwing a connectexception exception:from(\"direct:file\")',1),(4131,'process(new processor()) {        public void process(exchange exchange) throws exception {            throw new connectexception(\"simulated connection error\");        }    })',1),(4132,'to(\"mock:http\");you then write a test method to simulate this connection error, as follows:@test public void testsimulateconnectionerror() throws exception {    getmockendpoint(\"mock:http\")',1),(4133,'expectedmessagecount(0);    mockendpoint ftp = getmockendpoint(\"mock:ftp\");    ftp',1),(4134,'expectedbodiesreceived(\"camel rocks\");    template',1),(4135,'sendbody(\"direct:file\", \"camel rocks\");    assertmockendpointsissatisfied(); }you expect no messages to arrive at the http endpoint because you predicted the error would be handled and the message would be routed to the ftp endpoint instead',1),(4136,'info180 chapter 6 testing with camel the book’s source code contains this example',1),(4137,'you can try it by running the following maven goal from the chapter6/error directory: mvn test -dtest=simulateerrorusingprocessortestusing the processor is easy, but you have to alter the route to insert the processor',1),(4138,'when testing your routes, you might prefer to test them as is without changes that could introduce unnecessary risks',1),(4139,'what if you could test the route without changing it at all',1),(4140,'the next two techniques do this',1),(4141,'2 simulating errors using mocksyou saw in section 6',1),(4142,'6 that the mock component could be used to simulate a real component',1),(4143,'but instead of simulating a real component, you can use what you learned there to simulate errors',1),(4144,'if you use mocks, we don’t need to alter the route; you write the code to simulate the error directly into the test method, instead of mixing it in with the route',1),(4145,'listing 6',1),(4146,'11 shows this',1),(4147,'@test public void testsimulateconnectionerrorusingmock() throws exception {    getmockendpoint(\"mock:ftp\")',1),(4148,'expectedmessagecount(1);    mockendpoint http = getmockendpoint(\"mock:http\");       http',1),(4149,'whenanyexchangereceived(new processor() {            public void process(exchange exchange) throws exception {            throw new connectexception(\"simulated connection error\");           }    });    template',1),(4150,'sendbody(\"direct:file\", \"camel rocks\");    assertmockendpointssatisfied(); }to simulate the connection error, you need to get hold of the http mock endpoint, where you use the whenanyexchangereceived method to set a custom processor',1),(4151,'that processor can simulate the error by throwing the connection exception',1),(4152,'by using mocks, you put the code that simulates the error into the unit test method, instead of in the route, as is required by the processor technique',1),(4153,'now let’s look at the last technique for simulating errors',1),(4154,'3 simulating errors using interceptorssuppose your boss wants you to write integration tests for listing 6',1),(4155,'10 that should, among other things, test what happens when communication with the remote http server fails',1),(4156,'this is tricky because you don’t have control over the remote http server, and you can’t easily force communication errors in the network layer',1),(4157,'luckily, camel provides features to address this problem',1),(4158,'we’ll get to that in a moment, but first we need to look at interceptors, which provide the means to simulate errors',1),(4159,'listing 6',1),(4160,'info181simulating errorsin a nutshell, an interceptor allows you to intercept any given message and act upon it',1),(4161,'4 illustrates where the interception takes place in a route',1),(4162,'4 shows a low-level view of a camel route, where you route messages from a file consumer to an http producer',1),(4163,'in between sits the channel, which acts as a controller, and this is where the interceptors (among others) live',1),(4164,'the three types of interceptors that camel provides out of the box are listed in table 6',1),(4165,'to write integration tests, you can use interceptsendtoendpoint to intercept messages sent to the remote http server and redirect them to a processor that simulates the error, as shown here:interceptsendtoendpoint(\"http://rider',1),(4166,'process(new simulatehttperrorprocessor());when a message is about to be sent to the http endpoint, it’s intercepted by camel and the message is routed to your custom processor, where you simulate an error',1),(4167,'when this detour is complete, the message would normally be sent to the originally intended endpoint, but you instruct camel to skip this step using the skipsendtooriginalendpoint method',1),(4168,'7 the three flavors of interceptors provided out of the box in camelinterceptor descriptionintercept intercepts every single step a message takes',1),(4169,'this interceptor is invoked continuously as the message is routed',1),(4170,'interceptfromendpoint intercepts incoming messages arriving on a particular endpoint',1),(4171,'this interceptor is only invoked once',1),(4172,'interceptsendtoendpoint intercepts messages that are about to be sent to a particular endpoint',1),(4173,'this interceptor is only invoked once',1),(4174,'channel to(http)from(file)interceptorchannels play a key rolethis may look familiar—we looked at channels in figure 5',1),(4175,'it’s the same channel that sits between every node in the route path and acts as a controller',1),(4176,'channels play a key role in the camel routing engine, handling such things as routing the message to the next designated target, error handling, interception, tracing messages and gathering metrics',1),(4177,'4 the channel acts as a controller, and it’s where messages are intercepted during routing',1),(4178,'info182 chapter 6 testing with cameltip the last two interceptors in table 6',1),(4179,'7 support using wildcards (*) and regular expressions in the endpoint url',1),(4180,'you can use these techniques to intercept multiple endpoints or to be lazy and just match all http endpoints',1),(4181,'we’ll look at this in a moment',1),(4182,'because you’re doing an integration test, you want to keep the original route untouched, which means you can’t add interceptors or mocks directly in the route',1),(4183,'because you still want to use interceptors in the route, you need another way to somehow add the interceptors',1),(4184,'camel provides the advicewith method to address this',1),(4185,'using advicewith to add interceptors to an existing routethe advicewith method is available during unit testing, and it allows you to add such things as interceptors and error handling to an existing route',1),(4186,'to see how this works, let’s look at an example',1),(4187,'the following code snippet shows how you can use advicewith in a unit test method:@test public void testsimulateerrorusinginterceptors() throws exception {    routedefinition route = context',1),(4188,'getroutedefinitions()',1),(4189,'advicewith(context, new routebuilder() {              public void configure() throws exception {            interceptsendtoendpoint(\"http://*\")',1),(4190,'process(new simulatehttperrorprocessor());        }    });the key issue when using advicewith is to know which route to use',1),(4191,'because you only have one route in this case, you can refer to the first route enlisted in the route definitions list',1),(4192,'the route definitions list contains the definitions of all routes registered in the current camelcontext',1),(4193,'when you’ve got the route, it’s just a matter of using the advicewith method b, which leverages a routebuilder—this means that in the configure method you can use the java dsl to define the interceptors',1),(4194,'notice that the interceptor uses a wildcard to match all http endpoints',1),(4195,'tip if you have multiple routes, you’ll need to select the correct route to be used',1),(4196,'to help select the route, you can assign unique ids to the routes, which you then can use to look up the route, such as context',1),(4197,'we’ve included this integration test in the book’s source code in the chapter6/error directory',1),(4198,'you can try it using the following maven goal:mvn test -dtest=simulateerrorusinginterceptortesttip interceptors aren’t only for simulating errors—they’re a general purpose feature that can also be used for other types of testing',1),(4199,'for example, when you’re testing production routes, you can use interceptors to detour messages to mock endpoints',1),(4200,'uses advicewith to add interceptor to routeb    www',1),(4201,'info183testing without mocksthe last section of this chapter covers how to do integration testing without mocks',1),(4202,'4 testing without mocksso far in this chapter, you’ve learned that mocks play a central role when testing camel applications',1),(4203,'for example, integration testing often involves real live components, and substituting mocks isn’t an option, as the point of the integration test is to test with live components',1),(4204,'in this section, we’ll look at how to test such situations without using mocks',1),(4205,'rider auto parts has a client application that business partners can use to submit orders',1),(4206,'the client dispatches orders over jms to an incoming order queue at the rider auto parts message broker',1),(4207,'a camel application is then used to further process these incoming orders',1),(4208,'5 illustrates this',1),(4209,'the client application is written in java, but it doesn’t use camel at all',1),(4210,'the challenge you’re facing is how to test that the client and the camel application work as expected',1),(4211,'how can you do integration testing',1),(4212,'1 integration testingintegration testing the scenario outlined in figure 6',1),(4213,'5 requires you to use live components, which means you must start the test by using the client to send a message to the order queue',1),(4214,'then you let the camel application process the message',1),(4215,'when this is complete, you’ll have to inspect whether the message ended up in the right queue— the confirm or the invalid queue',1),(4216,'you have to perform these three tasks:1 use the client to send an order message2 wait for the camel application to process the message3 inspect the confirm and invalid queues to see if the message arrived as expectedso let’s tackle each step',1),(4217,'jms orderqueuevalidateorderjms invalidqueuejms confirmqueueprocessordercamelclientfigure 6',1),(4218,'5 the client sends orders to an order queue, which is routed by a camel application',1),(4219,'the order is either accepted and routed to a confirm queue, or it’s not accepted and is routed to an invalid queue',1),(4220,'info184 chapter 6 testing with cameluse the client to send an order messagethe client is easy to use',1),(4221,'all you’re required to do is provide an ip address to the remote rider auto parts message broker, and then use its sendorder method to send the order',1),(4222,'the following code has been simplified in terms of the information required for order details:orderclient client = new orderclient(\"localhost:61616\"); client',1),(4223,'sendorder(123, date, \"4444\", \"5555\");wait for the camel application to process the messagethe client has sent an order to the order queue on the message broker',1),(4224,'the camel application will now react and process the message according to the route outlined in figure 6',1),(4225,'the problem you’re facing now is that the client doesn’t provide any api you can use to wait until the process is complete',1),(4226,'what you need is an api that provides insight into the camel application',1),(4227,'all you need to know is when the message has been processed, and optionally whether it completed successfully or failed',1),(4228,'camel provides the notifybuilder, which provides such insight',1),(4229,'we’ll cover the notifybuilder in more detail in section 6',1),(4230,'2, but the following code shows how to have notifybuilder notify you when camel is finished processing the message:notifybuilder notify = new notifybuilder(context)',1),(4231,'create();orderclient client = new orderclient(\"tcp://localhost:61616\"); client',1),(4232,'sendorder(123, date, \"4444\", \"5555\");boolean matches = notify',1),(4233,'matches(5, timeunit',1),(4234,'seconds); asserttrue(matches);first, you configure notifybuilder to notify you when one message is done',1),(4235,'then you use the client to send the message',1),(4236,'invoking the matches method on the notify instance will cause the test to wait until the condition applies, or the 5-second timeout occurs',1),(4237,'the last task tests whether the message was processed correctly',1),(4238,'inspect the queues to see if the message arrived as expectedafter the message has been processed, you need to investigate whether the message arrived at the correct message queue',1),(4239,'if you want to test that a valid order arrived in the confirm queue, you can use the browsableendpoint to browse the messages on the jms queue',1),(4240,'by using the browsableendpoint, you only peek inside the message queue, which means the messages will still be present on the queue',1),(4241,'doing this requires a little bit of code, as shown in here:browsableendpoint be = context',1),(4242,'getendpoint(\"activemq:queue:confirm\",                                           browsableendpoint',1),(4243,'class); list<exchange> list = be',1),(4244,'getexchanges(); assertequals(1, list',1),(4245,'size());string body = list',1),(4246,'class); assertequals(\"ok,123,2010-04-20t15:47:58,4444,5555\", body);by using browsableendpoint, you can retrieve the exchanges on the jms queue using the getexchanges method',1),(4247,'you can then use the exchanges to assert that the message arrived as expected',1),(4248,'info185testing without mocks the source code for the book contains this example in the chapter6/notify directory, which you can try using the following maven goal:mvn test -dtest=ordertestwe’ve now covered an example of how to do integration testing ...',1),(4249,'along the road, we introduced the notifiybuilder, which has many more nifty features',1),(4250,'we’ll review it in the next section',1),(4251,'2 using notifybuildernotifybuilder is located in the org',1),(4252,'it uses the builder pattern, which means you stack methods on it to build an expression',1),(4253,'you use it to define conditions for messages being routed in camel',1),(4254,'then it offers methods to test whether the conditions have been meet',1),(4255,'we already used it in the previous section, but this time we’ll raise the bar and show how you can build more complex conditions',1),(4256,'in the previous example, you used a simple condition:notifybuilder notify = new notifybuilder(context)',1),(4257,'create();this condition will match when one or more messages have been processed in the entire camel application',1),(4258,'this is a very coarse-grained condition',1),(4259,'suppose you have multiple routes, and another message was processed as well',1),(4260,'that would cause the condition to match even if the message you wanted to test was still in progress',1),(4261,'to remedy this, you can pinpoint the condition so it applies only to messages originating from a specific endpoint, as shown in bold:notifybuilder notify = new notifybuilder(context)',1),(4262,'create();now you’ve told the notifier that the condition only applies for messages that originate from the order queue',1),(4263,'suppose you send multiple messages to the order queue, and you want to test whether a specific message was processed',1),(4264,'you can do this using a predicate to indicate when the desired message was completed',1),(4265,'this is done using the whenanydonematches method, as shown here in bold:notifybuilder notify = new notifybuilder(context)',1),(4266,'whenanydonematches(     body()',1),(4267,'isequalto(\"ok,123,2010-04-20\'t\'15:48:00,2222,3333\"))',1),(4268,'create();in this example we want the predicate to determine if the body is equal to the expected result which is the string starting with \"ok,123,',1),(4269,'we’ve now covered some examples using notifybuilder, but the builder has many methods that allow you to build even more complex expressions',1),(4270,'8 lists the most commonly used methods',1),(4271,'the notifybuilder has over 30 methods, and we’ve only listed the most commonly used ones in table 6',1),(4272,'consult the online camel documentation to see all the supported methods: http://camel',1),(4273,'info186 chapter 6 testing with camelnote the notifybuilder works in principle by adding an eventnotifier to the given camelcontext',1),(4274,'the eventnotifier then invokes callbacks during the routing of exchanges',1),(4275,'this allows the notifybuilder to listen for those events and react accordingly',1),(4276,'the eventnotifier is covered in section 12',1),(4277,'the notifybuilder identifies three ways a message can complete:■ done—this means the message is done, regardless of whether it completed or failed',1),(4278,'■ completed—this means the message completed with success (no failure)',1),(4279,'■ failed—this means the message failed (for example, an exception was thrown and not handled)',1),(4280,'the names of these three ways are also incorporated in the names of the builder methods: whendone, whencompleted, and whenfailed (listed in table 6',1),(4281,'tip you can create multiple instances of notifybuilder if you want to be notified of different conditions',1),(4282,'the notifybuilder also supports using binary operations (and, or, not) to stack together multiple conditions',1),(4283,'the source code for the book contains some example of using notifybuilder in the chapter6/notify directory',1),(4284,'you can run them using the following maven goal:mvn test -dtest=notifytesttable 6',1),(4285,'8 noteworthy methods on notifybuildermethod descriptionfrom(uri) specifies that the message must originate from the given endpoint',1),(4286,'you can use wildcards and regular expressions in the given uri to match multiple endpoints',1),(4287,'for example, you could use from(\"activemq:queue:*\") to match any jms queues',1),(4288,'filter(predicate) filters unwanted messages',1),(4289,'whendone(number) matches when a minimum number of messages are done',1),(4290,'whencompleted(number) matches when a minimum number of messages are completed',1),(4291,'whenfailed(number) matches when a minimum number of messages have failed',1),(4292,'whenbodiesdone(bodies',1),(4293,') matches when messages are done with the specified bodies in the given order',1),(4294,'whenanydonematches (predicate)matches when any message is done and matches the predicate',1),(4295,'create creates the notifier',1),(4296,'matches tests whether the notifier currently matches',1),(4297,'this operation returns immediately',1),(4298,'matches(timeout) waits until the notifier matches or times out',1),(4299,'returns true if it matched, or false if a timeout occurred',1),(4300,'info187summary and best practiceswe encourage you to take a look at this source code and also the online documentation',1),(4301,'that’s it for testing without mocks, and that marks the end of this chapter',1),(4302,'5 summary and best practicestesting is a challenge for every project',1),(4303,'it’s generally considered bad practice to only do testing at the end of a project, so testing often begins when development starts and continues through the remainder of the project lifecycle',1),(4304,'testing isn’t something you only do once, either',1),(4305,'testing is involved in most phases in a project',1),(4306,'you should do unit testing while you develop the application',1),(4307,'and you should also implement integration testing to ensure that the different components and systems work together',1),(4308,'you also have the challenge of ensuring you have the right environments for testing',1),(4309,'camel can’t eliminate these challenges, but it does provide a great test kit that makes writing tests with camel applications easier and less time consuming',1),(4310,'we looked at this test kit, and we also looked at how to externalize dynamic parts using property placeholders, so you can reuse and test the same test cases in different environments',1),(4311,'we also reviewed how you can simulate real components using mocks in the earlier phases of a project, allowing you to test against systems you may not currently have access to',1),(4312,'in chapter 5 you learned about error handling, and in this chapter you saw how you can use the camel test kit to test error handling by simulating errors',1),(4313,'we reviewed techniques for integration testing that don’t involve using mocks',1),(4314,'doing integration testing, using live components and systems, is often harder than unit testing, where mocks are a real advantage',1),(4315,'in integration testing, mocks aren’t available to use, and you have to use other techniques such as setting up a notification scheme that can notify you when certain messages have been processed',1),(4316,'this allows you to inspect the various systems to see whether the messages were processed as expected (such as by peeking into a jms queue or looking at a database table)',1),(4317,'here are a few best practices to take away from the chapter:■ use unit tests',1),(4318,'use the camel test kit from the beginning, and write unit tests in your projects',1),(4319,'■ use the mock component',1),(4320,'the mock component is a powerful component for unit testing',1),(4321,'use it rigorously in your unit tests',1),(4322,'■ test error handling',1),(4323,'integration is difficult, and unexpected errors can occur',1),(4324,'use the techniques you’ve learned in this chapter to simulate errors and test that your application is capable of dealing with these failures',1),(4325,'■ use integration tests',1),(4326,'build and use integration tests to test that your application works when integrated with real and live systems',1),(4327,'the next chapter will cover the use of components with camel',1),(4328,'you’ve already used components, such as the file and seda components',1),(4329,'but there is much more to components, so we’ve devoted an entire chapter to cover them in detail',1),(4330,'info188understanding  componentsso far, we’ve only touched on a handful of ways that camel can communicate with external applications, and we haven’t gone into much detail on most components',1),(4331,'it’s time to take your use of the components you’ve already seen to the next level, and to introduce new components that will enable your camel applications to communicate with the outside world',1),(4332,'this chapter covers■ an overview of camel components■ working with files and databases■ messaging with jms■ web services using apache cxf■ networking with apache mina■ in-memory messaging■ automating tasks with the quartz and timer components    www',1),(4333,'info189overview of camel components first, we’ll discuss exactly what it means to be a component in camel',1),(4334,'we’ll also see how components are added to camel',1),(4335,'then, although we can’t describe every component in camel—that would at least triple the length of this book—we’ll look at the most commonly used components',1),(4336,'1 lists the components we’ll cover in this chapter and lists the urls for their official documentation',1),(4337,'let’s start off with an overview of camel components',1),(4338,'1 overview of camel componentscomponents are the primary extension point in camel',1),(4339,'over the years since camel’s inception, the list of components has really grown',1),(4340,'as of version 2',1),(4341,'0, camel ships with more than 80 components, and there are dozens more available separately from other community sites',1),(4342,'1 these components allow you to bridge to many different apis, protocols, data formats, and so on',1),(4343,'camel saves you from having to code these integrations yourself, thus it achieves its primary goal of making integration easier',1),(4344,'what does a camel component look like',1),(4345,'well, if you think of camel routes as highways, components are roughly analogous to on and off ramps',1),(4346,'a message traveling down a route will need to take an off ramp to get to another route or external service',1),(4347,'if the message is headed for another route, it will need to take an on ramp to get onto that route',1),(4348,'1 components discussed in this chaptercomponent function component camel documentation referencefile i/o file http://camel',1),(4349,'htmlasynchronous messaging jms http://camel',1),(4350,'htmlusing web services cxf http://camel',1),(4351,'htmlworking with databases jdbc http://camel',1),(4352,'htmlin-memory messaging direct http://camel',1),(4353,'org/seda',1),(4354,'htmlautomating tasks timer http://camel',1),(4355,'html1 see appendix d for information on some of these community sites',1),(4356,'info190 chapter 7 understanding componentsfrom an api point of view, a camel component is simple, consisting of a class implementing the component interface, shown here:public interface component {      endpoint createendpoint(string uri) throws exce...',1),(4357,'to do this, a component also holds on to a reference of the camelcontext',1),(4358,'the camelcontext provides access to camel’s common facilities, like the registry, class loader, and type converters',1),(4359,'this relationship is shown in figure 7',1),(4360,'there are two main ways in which components are added to a camel runtime: by manually adding them to the camelcontext and through autodiscovery',1),(4361,'1 manually adding componentsyou’ve seen the manual addition of a component already',1),(4362,'this was done using the addcomponent method of the camelcontext interface, as follows:camelcontext context = new defaultcamelcontext(); context',1),(4363,'addcomponent(\"jms\",    jmscomponent',1),(4364,'jmscomponentautoacknowledge(connectionfactory));in this example, you add a component created by the jmscomponent',1),(4365,'jmscomponentautoacknowledge method and assign it a name of “jms”',1),(4366,'this component can be selected in a uri by using the “jms” scheme',1),(4367,'2 autodiscovering componentsthe other way components can be added to camel is through autodiscovery',1),(4368,'the autodiscovery process is illustrated in figure 7',1),(4369,'autodiscovery is the way the components that ship with camel are registered',1),(4370,'in order to discover new components, camel looks in the meta-inf/services/org/ apache/camel/component directory on the classpath for files',1),(4371,'files in this directory determine what the name of a component is and what the fully qualified class name is',1),(4372,'as an example, let’s look at the bean component',1),(4373,'it has a file named “bean” in the meta-inf/services/org/apache/camel/component directory that contains a single line:class=org',1),(4374,'beancomponent component endpointcamelcontext createsusesusesfigure 7',1),(4375,'1 a component creates endpoints and may use the camelcontext’s facilities to accomplish this',1),(4376,'info191overview of camel componentsthis class property tells camel to load up the org',1),(4377,'beancomponent class as a new component, and the filename gives the component the name of “bean”',1),(4378,'tip we’ll discuss how to create your own camel component in section 11',1),(4379,'most of the components in camel are in separate java modules from the camelcore module, because they usually depend on third-party dependencies that would bloat the core',1),(4380,'for example, the atom component depends on apache abdera to communicate over atom',1),(4381,'we wouldn’t want to make every camel application depend on abdera, so the atom component is included in a separate camel-atom module',1),(4382,'the camel-core module has 13 useful components built in, though',1),(4383,'these are listed in table 7',1),(4384,'2 components in the camel-core modulecomponent description camel documentation referencebean invokes a java bean in the registry',1),(4385,'you saw this used extensively in chapter 4',1),(4386,'htmlbrowse allows you to browse the list of exchanges that passed through a browse endpoint',1),(4387,'this can be useful for testing, visualization tools, or debugging',1),(4388,'org/browse',1),(4389,'htmldataset allows you to create large numbers of messages for soak or load testing',1),(4390,'org/dataset',1),(4391,'htmldirect allows you to synchronously call another endpoint with little overhead',1),(4392,'we’ll look at this component in section 7',1),(4393,'htmlfile reads or writes to files',1),(4394,'we’ll discuss this component in section 7',1),(4395,'htmllanguage executes a script against the incoming exchange using one of the languages supported by camel',1),(4396,'htmllog logs messages to a number of different logging providers',1),(4397,'htmlcamelcontextcomponentresolverget “bean”componentclass org',1),(4398,'beancomponentmeta-inf/services/org/apache/camel/component/beanreturnbeancomponentcreate newbeancomponentsearch classpathfor “bean” file12 return “class”property 345figure 7',1),(4399,'2 to autodiscover a component named “bean”, the component resolver searches for a file named “bean” in a specific directory on the classpath',1),(4400,'this file specifies that the component class that will be created is beancomponent',1),(4401,'info192 chapter 7 understanding componentsnow let’s look at each component in detail',1),(4402,'we’ll start by looking at the file component',1),(4403,'2 working with files (file and ftp components)it seems that in integration projects, you always end up needing to interface with a filesystem somewhere',1),(4404,'you may find this strange, as new systems often provide nice web services and other remoting apis to serve as integration points',1),(4405,'the problem is that in integration, we often have to deal with older legacy systems, and file-based integrations are common',1),(4406,'for example, you might need to read a file that was written by another application—it could be sending a command, an order to be processed, data to be logged, or anything else',1),(4407,'this kind of information exchange, illustrated in figure 7',1),(4408,'3, is called a file transfer in eip terms',1),(4409,'another reason why file-based integrations are so common is that they’re easy to understand',1),(4410,'even novice computer users know something about filesystems',1),(4411,'even though they’re easy to understand, file-based integrations are difficult to get right',1),(4412,'developers commonly have to battle with complex io apis, platform-specific filesystem issues, concurrent access, and the like',1),(4413,'mock tests that messages flow through a route as expected',1),(4414,'you saw the mock component in action in chapter 6',1),(4415,'htmlproperties allows you to use property placeholders in endpoint uris',1),(4416,'we talked about this in chapter 6',1),(4417,'htmlref looks up endpoints in the registry',1),(4418,'htmlseda allows you to asynchronously call another endpoint in the same camelcontext',1),(4419,'we’ll look at this component in section 7',1),(4420,'org/seda',1),(4421,'htmltimer sends out messages at regular intervals',1),(4422,'you’ll learn more about the timer component and a more powerful scheduling endpoint based on quartz in section 7',1),(4423,'8 of this chapter',1),(4424,'htmlvm allows you to asynchronously call another endpoint in the same jvm',1),(4425,'we’ll discuss this component in section 7',1),(4426,'2 components in the camel-core module (continued)component description camel documentation referenceapplication bapplicationadatashared produce consume figure 7',1),(4427,'3 a file transfer between two applications is a common way to integrate with legacy systems',1),(4428,'info193working with files (file and ftp components)camel has extensive support for interacting with filesystems',1),(4429,'in this section, we’ll look at how to use the file component to read files from and write them to the local filesystem',1),(4430,'we’ll also cover some advanced options for file processing and discuss how to access remote files with the ftp component',1),(4431,'1 reading and writing files with the file componentas you saw before, the file component is configured through uri options',1),(4432,'some common options are shown in table 7',1),(4433,'3; for a complete listing, see the online documentation (http://camel',1),(4434,'let’s first see how camel can be used to read files',1),(4435,'reading filesas you’ve seen in previous chapters, reading files with camel is pretty straightforward',1),(4436,'here’s a simple example:public void configure() {    from(\"file:data/inbox',1),(4437,'to(\"stream:out\"); }table 7',1),(4438,'3 common uri options used to configure the file componentoption default value descriptiondelay 500 specifies the number of milliseconds between polls of the directory',1),(4439,'recursive false specifies whether or not to recursively process files in all subdirectories of this directory',1),(4440,'noop false specifies file-moving behavior',1),(4441,'by default, camel will move files to the',1),(4442,'camel directory after processing them',1),(4443,'to stop this behavior and keep the original files in place, set the noop option to true',1),(4444,'filename null uses an expression to set the filename used',1),(4445,'for consumers, this acts as a filename filter; in producers, it’s used to set the name of the file being written',1),(4446,'fileexist override specifies what a file producer will do if the same filename already exists',1),(4447,'valid options are override, append, fail, and ignore',1),(4448,'override will cause the file to be replaced',1),(4449,'append adds content to the file',1),(4450,'fail causes an exception to be thrown',1),(4451,'if ignore is set, an exception won’t be thrown and the file won’t be written',1),(4452,'delete false specifies whether camel will delete the file after processing',1),(4453,'camel specifies the directory to which camel moves files after it’s done processing them',1),(4454,'include null specifies a regular expression',1),(4455,'camel will process only those files that match this expression',1),(4456,'exclude null specifies a regular expression',1),(4457,'camel will exclude files based on this expression',1),(4458,'info194 chapter 7 understanding componentsthis route will read files from the data/inbox directory and print the contents of each to the console',1),(4459,'the printing is done by sending the message to the system',1),(4460,'out stream, accessible by using the stream component',1),(4461,'as stated in table 7',1),(4462,'3, the noop flag tells camel to leave the original files as is',1),(4463,'this is a convenience option for testing, because it means that you can run the route many times without having to repopulate a directory of test files',1),(4464,'to run this yourself, change to the chapter7/file directory in the book’s source code, and run this command:mvn compile exec:java -dexec',1),(4465,'mainclass=camelinaction',1),(4466,'to(\"stream:out\"); }this would use camel’s default behavior, which is to move the consumed files to a special',1),(4467,'camel directory (though the directory can be changed with the move option); the files are moved after the routing has completed',1),(4468,'this behavior was designed so that files would not be processed over and over, but it also keeps the original files around in case something goes wrong',1),(4469,'if you don’t mind losing the original files, you can use the delete option listed in table 7',1),(4470,'by default, camel will also lock any files that are being processed',1),(4471,'the locks are released after routing is complete',1),(4472,'both of the two preceding routes will consume any file not beginning with a period, so they will ignore files like',1),(4473,'m2, and so on',1),(4474,'you can customize which files are included by using the include and exclude options',1),(4475,'writing filesyou just saw how to read files created by other applications or users',1),(4476,'now let’s see how camel can be used to write files',1),(4477,'here’s a simple example:public void configure() {   from(\"stream:in',1),(4478,'promptmessage=enter something:\")',1),(4479,'to(\"file:data/outbox\"); }this example uses the stream component to accept input from the console',1),(4480,'the stream:in uri will instruct camel to read any input from system',1),(4481,'in on the console and create a message from that',1),(4482,'the promptmessage option displays a prompt, so you know when to enter text',1),(4483,'the file:data/outbox uri instructs camel to write out the message body to the data/outbox directory',1),(4484,'to see what happens firsthand, you can try the example by changing to the chapter7/file directory in the book’s source code and executing the following command:mvn compile exec:java -dexec',1),(4485,'mainclass=camelinaction',1),(4486,'info195working with files (file and ftp components)when this runs, you’ll see an “enter something:” prompt',1),(4487,'enter some text into the console, and press enter, like this:info: apache camel 2',1),(4488,'0 (camelcontext: camel-1) started enter something:hellothis text (in this case, “hello”) will be read in by the stream component and added as the body of a new message',1),(4489,'this message’s body (the text you entered) will then be written out to a file in the data/outbox directory (which will be created if it doesn’t exist)',1),(4490,'if you run a directory listing on the data/outbox directory now, you’ll see a single file that has a rather strange name:f6a3a5ee-536b-43c3-8307-1b96e1ae7778because you did not specify a filename to use, camel chose a unique filename based on the mes...',1),(4491,'to set the filename that should be used, you can add a filename option to your uri',1),(4492,'for example, you could change the route so it looks like this:public void configure() {    from(\"stream:in',1),(4493,'promptmessage=enter something:\")',1),(4494,'txt\"); }now, any text entered into the console will be saved into the prompt',1),(4495,'txt, so you now have a problem with this route',1),(4496,'if text is frequently entered into the console, you may want new files created each time, so they don’t overwrite the old ones',1),(4497,'to implement this in camel, you can use an expression for the filename',1),(4498,'you can use the simple expression language to put the current time and date information into your filename:public void configure() {    from(\"stream:in',1),(4499,'promptmessage=enter something:\")',1),(4500,'filename=${date:now:yyyymmdd-hh:mm:ss}',1),(4501,'txt\"); }the date:now expression returns the current date, and you can also use any formatting options permitted by java',1),(4502,'now if you enter text into the console at 2:00 p',1),(4503,'on january 31, 2010, the file in the data/outbox directory will be named something like this:20100131-02:00:53',1),(4504,'txtthe simple techniques for reading from and writing to files discussed here will be adequate for most of the cases you’ll encounter in the real world',1),(4505,'for the trickier cases, there are a plethora of configuration possibilities listed in the online documentation',1),(4506,'we’ve started slowly with the file component, to get you comfortable with using components in camel',1),(4507,'next we’ll look at the ftp component, which builds on the file component but introduces messaging across a network',1),(4508,'info196 chapter 7 understanding components7',1),(4509,'2 accessing remote files with the ftp componentprobably the most common way to access remote files is by using ftp, and camel supports three flavors of ftp: ■ plain ftp mode transfer■ sftp for secure transfer■ ftps (ftp secure) for transfer with the ...',1),(4510,'for a complete listing of options for the ftp component, see the online documentation (http://camel',1),(4511,'because the ftp component isn’t part of the camel-core module, you need to add an additional dependency to your project',1),(4512,'if you use maven, you just have to add the following dependency to your pom:<dependency>  <groupid>org',1),(4513,'camel</groupid>  <artifactid>camel-ftp</artifactid>  <version>2',1),(4514,'0</version> </dependency>table 7',1),(4515,'4 common uri options used to configure the ftp componentoptiondefault valuedescriptionusername null provides a username to the remote host for authentication',1),(4516,'if no username is provided, anonymous login is attempted',1),(4517,'you can also specify the username by prefixing username@ to the hostname in the uri',1),(4518,'password null provides a password to the remote host to authenticate the user',1),(4519,'you can also specify the password by prefixing the hostname in the uri with username:password@',1),(4520,'binary false specifies the transfer mode',1),(4521,'by default, camel will transfer in ascii mode; set this option to true to enable binary transfer',1),(4522,'disconnect false specifies whether camel will disconnect from the remote host right after use',1),(4523,'the default is to remain connected',1),(4524,'maximumreconnectattempts 3 specifies the maximum number of attempts camel will make to connect to the remote host',1),(4525,'if all these attempts are unsuccessful, camel will throw an exception',1),(4526,'a value of 0 disables this feature',1),(4527,'reconnectdelay 1000 specifies the delay in milliseconds between reconnection attempts',1),(4528,'info197asynchronous messaging (jms component)to demonstrate accessing remotes files, let’s use the stream component as in the previous section to interactively generate and send files over ftp',1),(4529,'a route that accepts text on the console and then sends it over ftp would look like this:<route>  <from uri=\"stream:in',1),(4530,'promptmessage=enter something:\" />  <to uri=\"ftp://rider:secret@localhost:21000/data/outbox\"/> </route>this is a spring-based route—spring makes it easy to hook start and stop methods to an embedded ftp server',1),(4531,'this ftp endpoint uri specifies that camel should send the message to an ftp server on the localhost listening on port 21000, using rider as the username and secret as the password',1),(4532,'it also specifies that messages are to be stored in the data/outbox directory of the ftp server',1),(4533,'to run this example for yourself, change to the chapter7/ftp directory and run this command:mvn camel:runafter camel has started, you’ll need to enter something into the console:info  apache camel 2',1),(4534,'0 (camelcontext: camelcontext) started enter something:hellothe example will keep running until you press ctrl-c',1),(4535,'you can now check to see if the message made it into the ftp server',1),(4536,'the ftp server’s root directory was set up to be the current directory of the application, so you can check data/outbox for a message:cat data/outbox/8ff0787f-1eab-4d11-9a60-5c3f5a05e498 helloas you can see, using the ftp component is similar to usin...',1),(4537,'now that you know how to do the most basic of integrations with files and ftp, let’s move on to more advanced topics, like jms and web services',1),(4538,'3 asynchronous messaging (jms component)jms messaging is an incredibly useful integration technology',1),(4539,'it promotes loose coupling in application design, has built-in support for reliable messaging, and is by nature asynchronous',1),(4540,'as you saw in chapter 2, when we looked at jms, it’s also easy to use from camel',1),(4541,'in this section, we’ll expand on what we covered in chapter 2 by going over some of the more commonly used configurations of the jms component',1),(4542,'camel doesn’t ship with a jms provider; you need to configure it to use a specific jms provider by passing in a connectionfactory instance',1),(4543,'for example, to connect to an apache activemq broker listening on port 61616 of the local host, you could configure the jms component like this:<bean id=\"jms\" class=\"org',1),(4544,'jmscomponent\">  <property name=\"connectionfactory\">    <bean class=\"org',1),(4545,'info198 chapter 7 understanding components      <property name=\"brokerurl\" value=\"tcp://localhost:61616\" />    </bean>  </property> </bean>the tcp://localhost:61616 uri passed in to the connectionfactory is jms providerspecific',1),(4546,'in this example, you’re using the activemqconnectionfactory so the uri is parsed by activemq',1),(4547,'the uri tells activemq to connect to a broker using tcp on port 61616 of the local host',1),(4548,'if you wanted to connect to a broker over some other protocol, activemq supports connections over vm, ssl, udp, multicast, and so on',1),(4549,'throughout this section, we’ll be demonstrating jms concepts using activemq as the jms provider, but any provider could have been used here',1),(4550,'camel’s jms component has a daunting list of configuration options—over 60 to date',1),(4551,'many of these will only be seen in very specific jms usage scenarios',1),(4552,'the common ones are listed in table 7',1),(4553,'to use the jms component in your project, you’ll need to include the camel-jms module on your classpath as well as any jms provider jars',1),(4554,'if you’re using maven, the jms component can be added with the following dependency:<dependency>  <groupid>org',1),(4555,'camel</groupid>the activemq componentby default, a jms connectionfactory doesn’t pool connections to the broker, so it will spin up new connections for every message',1),(4556,'the way to avoid this is to use connection factories that use connection pooling',1),(4557,'for convenience to camel users, activemq ships with the activemq component, which configures connection pooling automatically for improved performance',1),(4558,'the activemq component is used as follows:  <bean id=\"activemq\"',1),(4559,'class=\"org',1),(4560,'activemqcomponent\">    <property name=\"brokerurl\" value=\"tcp://localhost:61616\" />  </bean>when using this component, you’ll also need to depend on the activemq-camel module from activemq: <dependency>  <groupid>org',1),(4561,'activemq</groupid>  <artifactid>activemq-camel</artifactid>  <version>5',1),(4562,'1</version> </dependency>this module contains the activemq component and type converters for activemq data types',1),(4563,'info199asynchronous messaging (jms component)  <artifactid>camel-jms</artifactid>  <version>2',1),(4564,'0</version> </dependency>table 7',1),(4565,'5 common uri options used to configure the jms componentoptiondefault valuedescriptionautostartup true controls whether consumers start listening right after creation',1),(4566,'if set to false, you’ll need to invoke the start()method on the consumer manually at a later time',1),(4567,'clientid null sets the jms client id, which must be unique among all connections to the jms broker',1),(4568,'the client id set in the connectionfactory overrides this one if set',1),(4569,'concurrentconsumers 1 sets the number of consumer threads to use',1),(4570,'it’s a good idea to increase this for high-volume queues, but it’s not advisable to use more than one concurrent consumer for jms topics, because this will result in multiple copies of the same message',1),(4571,'disablereplyto false specifies whether camel should ignore the jmsreplytoheader in any messages or not',1),(4572,'set this if you don’t want camel to send a reply back to the destination specified in the jmsreplyto header',1),(4573,'durablesubscriptionname null specifies the name of the durable topic subscription',1),(4574,'if clientid is also set, the topic subscription is made durable automatically',1),(4575,'maxconcurrentconsumers 1 sets the maximum number of consumer threads to use',1),(4576,'if this value is higher than concurrentconsumers, new consumers are started dynamically as load demands',1),(4577,'if load drops down, these extra consumers will be freed and the number of consumers will be equal to concurrentconsumers again',1),(4578,'increasing this value isn’t advisable when using topics',1),(4579,'replyto null sets the destination that the reply is sent to',1),(4580,'this overrides the jmsreplyto header in the message',1),(4581,'by setting this, camel will use a fixed reply queue',1),(4582,'by default, camel will use a temporary reply queue',1),(4583,'requesttimeout 20000 specifies the time in milliseconds before camel will timeout sending a message',1),(4584,'selector null sets the jms message selector expression',1),(4585,'only messages passing this predicate will be consumed',1),(4586,'timetolive null when sending messages, sets the amount of time the message should live',1),(4587,'after this time expires, the jms provider may discard the message',1),(4588,'transacted false enables transacted sending and receiving of messages in inonly mode',1),(4589,'info200 chapter 7 understanding componentsthe best way to show that camel is a great tool for jms messaging is with an example',1),(4590,'let’s look at how to send and receive messages over jms',1),(4591,'1 sending and receiving messagesin chapter 2, you saw how orders are processed at rider auto parts',1),(4592,'it started out as a step-by-step process: they were first sent to accounting to validate the customer standing and then to production for manufacture',1),(4593,'this process was improved by sending orders to accounting and production at the same time, cutting out the delay involved when production waited for the ok from accounting',1),(4594,'a multicast eip was used to implement this scenario',1),(4595,'4 illustrates another possible solution, which is to use a jms topic following a publish-subscribe model',1),(4596,'in that model, listeners such as accounting and production could subscribe to the topic, and new orders would be published to the topic',1),(4597,'in this way, both accounting and production would receive a copy of the order message',1),(4598,'to implement this in camel, you’d set up two consumers, which means there will be two routes needed:from(\"jms:topic:xmlorders\")',1),(4599,'to(\"jms:accounting\"); from(\"jms:topic:xmlorders\")',1),(4600,'to(\"jms:production\");when a message is sent (published) to the xmlorders topic, both the accounting and production queues will receive a copy',1),(4601,'as you saw in chapter 2, an incoming order could originate from another route (or set of routes), like one that receives orders via a file, as shown in listing 7',1),(4602,'from(\"file:src/data',1),(4603,'to(\"jms:incomingorders\"); from(\"jms:incomingorders\")',1),(4604,'endswith(\"',1),(4605,'to(\"jms:topic:xmlorders\")',1),(4606,'*(csv|csl)$\"))',1),(4607,'to(\"jms:topic:csvorders\");  from(\"jms:topic:xmlorders\")',1),(4608,'to(\"jms:accounting\"); from(\"jms:topic:xmlorders\")',1),(4609,'to(\"jms:production\");         to run this example, go to the chapter7/jms directory in the book’s source, and run this command:mvn clean compile camel:runlisting 7',1),(4610,'1 topics allow multiple receivers to get a copy of the message      both listening queues get copiesjms:topic:xmlordersjms:accountingjms:productionfigure 7',1),(4611,'4 orders are published to the xmlorders topic, and the two subscribers (the accounting and production queues) get a copy of the order',1),(4612,'info201asynchronous messaging (jms component)this will output the following on the command line:accounting received order: message1',1),(4613,'xml production received order: message1',1),(4614,'xmlwhy did you get this output',1),(4615,'well, you had a single order file named message1',1),(4616,'xml, and it was published to the xmlorders topic',1),(4617,'both the accounting and production queues were subscribed to the topic, so each received a copy',1),(4618,'testing routes consumed the messages on those queues and output the messages',1),(4619,'messages can also be sent “by hand” to a jms destination using a producertemplate',1),(4620,'a template class, in general, is a utility class that simplifies access to an api; in this case, the producer interface',1),(4621,'for example, to send an order to the topic using a producertemplate, you could use the following snippet:producertemplate template = camelcontext',1),(4622,'sendbody(\"jms:topic:xmlorders\", \"<',1),(4623,'\");this is a useful feature for getting direct access to any endpoint in camel',1),(4624,'for more on the producertemplate, see appendix c',1),(4625,'all of the jms examples so far have been one-way only',1),(4626,'let’s look at how you can deliver a reply to the sent message',1),(4627,'2 request-reply messagingjms messaging with camel (and in general) is asynchronous by default',1),(4628,'messages are sent to a destination, and the client doesn’t wait for a reply',1),(4629,'but there are times when it’s useful to be able to wait and get a reply after sending to a destination',1),(4630,'one obvious application is when the jms destination is a frontend to a service—in this case, a client sending to the destination would be expecting a reply from the service',1),(4631,'jms supports this type of messaging by providing a jmsreplyto header, so that the receiver knows where to send the reply, and a jmscorrelationid, used to match replies to requests if there are multiple replies awaiting',1),(4632,'this flow of messages is illustrated in figure 7',1),(4633,'camel takes care of this style of messaging, so you don’t have to create special reply queues, correlate reply messages, and the like',1),(4634,'by changing the message exchange pattern (mep) to inout, camel will enable request-reply mode for jms',1),(4635,'to demonstrate, let’s take a look at an order validation service within rider auto parts’ backend systems that checks orders against the company database to make sure the parts listed are actual products',1),(4636,'this service is exposed via a queue named validate',1),(4637,'the route exposing this service over jms could be as simple as this:from(\"jms:validate\")',1),(4638,'class);request queuerequestor replierreply queue1 234figure 7',1),(4639,'5 in request-reply messaging, a requestor sends a message to a request queue and then waits for a reply in the reply queue',1),(4640,'the replier waits for a new message in the request queue, inspects the jmsreplyto address, and then sends a reply back to that destination',1),(4641,'info202 chapter 7 understanding componentswhen calling this service, you just need to tell camel to use request-reply messaging by setting the mep to inout',1),(4642,'you can use the exchangepattern option to set this as follows:from(\"jms:incomingorders\")',1),(4643,'to(\"jms:validate',1),(4644,'you can also specify the mep using the inout dsl method:from(\"jms:incomingorders\")',1),(4645,'to(\"jms:validate\")',1),(4646,'with the inout method, you can even pass in an endpoint uri as an argument, which shortens your route:from(\"jms:incomingorders\")',1),(4647,'inout(\"jms:validate\")',1),(4648,'by specifying an inout mep, camel will send the message to the validate queue and wait for a reply on a temporary queue that it creates automatically',1),(4649,'when the validatorbean returns a result that message is propagated back to the temporary reply queue, and the route continues on from there',1),(4650,'rather than using temporary queues, you can also explicitly specify a reply queue',1),(4651,'this can be done by setting the jmsreplyto header on the message or by using the replyto uri option described in table 7',1),(4652,'a handy way of calling an endpoint that can return a response is by using the request methods of the producertemplate',1),(4653,'for example, you can send a message into the incomingorders queue and get a response back with the following call:object result = template',1),(4654,'requestbody(\"jms:incomingorders\",     \"<order name=\\\"motor\\\" amount=\\\"1\\\" customer=\\\"honda\\\"/>\");this will return the result of the validatorbean',1),(4655,'to try this out for yourself, go to the chapter7/jms directory in the book’s source, and run this command:mvn test -dtest=requestreplyjmstestthe command will run a unit test demonstrating request-reply messaging as we’ve discussed in this section',1),(4656,'in the jms examples we’ve looked at so far, several data mappings have been happening behind the scenes—mappings that are necessary to conform to the jms specification',1),(4657,'camel could be transporting any type of data, so that data needs to be converted to a type that jms supports',1),(4658,'we’ll look into this next',1),(4659,'3 message mappingscamel hides a lot of the details when doing jms messaging, so you don’t have to worry about them',1),(4660,'but one detail you should be aware of is that camel maps both bodies and headers from the arbitrary types and names allowed in camel to jms-specific types',1),(4661,'body mappingalthough camel poses no restrictions on what a message’s body contains, jms specifies different message types based on what the body type is',1),(4662,'6 shows the five concrete jms message implementations',1),(4663,'info203asynchronous messaging (jms component)the conversion to one of these five jms message types occurs when the exchange reaches a jms producer; said another way, it happens when the exchange reaches a route node like this:to(\"jms:jmsdestinationna...',1),(4664,'this newly created jms message is then sent to the jms destination specified',1),(4665,'6 shows what body types are mapped to jms messages',1),(4666,'another conversion happens when consuming a message from a jms destination',1),(4667,'7 shows the mappings in this case',1),(4668,'although this automatic message mapping allows you to utilize camel’s transformation and mediation abilities fully, you may sometimes need to keep the jms messagetable 7',1),(4669,'6 when sending messages to a jms destination, camel body types are                  mapped to specific jms message types',1),(4670,'camel body type jms message typestring, org',1),(4671,'node textmessagebyte[], java',1),(4672,'bytebufferbytesmessagejava',1),(4673,'map mapmessagejava',1),(4674,'serializable objectmessagejms message type camel body typetextmessage stringbytesmessage byte[]mapmessage java',1),(4675,'mapobjectmessage objectstreammessage no mapping occurs',1),(4676,'messagebytesmessage mapmessage objectmessage streammessage textmessagefigure 7',1),(4677,'messageinterface has five implementations, each of which is built for a different body type',1),(4678,'7 when receiving messages from a jms destination, jms message types are mapped to camel body types    www',1),(4679,'info204 chapter 7 understanding componentsintact',1),(4680,'an obvious reason would be to increase performance; not mapping every message means it will take less time for each message to be processed',1),(4681,'another reason could be that you’re storing an object type that doesn’t exist on camel’s classpath',1),(4682,'in this case, if camel tried to deserialize it, it would fail when finding the class',1),(4683,'tip you can also implement your own custom spring org',1),(4684,'messageconverter by using the messageconverter option',1),(4685,'to disable message mapping for body types, set the mapjmsmessage uri option to false',1),(4686,'header mappingheaders in jms are even more restrictive than body types',1),(4687,'in camel, a header can be named anything that will fit in a java string and its value can be any java object',1),(4688,'this presents a few problems when sending to and receiving from jms destinations',1),(4689,'these are the restrictions in jms: ■ header names that start with “jms” are reserved; you can’t use these header names',1),(4690,'■ header names must be valid java identifiers',1),(4691,'■ header values can be any primitive type and their corresponding object types',1),(4692,'these include boolean, byte, short, int, long, float, and double',1),(4693,'valid object types include boolean, byte, short, integer, long, float, double, and string',1),(4694,'to handle these restrictions, camel does a number of things',1),(4695,'first, any headers that you set starting with “jms” will be dropped before sending to a jms destination',1),(4696,'camel also attempts to convert the header names to be jms-compliant',1),(4697,') characters are replaced by “_dot_” and any hyphens (-) are replaced with “_hyphen_”',1),(4698,'test-header would be converted to org_dot_apache_dot_camel_dot_test_hyphen_header before being sent to a jms destination',1),(4699,'if this message is consumed by a camel route at some point down the line, the header name will be converted back',1),(4700,'to conform to the jms specification, camel will drop any header that has a value not listed in the list of primitives or their corresponding object types',1),(4701,'camel also allows charsequence, date, bigdecimal, and biginteger header values, all of which are converted to their string representations to conform to the jms specification',1),(4702,'you should now have a good grasp of what camel can do for your jms messaging applications',1),(4703,'jms messaging applications are typically used within an organization—users outside the corporate firewall rarely send jms messages to internal systems',1),(4704,'for messaging with the external world, web services can be used',1),(4705,'we’ll look at how camel uses apache cxf to access and serve up web services next',1),(4706,'info205web services (cxf component)7',1),(4707,'4 web services (cxf component)you would be hard pressed to find any modern enterprise project that doesn’t use web services of some sort',1),(4708,'they’re an extremely useful integration technology for distributed applications',1),(4709,'web services are often associated with service-oriented architecture (soa), where each service is defined as a web service',1),(4710,'you can think of a web service as an api on the network',1),(4711,'the api itself is defined using the web services description language (wsdl), specifying what operations you can call on a web service and what the input and output types are, among other things',1),(4712,'messages are typically xml, formatted to comply with the simple object access protocol (soap) schema',1),(4713,'in addition, these messages are typically sent over http',1),(4714,'as illustrated in figure 7',1),(4715,'7, web services allow you to write java code and make that java code callable over the internet, which is pretty neat',1),(4716,'for accessing and publishing web services, camel uses apache cxf (http:// cxf',1),(4717,'cxf is a popular web services framework that supports many web services standards, most of which we won’t discuss here',1),(4718,'we’ll mainly be focusing on developing web services using the java api for xml web services (jax-ws) specification',1),(4719,'jax-ws defines annotations that allow you to tell a tool like cxf how your pojo should be represented on the web',1),(4720,'we’ll be covering two types of web services development with cxf in this section: ■ contract-first development—recall that wsdls define what operations and types a web service provides',1),(4721,'this is often referred to as a web services contract, and in order to communicate with a web service, you must satisfy the contract',1),(4722,'contract-first development means that you start out by writing a wsdl file (either by hand or with the help of tooling), and then generating stub java class implementations from the wsdl file by using a tool like cxf',1),(4723,'■ code-first development—the other way to develop web services is by starting out with a java class and then letting the web service framework handle the job of generating a wsdl contract for you',1),(4724,'this is by far the easiest mode of development, but it also means that the tool (cxf in this case) is in control of what the contract will be',1),(4725,'when you want to fine-tune your wsdl file, it may be better to go the contract-first route',1),(4726,'clientwsdlclient classservice endpointinterfaceweb servicesframeworkweb serviceservice endpointimplementationweb servicesframeworksoap/httpfigure 7',1),(4727,'7 a client invokes a remote web service over http',1),(4728,'to the client, it looks as if it’s calling a java method on the service endpoint interface (sei)',1),(4729,'under the hood, this method invocation passes through the web services framework, across a network, and finally calls into the service endpoint implementation on the remote server',1),(4730,'info206 chapter 7 understanding componentsto show these concepts in action, let’s going back to rider auto parts, where they need a new piece of functionality implemented',1),(4731,'2) you saw how customers could place orders in two ways: ■ uploading the order file to an ftp server■ submitting the order from the rider auto parts web store via httpwhat we didn’t say then was that this http link to the backend order processing sys...',1),(4732,'before you jump into creating this web service, let’s take a moment to go over how cxf can be configured within camel',1),(4733,'1 configuring cxfthere are two main ways to configure a cxf component uri: by referencing a bean containing the configuration or by configuring it within the uri',1),(4734,'configuring using uri optionswhen configuring cxf using only uri options, a cxf endpoint uri looks like this,cxf://anaddress[',1),(4735,'options]where anaddress is a url like http://rider',1),(4736,'com:9999/order, and options are appended as usual from the possible options in table 7',1),(4737,'these options can also be used to configure a reusable cxf endpoint bean in spring',1),(4738,'8 common uri options used to configure the cxf componentoption default value descriptionwsdlurl retrieved from the endpoint addressspecifies the location of the wsdl contract file',1),(4739,'serviceclass null specifies the name of the service endpoint interface (sei)',1),(4740,'typically this interface will have jax-ws annotations',1),(4741,'the sei is required if the cxf data format mode is pojo',1),(4742,'if you already have an instance of a concrete class, you can reference it using the #beannamestyle',1),(4743,'servicename obtained from the wsdlspecifies the service to use',1),(4744,'the format is a qualified name (qname) that has a namespace and name like {http:// order',1),(4745,'note that if there is only one service in a wsdl, camel will choose this as the default service',1),(4746,'if there is more than one service defined, you need to set the servicename property',1),(4747,'portname obtained from the wsdlspecifies the port to use',1),(4748,'the format is a qualified name (qname) that has a namespace and name like {http:// order',1),(4749,'info207web services (cxf component)configuring using a cxf endpoint beanwhen using a cxf endpoint bean in spring, you have much more power than by configuring cxf via uri options',1),(4750,'in the cxf endpoint bean, you can configure things like cxf interceptors, jax-ws handlers, and the cxf bus',1),(4751,'the uri for configuring the cxf component looks like this:cxf:bean:beannamethe beanname name specifies the id of the cxf endpoint bean defined in your spring xml file',1),(4752,'this bean supports the uri options listed in table 7',1),(4753,'8 as well as an address attribute that tells camel what address to use for the web service',1),(4754,'listing 7',1),(4755,'2 shows how a cxf endpoint bean is configured',1),(4756,'<beans xmlns=\"http://www',1),(4757,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(4758,'org/2001/xmlschema-instance\"       xmlns:cxf=\"http://camel',1),(4759,'org/schema/cxf\"       xsi:schemalocation=\"         http://www',1),(4760,'org/schema/beans          http://www',1),(4761,'org/schema/beans/spring-beans-3',1),(4762,'xsd         http://camel',1),(4763,'org/schema/cxf                             http://camel',1),(4764,'org/schema/cxf/camel-cxf',1),(4765,'xsd\">  <import resource=\"classpath:meta-inf/cxf/cxf',1),(4766,'xml\"/>                  <import resource=\"classpath:meta-inf/cxf/',1),(4767,'cxf-extension-soap',1),(4768,'xml\"/>                               <import resource=\"classpath:meta-inf/cxf/',1),(4769,'cxf-extension-http-jetty',1),(4770,'xml\"/>                      <cxf:cxfendpoint     id=\"orderendpoint\"                                     address=\"http://localhost:9000/order/\"                       serviceclass=\"camelinaction',1),(4771,'orderendpoint\"/> </beans>after configuring an endpoint as shown in listing 7',1),(4772,'2, you can use it in a producer or consumer using the following uri:cxf:bean:orderendpointnote that if there is only one port in a wsdl, camel will choose this as the default port',1),(4773,'if there is more than one port defined per service, you need to set the portname property',1),(4774,'dataformat pojo sets the data format type that cxf uses for its messages',1),(4775,'the possible values are pojo, payload, and message',1),(4776,'we’ll only be covering pojo mode in this chapter; you can find more information on the other two modes on the cxf component page in the camel online documentation: http://camel',1),(4777,'listing 7',1),(4778,'8 common uri options used to configure the cxf component (continued)option default value description        sets bean id, address, and sei    www',1),(4779,'info208 chapter 7 understanding componentsthere is a notable difference when using producers versus consumers',1),(4780,'producers versus consumersin the context of a web service, a producer in camel calls a remote web service',1),(4781,'this web service could be defined by camel or by some other web framework',1),(4782,'to invoke a web service in camel, you use the familiar to java dsl method:',1),(4783,'to(\"cxf:bean:orderendpoint\");consumers are a little more interesting, as they expose an entire route to the world as a web service',1),(4784,'this is a powerful concept',1),(4785,'a camel route could be a complex process, with many branches and processing nodes, but the caller will only see it as a web service with input parameters and a reply',1),(4786,'say you start out with a route that consists of several steps, like this:from(\"jms:myqueue\")',1),(4787,'to(\"complex step 1\")',1),(4788,'to(\"complex step n\");to expose this route to the web, you can add a cxf endpoint to the beginning:from(\"cxf:bean:mycxfendpointbean\")',1),(4789,'to(\"complex step 1\")',1),(4790,'to(\"complex step n\");now, when the web service configured by mycxfendpointbean is called, the whole route will be invoked',1),(4791,'tip if you’re coming from a background in soa or have used web services before, you may be scratching your head about consumers in camel',1),(4792,'in the web services world, a consumer is typically a client that calls a remote service',1),(4793,'in camel, a consumer is a server, so the definition is reversed',1),(4794,'maven dependenciesin order to use the cxf component, you’ll have to add some dependencies',1),(4795,'first, you need to depend on the camel-cxf module:<dependency>  <groupid>org',1),(4796,'camel</groupid>  <artifactid>camel-cxf</artifactid>  <version>2',1),(4797,'0</version> </dependency>that will get you most of the way to a usable cxf component, but you also need to add a module for the cxf transport you’re using',1),(4798,'in most cases, this will be http, so you’ll need to add another dependency to your pom:<dependency>  <groupid>org',1),(4799,'cxf</groupid>  <artifactid>cxf-rt-transports-http-jetty</artifactid>  <version>2',1),(4800,'10</version> </dependency>    www',1),(4801,'info209web services (cxf component)cxf supports several other transports as well, and you can find more information about them on the cxf website at http://cxf',1),(4802,'org/docs/transports',1),(4803,'now that you have a sense of the configuration details, let’s take a hands-on look at how to develop web services with camel',1),(4804,'2 using a contract-first approachin contract-first development, you start by creating a wsdl document and then getting a web service tool to generate the necessary java code',1),(4805,'this process is illustrated in figure 7',1),(4806,'creating the wsdl contract for a particular web service is a non-trivial task',1),(4807,'it’s often best to think about what methods, types, and parameters you’ll need before starting',1),(4808,'in this case, to place an order at rider auto parts with a web service, you need a single method call named order',1),(4809,'this method will accept part name, amount, and customer name parameters',1),(4810,'when the method is complete, it will return a result code to the client',1),(4811,'the web service should be exposed on the server’s http://localhost:9000/order address',1),(4812,'the wsdl for this web service is shown in listing 7',1),(4813,'<wsdl:definitions xmlns:soap=\"http://schemas',1),(4814,'xmlsoap',1),(4815,'org/wsdl/soap/\"    xmlns:tns=\"http://order',1),(4816,'camelinaction\"    xmlns:xs=\"http://www',1),(4817,'org/2001/xmlschema\"    xmlns:http=\"http://schemas',1),(4818,'xmlsoap',1),(4819,'org/wsdl/http/\"    xmlns:wsdl=\"http://schemas',1),(4820,'xmlsoap',1),(4821,'org/wsdl/\"    targetnamespace=\"http://order',1),(4822,'camelinaction\">  <wsdl:types>                                              <xs:schema targetnamespace=\"http://order',1),(4823,'camelinaction\">      <xs:element type=\"xs:string\" name=\"partname\" />      <xs:element type=\"xs:int\" name=\"amount\" />      <xs:element type=\"xs:string\" name=\"customername\" />      <xs:element type=\"xs:string\" name=\"resultcode\" />    </xs:schema>  </ws...',1),(4824,'3 the wsdl for an order service wsdlservice endpointinterfacestub serviceendpointimplementationwsdl to java tooldeveloperfigure 7',1),(4825,'8 in contract-first web service development, you start out by creating a wsdl document and letting a tool generate the required source interfaces and stubs',1),(4826,'defines input and output parametersbdefines messagesc    www',1),(4827,'info210 chapter 7 understanding components  <wsdl:message name=\"orderresult\">    <wsdl:part name=\"resultcode\" element=\"tns:resultcode\" />  </wsdl:message>  <wsdl:porttype name=\"orderendpoint\">                    <wsdl:operation name=\"order\">      <ws...',1),(4828,'xmlsoap',1),(4829,'org/soap/http\" />    <wsdl:operation name=\"order\">      <soap:operation soapaction=\"http://order',1),(4830,'camelinaction/order\" style=\"document\" />      <wsdl:input>        <soap:body parts=\"in\" use=\"literal\" />      </wsdl:input>      <wsdl:output>        <soap:body parts=\"out\" use=\"literal\" />      </wsdl:output>    </wsdl:operation>  </wsdl:binding>  <...',1),(4831,'3, a wsdl contract is quite a mouthful',1),(4832,'writing this kind of document from scratch would be pretty hard to get right',1),(4833,'typically, a good way to start one of these is to use a wizard or gui tooling',1),(4834,'for instance, in eclipse you can use the file > new > other > web services > wsdl wizard to generate a skeleton wsdl file based on several options',1),(4835,'tweaking this skeleton file is much easier than starting from scratch',1),(4836,'cxf also has command-line tools to help you create a wsdl contract properly',1),(4837,'once you have a porttype element defined, you can pass the wsdl fragment through cxf’s wsdl2xml tool (http://cxf',1),(4838,'org/docs/wsdl-to-xml',1),(4839,'when the binding element is defined, the wsdl2service tool (http://cxf',1),(4840,'org/docs/wsdl-to-service',1),(4841,'html) can then generate a service element for you',1),(4842,'defines interface to callduses soap encoding over http transporteexposes service using interfacefwsdl 1',1),(4843,'1 versus 2',1),(4844,'0if you’ve used wsdl documents before, you may have picked up on the version of the wsdl specification we used in listing 7',1),(4845,'we used wsdl version 1',1),(4846,'1 because the current version of cxf only supports 1',1),(4847,'this is also the most common wsdl version you’ll see in use',1),(4848,'0 changes things substantially, and to date few web services tools (like cxf) support it',1),(4849,'info211web services (cxf component)there are five main elements specified in the wsdl file shown in listing 7',1),(4850,'3, and all wsdl files follow this same basic structure:■ types—data types used by the web service■ message—messages used by the web service■ porttype—interface name and operation performed by the web service■ binding—transport type and message encodi...',1),(4851,'this configuration is done using the xml schema, which may make it a bit more familiar to you',1),(4852,'you specify a name and a type for each parameter',1),(4853,'the next section of listing 7',1),(4854,'3 defines the messages used by the web service c',1),(4855,'these messages allow you to assign parameters to use as input versus output',1),(4856,'you then define the porttype d, which is the interface that you’ll be exposing over the web',1),(4857,'on this interface, you define a single operation (method) that takes a purchaseorder message as input and returns an orderresult message',1),(4858,'the binding section e then specifies the use of the http transport for the messages and that the messages should be encoded over the wire using document literal style',1),(4859,'document literal means that the soap message body will be an xml document',1),(4860,'the format of this xml document is specified using the xml schema',1),(4861,'note there are more options to choose from for wsdl binding and encoding',1),(4862,'an excellent introduction is available from the ibm developerworks website: http://www',1),(4863,'com/developerworks/webservices/library/ws-whichwsdl',1),(4864,'finally, the service section f exposes a port using a specific binding on an address',1),(4865,'there can be more than one port listed here',1),(4866,'in this example, you use the port and binding definitions from before and set the web service address to http://localhost:9000/order',1),(4867,'the next step in contract-first web service development is taking the wsdl and generating java code that implements it',1),(4868,'cxf provides the wsdl2java tool (http:// cxf',1),(4869,'org/docs/wsdl-to-java',1),(4870,'html) to do this for you',1),(4871,'listing 7',1),(4872,'4 shows how this tool can be used from a maven pom file',1),(4873,'cxf</groupid>  <artifactid>cxf-codegen-plugin</artifactid>  <version>2',1),(4874,'10</version>  <executions>    <execution>      <id>generate-sources</id>      <phase>generate-sources</phase>      <configuration>listing 7',1),(4875,'4 using cxf’s wsdl2java tool    www',1),(4876,'info212 chapter 7 understanding components        <sourceroot>          ${basedir}/target/generated/src/main/java               </sourceroot>        <wsdloptions>          <wsdloption>            <wsdl>         ${basedir}/src/main/resources/wsdl/order',1),(4877,'wsdl                  </wsdl>            <extraargs>              <extraarg>-impl</extraarg>            </extraargs>          </wsdloption>        </wsdloptions>      </configuration>      <goals>        <goal>wsdl2java</goal>      </goals>    </exec...',1),(4878,'to run this tool for yourself, change to the chapter7/cxf/contract_first directory and run the following command:mvn generate-sourcesafter this completes, you can look in the output directory and see that there are four files generated:objectfactory',1),(4879,'javathese files implement a stubbed-out version of the order web service',1),(4880,'if you were not using camel, you would write your business logic in the orderendpointimpl file that was generated',1),(4881,'to use this web service in camel, you need to define a cxf endpoint',1),(4882,'listing 7',1),(4883,'5 shows how to do this in spring',1),(4884,'<beans xmlns=\"http://www',1),(4885,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(4886,'org/2001/xmlschema-instance\"       xmlns:cxf=\"http://camel',1),(4887,'org/schema/cxf\"       xsi:schemalocation=\"         http://www',1),(4888,'org/schema/beans          http://www',1),(4889,'org/schema/beans/spring-beans-3',1),(4890,'xsd         http://camel',1),(4891,'org/schema/cxf          http://camel',1),(4892,'org/schema/cxf/camel-cxf',1),(4893,'xsd\">  <import resource=\"classpath:meta-inf/cxf/cxf',1),(4894,'xml\"/>  <import resource=\"classpath:meta-inf/cxf/cxf-extension-soap',1),(4895,'xml\"/>listing 7',1),(4896,'xmllocation of generated sourceblocation of input wsdlc    www',1),(4897,'info213web services (cxf component)  <import resource=\"classpath:meta-inf/cxf/cxf-extension-http-jetty',1),(4898,'xml\"/>  <cxf:cxfendpoint id=\"orderendpoint\"                                        address=\"http://localhost:9000/order/\"                   serviceclass=\"camelinaction',1),(4899,'orderendpoint\"                   wsdlurl=\"wsdl/order',1),(4900,'wsdl\"/> </beans>this endpoint configures cxf under the hood to use the web service located at http: //localhost:9000/order and using the camelinaction',1),(4901,'because there is only one service defined in order',1),(4902,'wsdl, cxf will choose that automatically',1),(4903,'if there were more than one service, you would need to set the servicename and endpointname attributes on the endpoint bean',1),(4904,'the servicename is the name of the wsdl service element, and endpointname is the name of the port element',1),(4905,'you can browse a web service’s wsdl yourself by appending',1),(4906,'wsdl to any web service url in your browser',1),(4907,'for this address, that would be http://localhost:9000/ order',1),(4908,'wsdl',1),(4909,'this wsdl is the same as the file provided in the wsdlurl attribute of the endpoint bean',1),(4910,'adding a web service to your routewith all that set up, you’re ready to start using the order web service within a camel route',1),(4911,'listing 7',1),(4912,'6 shows a route using the web service',1),(4913,'<import                                                       resource=\"classpath:meta-inf/spring/camel-cxf',1),(4914,'xml\" />  <camelcontext xmlns=\"http://camel',1),(4915,'org/schema/spring\">    <route>    <from uri=\"cxf:bean:orderendpoint\" />            <to uri=\"seda:incomingorders\" />     <transform>      <constant>ok</constant>                </transform>  </route> </camelcontext>because you defined your cxf web ser...',1),(4916,'5, you just had to import the bean configuration b and refer to the bean id to set up the consumer c',1),(4917,'recall that setting up a cxf consumer effectively turns the entire route into a web service, so once the order data is sent to an internal queue for processing, the output produced by the route d is returned to the caller of the web service c',1),(4918,'how does one call this web service',1),(4919,'well, you could use pure cxf or another web services framework compatible with cxf',1),(4920,'in this case, you’ll use camel',1),(4921,'you used an endpoint bean to configure cxf earlier, so you can use that to send to the web service as well',1),(4922,'you first need to prepare the parameters to be passed into the web service:listing 7',1),(4923,'6 web-enabled route configurationdefines endpoint to be used from camelimports cxf endpoint beanbexposes route as web servicecreturns ok reply to callerd    www',1),(4924,'info214 chapter 7 understanding componentslist<object> params = new arraylist<object>(); params',1),(4925,'add(\"honda\");recall that, in the wsdl, you specified that the web service accepted parameters for part name, number of parts, and customer name',1),(4926,'next, you can use a producertemplate to send a message to the web service:string reply = template',1),(4927,'requestbody(\"cxf:bean:orderendpoint\", params, string',1),(4928,'class); assertequals(\"ok\", reply);to try this out for yourself, change to the chapter7/cxf/contract_first directory, and run the following maven command:mvn testthis will run the wsdl2java tool to generate the code from the wsdl, and then run a test ...',1),(4929,'selecting the operation when invoking web servicesif you call a web service with multiple operations, you need to specify which operation camel should invoke',1),(4930,'you can do this by setting the operationname header on the message before sending it to a cxf endpoint',1),(4931,'here is an example: <route>  <from uri=\"direct:startorder\" />  <setheader headername=\"operationname\">    <constant>order</constant>  </setheader>  <to uri=\"cxf:bean:orderendpoint\"/> </route>                          in this case, you’re invoking the ...',1),(4932,'the header is set to the operation name order, which you can find in the wsdl under the wsdl:operation element',1),(4933,'other ways of communicating over httpthe cxf component provides extensive support for many web services standards',1),(4934,'in some cases, you may not need to or won’t be able to use those standards and you’ll just need to communicate over http',1),(4935,'for example, you may be interfacing with an http-based service that has been up since before the ws-* specifications were created',1),(4936,'you could also need a barebones web service where you manually handle things like parsing the messages',1),(4937,'or maybe you want to download a remote file over http—there are lots of reasons you might need http support',1),(4938,'camel provides two main ways of doing raw communications over http: the jetty component and the http component',1),(4939,'the http component can only be used for sending (producing) to a remote service, whereas the jetty component can handle consuming and producing',1),(4940,'info215web services (cxf component)think contract-first development is hard',1),(4941,'well, some developers do, even though it gives you complete control over your web service contract—an important detail',1),(4942,'next we’ll look at how to develop web services using a code-first approach',1),(4943,'3 using a code-first approachcode-first web services development is often touted as a much easier alternative to contract-first development',1),(4944,'in code-first development, you start out with java that’s annotated with jax-ws annotations, and then you get the web services framework to generate the underlying wsdl contract for you',1),(4945,'this process is illustrated in figure 7',1),(4946,'to see how this is possible with camel, let’s try implementing the solution presented in the previous section in a code-first manner',1),(4947,'you start much as you do with contract-first development—you need to think about what methods, types, and parameters you need',1),(4948,'because you’re starting with java, you’ll need an interface to represent the web service:@webservice public interface orderendpoint {    string order(string partname, int amount, string customername); }the jax-ws javax',1),(4949,'webservice annotation will tell cxf that this interface is a web service',1),(4950,'there are many annotations that allow you to fine-tune the generated wsdl, but for many cases the defaults work quite well',1),(4951,'in order to use this interface as a web service, you don’t have to change any of your camel configuration from the previous section',1),(4952,'yes, you read that correctly',1),(4953,'your cxf endpoint bean is still defined as follows:(continued)for the special case where you can’t start up an embedded jetty server and need to hook in to the existing servlet container (like apache tomcat), you can use the servlet component',1),(4954,'you can find more information on these components on the camel website:■ http component—http://camel',1),(4955,'org/servlet',1),(4956,'9 in code-first web services development, you start out by coding the service interface and implementation and then using a tool to generate the required wsdl',1),(4957,'info216 chapter 7 understanding components<cxf:cxfendpoint id=\"orderendpoint\"                 address=\"http://localhost:9000/order/\"                 serviceclass=\"camelinaction',1),(4958,'orderendpoint\"/>to use this bean in a camel route, you can reference it as before:<from uri=\"cxf:bean:orderendpoint\" /> to try this out for yourself, change to the chapter7/cxf/code_first directory and run the following maven command:mvn testthis wil...',1),(4959,'the java to wsdl process happens automatically in the background',1),(4960,'certainly, the code-first approach allows you to implement web services quickly',1),(4961,'but it’s good to understand what is happening under the hood of a web service, because it’s a complex technology',1),(4962,'speaking of under the hood, several types of messaging that we’ve looked at before, like ftp, jms, and now web services, all run on top of other protocols',1),(4963,'let’s look at how you can use camel for these kinds of low-level communications',1),(4964,'5 networking (mina component)so far in this chapter, you’ve seen a mixture of old integration techniques, such as filebased integration, and newer technologies like jms and web services',1),(4965,'all of these can be considered essential in any integration framework',1),(4966,'another essential mode of integration is using low-level networking protocols, such as the transmission control protocol (tcp) and the user datagram protocol (udp)',1),(4967,'even if you haven’t heard of these protocols before, you’ve definitely used them—protocols like email, ftp, and http run on top of tcp',1),(4968,'to communicate over these and other protocols, camel uses apache mina and netty',1),(4969,'both mina and netty are networking frameworks that provide asynchronous event-driven apis and communicate over various protocols like tcp and udp',1),(4970,'in this section, we’ll be using mina to demonstrate low-level network communication with camel',1),(4971,'for more information on using netty with camel, see the camel-netty component’s documentation (http://camel',1),(4972,'the mina component is located in the camel-mina module of the camel distribution',1),(4973,'you can access this by adding it as a dependency to your maven pom like this:<dependency>  <groupid>org',1),(4974,'camel</groupid>  <artifactid>camel-mina</artifactid>  <version>2',1),(4975,'0</version> </dependency>the most common configuration options are listed in table 7',1),(4976,'info217networking (mina component)in addition to the uri options, you also have to specify the transport type and port you want to use',1),(4977,'in general, a mina component uri will look like this,mina:transport://hostname[:port][',1),(4978,'options] where transport is one of tcp, udp, multicast/mcast, or vm',1),(4979,'let’s now see how you can use the mina component to solve a problem at rider auto parts',1),(4980,'1 using mina for network programmingback at rider auto parts, the production group has been using automated manufacturing robots for years to assist in producing parts',1),(4981,'what they’ve been lacking, though, is a way of tracking the whole plant’s health from a single location',1),(4982,'they currently have floor personnel monitoring the machines manually',1),(4983,'what they’d like to have is an operations center with a single-screen view of the entire plant',1),(4984,'to accomplish this, they’ve purchased sensors that communicate machine status over tcp',1),(4985,'the new operations center needs to consume these messages over jms',1),(4986,'10 illustrates this setup',1),(4987,'9 common uri options used to configure the mina componentoptiondefault valuedescriptioncodec null specifies the codec used to marshal the message body',1),(4988,'codecs need to be loaded into the registry and referenced using the #beanname style',1),(4989,'textline false enables the textline codec when you’re using tcp and no other codec is specified',1),(4990,'the textline codec understands bodies that have string content and end with a line delimiter',1),(4991,'textlinedelimiter default sets the delimiter used for the textline codec',1),(4992,'possible values include: default, auto, windows, unix, or mac',1),(4993,'sync true sets the synchronous mode of communication',1),(4994,'this means that clients will be able to get a response back from the server',1),(4995,'timeout 30000 sets the time in milliseconds to wait for a response from a remote server',1),(4996,'encoding jvm defaultspecifies the java',1),(4997,'charset',1),(4998,'charset used to encode the data',1),(4999,'transferexchange false specifies whether only the message body is transferred',1),(5000,'enable this property to serialize the entire exchange for transmission',1),(5001,'filters null specifies what mina org',1),(5002,'iofilter beans to use',1),(5003,'it should be specified as a comma-separated list of bean references, like \"#filter1,#filter2\"',1),(5004,'info218 chapter 7 understanding componentshand-coding a tcp server such as this wouldn’t be a trivial exercise',1),(5005,'you’d need to spin up new threads for each incoming socket connection, as well as transform the body to a format suitable for jms',1),(5006,'in camel, a possible solution is accomplished with a single line:from(\"mina:tcp://localhost:8999',1),(5007,'textline=true&sync=false\")',1),(5008,'to(\"jms:operations\");here you set up a tcp server on port 8999 using mina, and it parses messages using the textline codec',1),(5009,'the sync property is set to false to make this route inonly—any clients sending a message won’t get a reply back',1),(5010,'you may be wondering what a textline codec is, and maybe even what a codec is',1),(5011,'in tcp communications, a single message payload going out may not reach its destination in one piece',1),(5012,'all will get there, but it may be broken up or fragmented into smaller packets',1),(5013,'it’s up to the receiver (in this case, the server) to wait for all the pieces and assemble them back into one payload',1),(5014,'a codec decodes or encodes the message data into something that the applications on either end of the communications link can understand',1),(5015,'as figure 7',1),(5016,'11 illustrates, the textline codec is responsible for grabbing packets as they come in and trying to piece together a message that’s terminated by a specified character',1),(5017,'this example is provided in the book’s source in the chapter7/mina directory',1),(5018,'try it out using the following command:mvn test -dtest=minatcptestjms:operations mina:tcp://localhost:8999sensor 1sensor n',1),(5019,'10 sensors feed status messages over tcp to a server, which then forwards them to a jms operations queue',1),(5020,'sender receiver“hello \\n” “hello \\n”“hel”“lo\\n”tcpcodec codecfigure 7',1),(5021,'11 during tcp communications, a payload may be broken up into multiple packets',1),(5022,'a mina textline codec can assemble the tcp packets into a full payload by appending text until it encounters a delimiter character',1),(5023,'info219networking (mina component)object serialization codecif you had not specified the textline uri option in the previous example, the mina component would have defaulted to using the object serialization codec',1),(5024,'this codec will take any serializable java object and send its bytes over tcp',1),(5025,'this is a pretty handy codec if you aren’t sure what payload format to use',1),(5026,'if you’re using this codec, you’ll also need to ensure that the classes are on the classpath of both the sender and the receiver',1),(5027,'there are times when your payload will have a custom format that neither textline or object serialization accommodates',1),(5028,'in this case, you’ll need to create a custom codec',1),(5029,'2 using custom codecsthe tcp server you set up for rider auto parts in the previous section has worked out well',1),(5030,'sensors have been sending back status messages in plain text, and you used the mina textline codec to successfully decode them',1),(5031,'but one type of sensor has been causing an issue: the sensor connected to the welding machine sends its status back in a custom binary format',1),(5032,'you need to interpret this custom format and send a status message formatted like the ones from the other sensors',1),(5033,'we can do this with a custom mina codec',1),(5034,'in mina, a codec consists of three parts: ■ protocolencoder—the protocolencoder has the job of taking an input payload and putting bytes onto the tcp channel',1),(5035,'in this example, the sensor will be transmitting the message over tcp, so you don’t have to worry about this too much, except for testing that the server works',1),(5036,'■ protocoldecoder—the protocoldecoder interprets the custom binary message from the sensor and returns a message that your application can understand',1),(5037,'■ protocolcodecfactory—as implied by the name, the protocolcodecfactory creates the encoder and decoder',1),(5038,'you can specify a custom codec in a camel uri by using the codec property and specifying a reference to a protocolcodecfactory instance in the registry',1),(5039,'the custom binary payload that you have to interpret with your codec is 8 bytes in total; the first 7 bytes are the machine id and the last byte is a value indicating the status',1),(5040,'you need to convert this to the plain text format used by the other sensors, as illustrated in figure 7',1),(5041,'2371748 1machine id status“machineid=2371748;status=good”welderdecoderfigure 7',1),(5042,'12 the custom welder sensor decoder is used to interpret an 8-byte binary payload and construct a plain text message body',1),(5043,'the first 7 bytes are the machine id and the last byte represents a status',1),(5044,'in this case, a value of 1 means “good”',1),(5045,'info220 chapter 7 understanding componentsyour route looks similar to the previous example:from(\"mina:tcp://localhost:8998',1),(5046,'codec=#weldercodec&sync=false\")',1),(5047,'to(\"jms:operations\");note that you need to change the port that it listens on, so as not to conflict with your other tcp server',1),(5048,'you also add a reference to the custom codec loaded into the registry',1),(5049,'in this case, the codec is loaded into a jndiregistry like this:jndiregistry jndi =',1),(5050,'bind(\"weldercodec\", new weldersensorcodec());the weldersensorcodec is defined as a mina protocolcodecfactory object',1),(5051,'it merely creates the encoder and decoder, as shown here:public class weldersensorcodec implements protocolcodecfactory {    public protocolencoder getencoder() throws exception {        return new welderencoder();    }    public protocoldecoder getd...',1),(5052,'if you recall, decoding the custom binary format into a plain text message was the most important task for this particular application',1),(5053,'this decoder is shown in listing 7',1),(5054,'class welderdecoder extends cumulativeprotocoldecoder {    static final int payload_size = 8;    protected boolean dodecode(iosession session, bytebuffer in, protocoldecoderoutput out) throws exception {        if (in',1),(5055,'get(buf);            stringbuilder sb = new stringbuilder();            sb',1),(5056,'append(\"status=\");            if (buf[payload_size - 1] == \'1\') {                      sb',1),(5057,'append(\"good\");            } else {                sb',1),(5058,'write(sb',1),(5059,'tostring());            return true;        } else {            return false;        }    } }listing 7',1),(5060,'7 the decoder for the welder sensorwaits for all 8 bytes of payloadbgets first 7 bytes as machine idcgets last byte as statusd    www',1),(5061,'info221working with databases (jdbc and jpa components)the decoder shown in listing 7',1),(5062,'7 may look a bit complex, but it’s only doing three main things: waiting for 8 bytes of payload to arrive on the tcp channel b, extracting the first 7 bytes and using that as the machine id string c, and checking the last byte for a status of 1, whic...',1),(5063,'to try this example yourself, go to the chapter7/mina directory of the book’s source and run the following unit test:mvn test -dtest=minacustomcodectestnow that you’ve tried out low-level network communications, its time to interact with one of the m...',1),(5064,'that’s the database',1),(5065,'6 working with databases (jdbc and jpa components)in pretty much every enterprise-level application, you’ll need to integrate with a database at some point',1),(5066,'so it makes sense that camel has first-class support for accessing databases',1),(5067,'camel has five components that let you access databases in a number of ways:■ jdbc component—allows you to access jdbc apis from a camel route',1),(5068,'■ sql component—allows you to write sql statements directly into the uri of the component for utilizing simple queries',1),(5069,'■ jpa component—persists java objects to a relational database using the java persistence architecture',1),(5070,'■ hibernate component—persists java objects using the hibernate framework',1),(5071,'this component isn’t distributed with apache camel due to licensing incompatibilities',1),(5072,'■ ibatis component—allows you to map java objects to relational databases',1),(5073,'in this section, we’ll be covering both the jdbc and jpa components',1),(5074,'these are the most-used database-related components in camel',1),(5075,'you can do pretty much any database-related task with them that you can do with the others',1),(5076,'for more information on the other components, see the relevant pages on the camel website’s components list (http://camel',1),(5077,'let’s look first at the jdbc component',1),(5078,'1 accessing data with the jdbc componentthe java database connectivity (jdbc) api defines how java clients can interact with a particular database',1),(5079,'it tries to abstract away details about the actual database being used',1),(5080,'to use this component, you need to add the camel-jdbc module to your project:<dependency>  <groupid>org',1),(5081,'camel</groupid>  <artifactid>camel-jdbc</artifactid>  <version>2',1),(5082,'0</version> </dependency>    www',1),(5083,'info222 chapter 7 understanding componentsthe most common uri options are shown in table 7',1),(5084,'the endpoint uri for the jdbc component points camel to a javax',1),(5085,'datasource loaded into the registry, and, like other components, it allows for configuration options to be set',1),(5086,'the uri syntax is as follows:jdbc:datasourcename[',1),(5087,'options]after this is specified, the component is ready for action',1),(5088,'but you may be wondering where the actual sql statement is specified',1),(5089,'the jdbc component is a dynamic component in that it doesn’t merely deliver a message to a destination but takes the body of the message as a command',1),(5090,'in this case, the command is specified using sql',1),(5091,'in eip terms, this kind of message is called a command message',1),(5092,'because a jdbc endpoint accepts a command, it doesn’t make sense to use it as a consumer, so, you can’t use it in a from dsl statement',1),(5093,'of course, you can still retrieve data using a select sql statement as the command message',1),(5094,'in this case, the query result will be added as the outgoing message on the exchange',1),(5095,'to demonstrate the sql command-message concept, let’s revisit the order router at rider auto parts',1),(5096,'in the accounting department, when an order comes in on a jms queue, the accountant’s business applications can’t use this data',1),(5097,'they can only import data from a database',1),(5098,'so any incoming orders need to be put into the corporate database',1),(5099,'using camel, a possible solution is illustrated in figure 7',1),(5100,'10 common uri options used to configure the jdbc componentoptiondefault valuedescriptionreadsize 0 sets the maximum number of rows that can be returned',1),(5101,'the default of 0 causes the readsize to be unbounded',1),(5102,'propertyname null sets the property with name propertyname on the underlying java',1),(5103,'usejdbc4columnnameandlabelsemantics true sets the column and label semantics to use',1),(5104,'default is to use the newer jdbc 4 style, but you can set this property to false to enable jdbc 3 style',1),(5105,'jms:accountingordertosqlbeancjdbc:datasourceexecutecommand cdatabasefigure 7',1),(5106,'13 a message from the jms accounting queue is transformed into an sql command message by the ordertosqlbean bean',1),(5107,'the jdbc component then executes this command against its configured data source',1),(5108,'info223working with databases (jdbc and jpa components)the main takeaway from figure 7',1),(5109,'13 is that you’re using a bean to create the sql statement from the incoming message body',1),(5110,'this is the most common way to prepare a command message for the jdbc component',1),(5111,'you could use the dsl directly to create the sql statement (by setting the body with an expression), but you have much more control when you use a custom bean',1),(5112,'13 is simple on the surface:from(\"jms:accounting\")',1),(5113,'to(\"jdbc:datasource\");there are two things that require further explanation here',1),(5114,'first, the jdbc endpoint is configured to load the javax',1),(5115,'datasource with the name datasource in the registry',1),(5116,'the bean endpoint here is using the bean with the name ordertosql to convert the incoming message to an sql statement',1),(5117,'the ordertosql bean is shown in listing 7',1),(5118,'public class ordertosqlbean {    public string tosql(@xpath(\"order/@name\") string name,                        @xpath(\"order/@amount\") int amount,                        @xpath(\"order/@customer\") string customer) {        stringbuilder sb = new strin...',1),(5119,'append(\"insert into incoming_orders \");        sb',1),(5120,'append(\"(part_name, quantity, customer) values (\");        sb',1),(5121,'append(\"\', \");        sb',1),(5122,'append(\"\', \");        sb',1),(5123,'append(customer)',1),(5124,'append(\"\') \");        return sb',1),(5125,'tostring();    } }the ordertosql bean uses xpath to parse an incoming order message with a body something like this:<',1),(5126,'xml version=\"1',1),(5127,'> <order name=\"motor\" amount=\"1\" customer=\"honda\"/>the data in this order is then converted to an sql statement like this:insert into incoming_orders (part_name, quantity, customer) values (\'motor\', \'1\', \'honda\') this sql statement then becomes the b...',1),(5128,'in this case, you’re updating the database by inserting a new row',1),(5129,'so you won’t be expecting any result back',1),(5130,'but camel will set the cameljdbcupdatecount header to the number of rows updated',1),(5131,'if there were any problems running the sql command, an sqlexception would be thrown',1),(5132,'if you were running a query against the database (an sql select command), camel would return the rows as an arraylist<hashmap<string, object>>',1),(5133,'eachlisting 7',1),(5134,'8 a bean that converts an incoming order to an sql statement    www',1),(5135,'info224 chapter 7 understanding componentsentry in the arraylist is a hashmap that maps the column name to a column value',1),(5136,'camel would also set the cameljdbcrowcount header to the number of rows returned from the query',1),(5137,'to run this example for yourself, change to the chapter7/jdbc directory of the book’s source, and run the following command:mvn test -dtest=jdbctesthaving raw access to the database through jdbc is a must-have ability in any integration framework',1),(5138,'there are times, though, that you need to persist more than raw data—sometimes you need to persist whole java objects',1),(5139,'you can do this with the jpa component, which we’ll look at next',1),(5140,'2 persisting objects with the jpa componentthere is a new requirement at rider auto parts: instead of passing around xml order messages, management would like to adopt a pojo model for orders',1),(5141,'a first step would be to transform the incoming xml message into an equivalent pojo form',1),(5142,'in addition, the order persistence route in the accounting department would need to be updated to handle the new pojo body type',1),(5143,'you could manually extract the necessary information as you did for the xml message in listing 7',1),(5144,'8, but there is a better solution for persisting objects',1),(5145,'the java persistence architecture (jpa) is a wrapper layer on top of object-relational mapping (orm) products such as hibernate, openjpa, toplink, and the like',1),(5146,'these products map java objects to relational data in a database, which means you can save a java object in your database of choice, and load it up later when you need it',1),(5147,'this is a pretty powerful ability, and it hides many details',1),(5148,'because this adds quite a bit of complexity to your application, plain jdbc should be considered first to see if it meets your requirements',1),(5149,'to use the jpa component, you need to add the camel-jpa module to your project:<dependency>  <groupid>org',1),(5150,'camel</groupid>  <artifactid>camel-jpa</artifactid>  <version>2',1),(5151,'0</version> </dependency>you’ll also need to add jars for the orm product and database you’re using',1),(5152,'the examples in this section will use openjpa and the hypersql database, so you need the following dependencies as well:<dependency>  <groupid>org',1),(5153,'openjpa</groupid>  <artifactid>openjpa-persistence-jdbc</artifactid>  <version>1',1),(5154,'2</version> </dependency> <dependency>  <groupid>hsqldb</groupid>  <artifactid>hsqldb</artifactid>  <version>1',1),(5155,'7</version> </dependency>    www',1),(5156,'info225working with databases (jdbc and jpa components)the jpa component has a number of uri options, many of which can only be applied to either a consumer or producer endpoint',1),(5157,'the possible uri options are shown in table 7',1),(5158,'11 common uri options used to configure the jpa componentoptionconsumer/ producer modedefault valuedescriptionpersistenceunit both camel specifies the jpa persistence unit name used',1),(5159,'transactionmanager both null sets the transaction manager to be used',1),(5160,'if transactions are enabled and this property isn’t specified, camel will use a jpatransactionmanager',1),(5161,'for more on transactions, see chapter 9',1),(5162,'maximumresults consumer -1 specifies the maximum number of objects to be returned from a query',1),(5163,'the default of -1 means an unlimited number of results',1),(5164,'maxmessagesperpoll consumer 0 sets the maximum number of objects to be returned during a single poll',1),(5165,'the default of 0 means an unlimited number of results',1),(5166,'consumelockentity consumer true specifies whether the entities in the database will lock while they’re being consumed by camel',1),(5167,'consumedelete consumer true specifies whether the entity should be deleted in the database after it’s consumed',1),(5168,'consumer',1),(5169,'delay consumer 500 sets the delay in milliseconds between each poll',1),(5170,'consumer',1),(5171,'initialdelay consumer 1000 sets the initial delay in milliseconds before the first poll',1),(5172,'consumer',1),(5173,'query consumer sets the custom sql query to use when consuming objects',1),(5174,'consumer',1),(5175,'namedquery consumer references a named query to consume objects',1),(5176,'consumer',1),(5177,'nativequery consumer specifies a query in the native sql dialect of the database you’re using',1),(5178,'this isn’t very portable, but it allows you to take advantage of features specific to a particular database',1),(5179,'flushonsend producer causes objects that are sent to a jpa producer to be persisted to the underlying database immediately',1),(5180,'otherwise, they may stay in memory with the orm tool until it decides to persist',1),(5181,'info226 chapter 7 understanding componentsa requirement in jpa is to annotate any pojos that need to be persisted with the javax',1),(5182,'persistence',1),(5183,'the term entity is borrowed from relational database terminology and roughly translates to an object in object-oriented programming',1),(5184,'this means that your new pojo order class needs to have this annotation if you wish to persist it with jpa',1),(5185,'the new order pojo is shown in listing 7',1),(5186,'@entity                                                 public class purchaseorder implements serializable {    private string name;    private double amount;    private string customer;    public purchaseorder() {    }    public double getamount() {...',1),(5187,'amount = amount;    }    public string getname() {        return name;    }    public void setname(string name) {        this',1),(5188,'name = name;    }    public void setcustomer(string customer) {        this',1),(5189,'customer = customer;    }    public string getcustomer() {        return customer;    } }this pojo can be created from the incoming xml order message easily with a message translator, as shown in chapter 3',1),(5190,'for testing purposes, you can use a producer template to send a new purchaseorder to the accounting jms queue, like so:purchaseorder purchaseorder = new purchaseorder(); purchaseorder',1),(5191,'setname(\"motor\"); purchaseorder',1),(5192,'setamount(1); purchaseorder',1),(5193,'setcustomer(\"honda\"); template',1),(5194,'sendbody(\"jms:accounting\", purchaseorder);your route from section 7',1),(5195,'1 is now a bit simpler',1),(5196,'you send directly to the jpa endpoint after an order is received on the queue:from(\"jms:accounting\")',1),(5197,'purchaseorder\"); listing 7',1),(5198,'9 an annotated pojo representing an incoming orderrequired annotation for objects to be persisted    www',1),(5199,'info227working with databases (jdbc and jpa components)now that your route is in place, you have to configure the orm tool',1),(5200,'this is by far the most configuration you’ll have to do when using jpa with camel',1),(5201,'as we’ve mentioned, orm tools can be complex',1),(5202,'there are two main bits of configuration: hooking the orm tool’s entity manager up to camel’s jpa component, and configuring the orm tool to connect to your database',1),(5203,'for demonstration purposes here, we’ll be using apache openjpa, but you could use any other jpa-compliant orm tool',1),(5204,'the beans required to set up the openjpa entity manager are shown in listing 7',1),(5205,'<beans xmlns=\"http://www',1),(5206,'org/schema/beans\"    xmlns:xsi=\"http://www',1),(5207,'org/2001/xmlschema-instance\"    xsi:schemalocation=\"       http://www',1),(5208,'org/schema/beans       http://www',1),(5209,'org/schema/beans/spring-beans-3',1),(5210,'xsd\">  <bean id=\"jpa\"                                                     class=\"org',1),(5211,'jpacomponent\">    <property name=\"entitymanagerfactory\" ref=\"entitymanagerfactory\" />  </bean>  <bean id=\"entitymanagerfactory\"                     class=\"org',1),(5212,'localentitymanagerfactorybean\">    <property name=\"persistenceunitname\" value=\"camel\" />    <property name=\"jpavendoradapter\" ref=\"jpaadapter\" />  </bean>  <bean id=\"jpaadapter\"                                       class=\"org',1),(5213,'openjpavendoradapter\">    <property name=\"databaseplatform\"     value=\"org',1),(5214,'hsqldictionary\" />    <property name=\"database\" value=\"hsql\" />  </bean>  <bean id=\"transactiontemplate\"                              class=\"org',1),(5215,'transaction',1),(5216,'transactiontemplate\">    <property name=\"transactionmanager\">      <bean class=\"org',1),(5217,'jpatransactionmanager\">        <property name=\"entitymanagerfactory\" ref=\"entitymanagerfactory\" />      </bean>    </property>  </bean></beans>the spring beans file shown in listing 7',1),(5218,'10 does a number of things to set up jpa',1),(5219,'first off, it creates a camel jpacomponent and specifies the entity manager to be used b',1),(5220,'this entity manager c is then hooked up to openjpa and the hypersql order database d',1),(5221,'it also sets up the entity manager so it can participate in transactions e',1),(5222,'there is one more thing left to configure before jpa is up and running',1),(5223,'when the entity manager was created in listing 7',1),(5224,'10 c, you set the persistenceunitname to \"camel\"',1),(5225,'this persistence unit defines what entity classes will be persisted, as well as thelisting 7',1),(5226,'10 hooking up the camel jpa component to openjpahooks jpa component upto entity managerbcreates entity managercuses openjpa and hypersql databasedallows jpa component to participate in transactionse    www',1),(5227,'info228 chapter 7 understanding componentsconnection information for the underlying database',1),(5228,'in jpa, this configuration is stored in the persistence',1),(5229,'xml file in the meta-inf directory on the classpath',1),(5230,'listing 7',1),(5231,'11 shows the configuration required for your application',1),(5232,'<persistence xmlns=\"http://java',1),(5233,'com/xml/ns/persistence\"   xmlns:xsi=\"http://www',1),(5234,'org/2001/xmlschema-instance\" version=\"1',1),(5235,'0\">  <persistence-unit name=\"camel\" transaction-type=\"resource_local\">    <class>camelinaction',1),(5236,'purchaseorder</class>         <properties>      <property name=\"openjpa',1),(5237,'hsqldb',1),(5238,'connectionurl\" value=\"jdbc:hsqldb:mem:order\" />      <property name=\"openjpa',1),(5239,'connectionusername\" value=\"sa\" />      <property name=\"openjpa',1),(5240,'connectionpassword\" value=\"\" />      <property name=\"openjpa',1),(5241,'synchronizemappings\" value=\"buildschema\" />    </properties>  </persistence-unit> </persistence>there are two main things in listing 7',1),(5242,'first, classes that you need persisted need to be defined here b, and there can be more than one class element',1),(5243,'also, if you need to connect to another database or otherwise change the connection information to the database, you’ll need to do so here c',1),(5244,'now that all of the setup is complete, your jpa route is complete',1),(5245,'to try out this example, browse to the chapter7/jpa directory and run the jpatest test case with this maven command:mvn test -dtest=jpatestthis example sends a purchaseorder to the accounting queue and then queries the database to make sure the entit...',1),(5246,'manually querying the database via jpa is a useful ability, especially in testing',1),(5247,'in jpatest, the query was performed like so: jpaendpoint endpoint =   (jpaendpoint) context',1),(5248,'purchaseorder\"); jpatemplate = endpoint',1),(5249,'gettemplate();list list =   jpatemplate',1),(5250,'find(\"select x from camelinaction',1),(5251,'purchaseorder x\");assertequals(1, list',1),(5252,'size()); assertisinstanceof(purchaseorder',1),(5253,'class, list',1),(5254,'get(0));first off, you grab the instance of the jpatemplate on the jpaendpoint',1),(5255,'you then search for instances of your entity class in the database using jpql, which is similar to sql but deals with jpa entity objects instead of tables',1),(5256,'a simple check is then performed to make sure the object is the right type and that there is only one result',1),(5257,'listing 7',1),(5258,'11 configuring the orm tool with the persistence',1),(5259,'xml filelists entity classes to be persistedbprovides database connection informationc    www',1),(5260,'info229in-memory messaging (direct, seda, and vm components) now that we’ve covered accessing databases, and messaging that can span the entire web, we’re going to shift our attention to communication within the jvm',1),(5261,'7 in-memory messaging (direct, seda, and vm components)having braved so many of camel’s different messaging abilities in this chapter, you might think there couldn’t be more',1),(5262,'yet there is still another important messaging topic to cover: in-memory messaging',1),(5263,'camel provides three main components in the core to handle in-memory messaging',1),(5264,'for synchronous messaging, there is the direct component',1),(5265,'for asynchronous messaging, there are the seda and vm components',1),(5266,'the only difference between seda and vm is that the seda component can be used for communication within a single camelcontext, whereas the vm component is a bit broader and can be used for communication within a jvm',1),(5267,'if you have two camelcontexts loaded into an application server, you can send messages between them using the vm component',1),(5268,'note for more information on staged event-driven architecture (seda) in general, see matt welsh’s seda page at http://www',1),(5269,'edu/~mdw/ proj/seda/',1),(5270,'let’s look first at the direct component',1),(5271,'1 synchronous messaging with the direct componentthe direct component is about as simple as a component can get, but it’s extremely useful',1),(5272,'it’s probably the most common camel endpoint you’ll see in a route',1),(5273,'a direct endpoint uri looks like this:direct:endpointnamethere are no options that you can specify or backends to configure; there is just an endpoint name',1),(5274,'so what does this give you',1),(5275,'the direct component lets you make a synchronous call to a route or, conversely, expose a route as a synchronous service',1),(5276,'to demonstrate, say you have a route that’s exposed by a direct endpoint as follows:from(\"direct:startorder\")',1),(5277,'to(\"cxf:bean:orderendpoint\");sending a message to the direct:startorder endpoint will invoke a web service defined by the orderendpoint cxf endpoint bean',1),(5278,'let’s also say that you send a message to this endpoint using a producertemplate, as you saw in section 7',1),(5279,'requestbody(\"direct:startorder\", params, string',1),(5280,'class);the producertemplate will create a producer under the hood that sends to the direct:startorder endpoint',1),(5281,'in most other components, some processing happens in between the producer and the consumer',1),(5282,'for instance, in a jms component, the message could be sent to a queue on a jms broker',1),(5283,'info230 chapter 7 understanding componentsproducer directly calls the consumer',1),(5284,'and by directly, we mean that in the producer there is a method invocation on the consumer',1),(5285,'the only overhead of using the direct component is a method call',1),(5286,'this simplicity and minimal overhead make the direct component a great way of starting routes and synchronously breaking up routes into multiple pieces',1),(5287,'but even though there is little overhead to using the direct component, its synchronous nature doesn’t fit well with all applications',1),(5288,'if you need to operate asynchronously, you need the seda or vm components, which we’ll look at next',1),(5289,'2 asynchronous messaging with seda and vmas you saw in the discussion of jms earlier in the chapter (section 7',1),(5290,'3), there are many benefits to using message queuing as a means of sending messages',1),(5291,'you also saw how a routing application can be broken up into many logical pieces (routes) and connected by using jms queues as bridges',1),(5292,'but using jms for this purpose in an application on a single host adds unnecessary complexity for some use cases',1),(5293,'if you want to reap the benefits of asynchronous messaging but aren’t concerned with jms specification conformance or the built-in reliability that jms provides, you may want to consider an in-memory solution',1),(5294,'by ditching the specification conformance and any communications with a message broker (which can be costly), an inmemory solution can be much faster',1),(5295,'note that there is no message persistence to the disk, like in jms, so you run the risk of losing messages in the event of a crash—your application should be tolerant of losing messages',1),(5296,'camel provides two in-memory queuing components: seda and vm',1),(5297,'they both share the options listed in table 7',1),(5298,'12 common uri options used to configure the seda and vm componentsoption default value descriptionsize unbounded sets the maximum number of messages the queue can hold',1),(5299,'concurrentconsumers 1 sets the number of threads servicing incoming exchanges',1),(5300,'increase this number to process more exchanges concurrently',1),(5301,'waitfortasktocomplete ifreplyexpected specifies whether or not the client should wait for an asynchronous task to complete',1),(5302,'the default is to only wait if its an inout mep',1),(5303,'other values include always and never',1),(5304,'timeout 30000 sets the time in milliseconds to wait for an asynchronous send to complete',1),(5305,'a value less than or equal to 0 will disable the timeout',1),(5306,'multipleconsumers false specifies whether to allow the seda queue to have behavior like a jms topic (a publish-subscribe style of messaging)',1),(5307,'info231in-memory messaging (direct, seda, and vm components)one of the most common uses for seda queues in camel is to connect routes together to form a routing application',1),(5308,'for example, recall the example presented in 7',1),(5309,'1 where you used a jms topic to send copies of an incoming order to the accounting and production departments',1),(5310,'in that case, you used jms queues to connect your routes together',1),(5311,'because the only parts that are hosted on separate hosts are the accounting and production queues, you can use seda queues for everything else',1),(5312,'this new faster solution is illustrated in figure 7',1),(5313,'any jms messaging that you were doing within a camelcontext could be switched over to seda',1),(5314,'you still need to use jms for the accounting and production queues, because they’re located in physically separate departments',1),(5315,'you may have noticed that the jms xmlorders topic has been replaced with a seda queue in figure 7',1),(5316,'in order for this seda queue to behave like a jms topic (using a publish-subscribe messaging model), you need to set the multipleconsumers uri option to true, as shown in listing 7',1),(5317,'from(\"file:src/data',1),(5318,'to(\"seda:incomingorders\");        from(\"seda:incomingorders\")',1),(5319,'endswith(\"',1),(5320,'to(\"seda:xmlorders',1),(5321,'multipleconsumers=true\")',1),(5322,'*(csv|csl)$\"))',1),(5323,'to(\"seda:csvorders',1),(5324,'multipleconsumers=true\");  from(\"seda:xmlorders',1),(5325,'multipleconsumers=true\")',1),(5326,'to(\"jms:accounting\");                                from(\"seda:xmlorders',1),(5327,'multipleconsumers=true\")',1),(5328,'to(\"jms:production\");                           listing 7',1),(5329,'12 a topic allows multiple receivers to get a copy of the messageseda:xmlordersjms:accountingjms:productionseda:incomingorderscontent basedrouterseda:csvorders',1),(5330,'14  seda queues can be used as a low-overhead replacement for jms when messaging is within a camelcontext',1),(5331,'for messages being sent to other hosts, jms can be used',1),(5332,'in this case, all order routing is done via seda until the order needs to go to the accounting and production departments',1),(5333,'orders enter set of routes      both listening queues get copies    www',1),(5334,'info232 chapter 7 understanding componentsthis example behaves in the same way as the example in section 7',1),(5335,'1, except that it uses seda endpoints instead of jms',1),(5336,'another important detail in this listing is that seda endpoint uris that are reused in consumer and producer scenarios need to be exactly the same as each other',1),(5337,'it’s not enough to specify the correct seda queue name; you need to use the queue name and all options',1),(5338,'to run this example, go to the chapter7/seda directory in the book’s source, and run this command:mvn compile exec:java -dexec',1),(5339,'mainclass=camelinaction',1),(5340,'orderrouterthis will output the following on the command line:accounting received order: message1',1),(5341,'xmlproduction received order: message1',1),(5342,'xmlwhy did you get this output',1),(5343,'well, you had a single order file named message1',1),(5344,'xml, and it was published to the xmlorders topic',1),(5345,'both the accounting and production queues were subscribed to the topic, so each received a copy',1),(5346,'the testing routes consumed the messages on those queues and output the messages',1),(5347,'so far you’ve been kicking off routes either by hand or by consuming from a filesystem directory',1),(5348,'how can you kick off routes automatically',1),(5349,'or better yet, how can you schedule a route’s execution to occur',1),(5350,'8 automating tasks (timer and quartz components)often in enterprise projects you’ll need to schedule tasks to occur either at a specified time or at regular intervals',1),(5351,'camel supports this kind of service with the timer and quartz components',1),(5352,'the timer component is useful for simple recurring tasks, but when you need more control of when things get started, the quartz component is a must',1),(5353,'in this section, we’re first going to look at the timer component and then move on to the more advanced quartz component',1),(5354,'1 using the timer componentthe timer component comes with camel’s core library and uses the jre’s built-in timer mechanism to generate message exchanges at regular intervals',1),(5355,'this component only supports consuming, because sending to a timer doesn’t really make sense',1),(5356,'some common uri options are listed in table 7',1),(5357,'13 common uri options used to configure the timer componentoption default value descriptionperiod 1000 specifies the time in milliseconds between generated events',1),(5358,'delay 0 specifies the time in milliseconds before the first event is generated',1),(5359,'fixedrate false specifies whether to create events at a fixed rate based on the period',1),(5360,'daemon true sets the timer thread to run as a daemon',1),(5361,'info233automating tasks (timer and quartz components)as an example, let’s print a message stating the time to the console every 2 seconds',1),(5362,'the route looks like this:from(\"timer://mytimer',1),(5363,'simple(\"current time is ${header',1),(5364,'to(\"stream:out\");the timer uri is configuring the underlying java',1),(5365,'timer to have the name mytimer and an execution interval of 2000 milliseconds',1),(5366,'tip when the value of milliseconds gets large, you can opt for a shorter notation using the s, m, and h keywords',1),(5367,'for example, 2000 milliseconds can be written as 2s, meaning 2 seconds',1),(5368,'90000 milliseconds can be written as 1m30s, and so on',1),(5369,'when this timer fires an event, camel creates an exchange with an empty body and sends it along the route',1),(5370,'in this case, you’re setting the body of the message using a simple language expression',1),(5371,'the firedtime header was set by the timer component; for a full list of headers set, see the online documentation (http://camel',1),(5372,'note the timer object and corresponding thread can be shared',1),(5373,'if you use the same timer name in another route, it will reuse the same timer object',1),(5374,'you can run this simple example by changing to the chapter7/timer directory of the book’s source and running this command:mvn compile exec:java -dexec',1),(5375,'mainclass=camelinaction',1),(5376,'timerexampleyou’ll see output similar to the following:current time is wed feb 10 00:43:31 nst 2010current time is wed feb 10 00:43:33 nst 2010 current time is wed feb 10 00:43:35 nst 2010as you can see, an event was fired every 2 seconds',1),(5377,'but suppose you wanted to schedule a route to execute on the first day of each month',1),(5378,'you couldn’t do this easily with the timer component',1),(5379,'2 enterprise scheduling with quartzlike the timer component, the quartz component allows you to schedule the generation of message exchanges',1),(5380,'but the quartz component gives you much more control over how this scheduling happens',1),(5381,'you can also take advantage of quartz’s many other enterprise features',1),(5382,'we won’t be covering all of quartz’s features here—only ones exposed directly in camel',1),(5383,'for a complete look at how to use quartz, please see the quartz website: http://www',1),(5384,'quartz-scheduler',1),(5385,'the common uri options for the quartz component are listed in table 7',1),(5386,'info234 chapter 7 understanding componentsbefore you can use the quartz component, you’ll need to add the following dependency to your maven pom file:<dependency>  <groupid>org',1),(5387,'camel</groupid>  <artifactid>camel-quartz</artifactid>  <version>2',1),(5388,'0</version> </dependency>let’s now reproduce the timer example from the previous section with quartz',1),(5389,'to do this, you can use the trigger',1),(5390,'repeatinterval option, which is similar to the period option for the timer component',1),(5391,'the route looks like this:from(\"quartz://mytimer',1),(5392,'simple(\"current time is ${header',1),(5393,'to(\"stream:out\");although this behaves in the same way as the timer example, there are a few different things going on under the covers',1),(5394,'first off, mytimer sets the underlying trigger object’s name',1),(5395,'timers in quartz are made up of a trigger and a jobdetail',1),(5396,'triggers can also have a group name associated with them, which you can specify by adding the group name to your uri, as follows:quartz://mygroupname/mytimer',1),(5397,'if the group name is omitted, as in the previous route, “camel” is used as the group name',1),(5398,'by default, a simpletrigger is created to schedule events',1),(5399,'repeatcount properties configured this trigger to fire every 2000 milliseconds for as long as the application is running (a repeat count of -1 causes the trigger to repeat indefinitely)',1),(5400,'you may be thinking that the option names are a bit long, but there is a reason for this',1),(5401,'as stated in table 7',1),(5402,'14, options starting with trigger allow you to set properties on the trigger object',1),(5403,'14 common uri options used to configure the quartz componentoption default value descriptioncron none specifies a cron expression used to determine when the timer fires',1),(5404,'repeatcount 0 specifies the number of times to repeat the trigger',1),(5405,'a value of -1 causes the timer to repeat indefinitely',1),(5406,'repeatinterval 0 specifies the interval in milliseconds at which to generate events',1),(5407,'propertyname null sets the property with name propertyname on the underlying quartz jobdetail',1),(5408,'propertyname null sets the property with name propertyname on the underlying quartz trigger',1),(5409,'info235summary and best practicescase of the trigger',1),(5410,'repeatinterval uri option, this will call the setrepeatinterval method on the simpletrigger object',1),(5411,'you can similarly set options on the jobdetail by using properties that start with job, followed by a valid property name',1),(5412,'for instance, you can set the job name by using the job',1),(5413,'using cron triggersso far, you’ve replaced the timer component example with a functionally equivalent quartz-based example',1),(5414,'how would you schedule something more complex, like kicking off a route on the first day of each month',1),(5415,'the answer is by using cron expressions',1),(5416,'readers familiar with linux or unix will probably have heard of the cron scheduling application',1),(5417,'quartz allows you to use scheduling syntax similar to the venerable cron application',1),(5418,'a cron expression is a string consisting of 6–7 fields separated by white space',1),(5419,'each field denotes a date or range of dates',1),(5420,'the structure of a cron expression is as follows:<seconds> <minutes> <hours> <day of month> <month> <day of week> <year>these accept numeric values (and optional textual ones) for the times you want a trigger to fire',1),(5421,'more information on cron expressions can be found on the quartz website (http://www',1),(5422,'quartz-scheduler',1),(5423,'org/docs/tutorials/crontrigger',1),(5424,'the cron expression for occurring on the first day of each month at 6:00 a',1),(5425,'is the following:  0 0 6 1 *',1),(5426,'in this expression, the third digit denotes the hour at which to execute, and the fourth digit is the day of the month',1),(5427,'you can also see that a star was placed in the month column so that every month would be triggered',1),(5428,'setting up quartz to use cron triggers in camel is easy',1),(5429,'you just need to use the cron option and make sure to replace all white space with plus characters (+)',1),(5430,'your uri becomes the following:quartz://firstdayofthemonth',1),(5431,'cron=0+0+6+1+*+',1),(5432,'using this uri in a route will cause a message exchange to be generated (running the route) on the first day of each month',1),(5433,'you should be able to see now how the scheduling components in camel can allow you to execute routes at specified times',1),(5434,'this is an important ability in time-sensitive enterprise applications',1),(5435,'9 summary and best practicescongratulations on making it through the barrage of components we covered in this chapter',1),(5436,'by now, you should have a good understanding of how to use them in your own applications',1),(5437,'here are some of the key ideas you should take away from this chapter:    www',1),(5438,'info236 chapter 7 understanding components■ there are tons of camel components',1),(5439,'one of the great things about camel is its extensive component library',1),(5440,'you can rest easy knowing that most things you’ll ever need to connect to are covered by camel',1),(5441,'■ the camel website has documentation on all components available',1),(5442,'we could only cover the most widely used and important components in this book, so you should be aware that if you need to use one of the many other components, documentation is available at http://camel',1),(5443,'■ camel’s component model allows for your own extensions',1),(5444,'we briefly touched on how components are resolved at runtime in camel',1),(5445,'camel imposes no restrictions on where your components come from, so you can easily write your own (as described in chapter 11) and include it in your camel application',1),(5446,'■ don’t write to files manually; use the file and ftp components',1),(5447,'camel’s file and ftp components have many options that will suit most file-processing scenarios',1),(5448,'don’t reinvent the wheel—use what camel has to offer',1),(5449,'■ use the jms component for asynchronous messaging with jms',1),(5450,'camel makes it easy to send messages to and receive them from jms providers',1),(5451,'you will no longer have to write dozens of lines of jms api calls to send or receive a simple message',1),(5452,'■ use the cxf component for all your web services needs',1),(5453,'the cxf component allows you to make calls to a variety of web service types or to expose your camel route to the world as a web service',1),(5454,'■ use the mina component for network communications',1),(5455,'network programming can be difficult, given the low-level concepts you need to deal with',1),(5456,'the mina component handles these details for you, making it easy to communicate over network protocols such as tcp and udp',1),(5457,'■ hook your routes into databases using the jdbc and jpa components',1),(5458,'the jdbc component allows you to access databases using tried-and-true sql, whereas the jpa component is all about persisting java objects into databases',1),(5459,'■ use in-memory messaging when reliability isn’t a concern but speed is',1),(5460,'camel provides three choices for in-memory messaging: the direct, seda, and vm components',1),(5461,'■ kick off routes at specified intervals using the quartz or timer components',1),(5462,'camel routes can do useful things',1),(5463,'some tasks need to be executed at specified intervals, and the quartz and timer components come into play here',1),(5464,'components in camel fill the role of bridging out to other transports, apis, and data formats',1),(5465,'they’re also the on and off ramps to camel’s routing abilities',1),(5466,'back in chapter 2, you were exposed to some of camel’s routing capabilities by using some standard eips',1),(5467,'in the next chapter, we’ll look at some of the more complex eips available in camel',1),(5468,'unlike when you read chapter 2, you’re now armed with the knowledge of how to connect to many different services with camel',1),(5469,'keep your knowledge of components handy—you can think up some interesting integration scenarios',1),(5470,'info237enterprise integration patternstoday’s businesses aren’t run on a single monolithic system, and most businesses have a full range of disparate systems',1),(5471,'there is an ever-increasing demand for those systems to integrate with each other and with external business partners and government systems',1),(5472,'let’s face it, integration is hard',1),(5473,'to help deal with the complexity of integration problems, enterprise integration patterns (eips) have become the standard way to describe, document, and implement complex integration problems',1),(5474,'we explain the patterns we discuss in this book, but to learn more about them and others, see the enterprise integration patterns website and the associated book: http:// www',1),(5475,'enterpriseintegrationpatterns',1),(5476,'this chapter covers■ the aggregator eip■ the splitter eip■ the routing slip eip■ the dynamic router eip■ the load balancer eip    www',1),(5477,'info238 chapter 8 enterprise integration patterns8',1),(5478,'1 introducing enterprise integration patternsapache camel implements eips, and because the eips are essential building blocks in the camel routes, you’ll bump into eips throughout this book, starting in chapter 2',1),(5479,'it would be impossible for this book to cover all the eips camel supports, which currently total around 60 patterns',1),(5480,'this chapter is devoted to covering five of the most powerful and feature-rich patterns',1),(5481,'the patterns discussed in this chapter are listed in table 8',1),(5482,'let’s look at these patterns in a bit more detail',1),(5483,'1 the aggregator and splitter eips  the first two patterns listed in table 8',1),(5484,'the splitter can split out a single message into multiple submessages, and the aggregator can combine those submessages back into a single message',1),(5485,'they’re opposite patterns',1),(5486,'the eips allow you to build patterns lego style, which means that patterns can be combined together to form new patterns',1),(5487,'for example, you can combine the splitter and the aggregator into what is known as the composed message processor eip, as illustrated in figure 8',1),(5488,'1 eips covered in this chapterpattern summaryaggregator used to combine results of individual but related messages into a single outgoing message',1),(5489,'you can view this as the reverse of the splitter pattern',1),(5490,'this pattern is covered in section 8',1),(5491,'splitter used to split a message into pieces that are routed separately',1),(5492,'this pattern is covered in section 8',1),(5493,'routing slip used to route a message in a series of steps, where the sequence of steps isn’t known at design time and may vary for each message',1),(5494,'this pattern is covered in section 8',1),(5495,'dynamic router used to route messages with a dynamic router dictating where the message goes',1),(5496,'this pattern is covered in section 8',1),(5497,'load balancer used to balance the load to a given endpoint using a variety of different balancing policies',1),(5498,'this pattern is covered in section 8',1),(5499,'splitter router aggregatornewordervalidatedordergadget inventorywidget inventorycomposed message processor eipfigure 8',1),(5500,'1 the composed message processor eip splits up the message, routes the submessages to the appropriate destinations, and re-aggregates the response back into a single message',1),(5501,'info239the aggregator eipthe aggregator eip is likely the most sophisticated and most advanced eip implemented in camel',1),(5502,'it has many use cases, such as aggregating incoming bids for auctions or throttling stock quotes',1),(5503,'2 the routing slip and dynamic router eipsa question that is often asked on the camel mailing list is how to route messages dynamically',1),(5504,'the answer is to use eips such as recipient list, routing slip, and dynamic router',1),(5505,'we covered recipient list in chapter 2, and in this chapter we’ll show you how to use the routing slip and dynamic router patterns',1),(5506,'3 the load balancer eip the eip book doesn’t list the load balancer, which is a pattern implemented in camel',1),(5507,'suppose you route pdf messages to network printers, and those printers come and go online',1),(5508,'you can use the load balancer to send the pdf messages to another printer if one printer is unresponsive',1),(5509,'that covers the five eips we’ll cover in this chapter',1),(5510,'it’s now time to look at the first one in detail, the aggregator eip',1),(5511,'2 the aggregator eipthe aggregator eip is important and complex, so we’ll cover it well',1),(5512,'don’t despair if you don’t understand the pattern in the first few pages',1),(5513,'the aggregator combines many related incoming messages into a single aggregated message, as illustrated in figure 8',1),(5514,'the aggregator receives a stream of messages and identifies messages that are related, which are then aggregated into a single combined message',1),(5515,'once a completionaggregatoremessage1emessage2emessage3daggregatedmessagefigure 8',1),(5516,'2 the aggregator stores incoming messages until it receives a complete set of related messages',1),(5517,'then the aggregator publishes a single message distilled from the individual messages',1),(5518,'example uses of aggregatorthe aggregator eip supports many use cases, such as the loan broker example from the eip book, where brokers send loan requests to multiple banks and aggregate the replies to determine the best deal',1),(5519,'you could also use the aggregator in an auction system to aggregate current bids',1),(5520,'also imagine a stock market system that continuously receives a stream of stock quotes, and you want to throttle this to publish the latest quote every 5 seconds',1),(5521,'this can be done using the aggregator to choose the latest message and thus trigger a completion every 5 seconds',1),(5522,'info240 chapter 8 enterprise integration patternscondition occurs, the aggregated message is sent to the output channel for further processing',1),(5523,'we’ll cover how this process works in detail in the next section',1),(5524,'when using the aggregator, you have to pay attention to the following three configuration settings, which must be configured',1),(5525,'failure to do so will cause camel to fail on startup and to report an error regarding the missing configuration',1),(5526,'■ correlation identifier—an expression that determines which incoming messages belong together■ completion condition—a predicate or time-based condition that determines when the result message should be sent■ aggregation strategy—an aggregationstrate...',1),(5527,'this will keep things simple, making it easier to follow what’s going on',1),(5528,'the aggregator is equally equipped to work with big loads, but that can wait until we’ve covered the basic principles',1),(5529,'1 introducing the aggregator eipsuppose you want to collect any three messages together and combine them together',1),(5530,'given three messages containing a, b, and c, you want the aggregator to output a single message containing “abc”',1),(5531,'3 shows how this would work',1),(5532,'when the first message with correlation identifier 1 arrives, the aggregator initializes a new aggregate and stores the message inside the aggregate',1),(5533,'in this example, the completion condition is when three messages have been aggregated, so the aggregate isn’t yet complete',1),(5534,'when the second message with correlation identifier 1 arrives, the eip adds it to the already existing aggregate',1),(5535,'the third message specifies a different correlation identifier value of 2, so the aggregator starts a new aggregate for that value',1),(5536,'the fourth message relates to the first aggregate (identifier 1), so the aggregate has now aggregated three messages and the completion condition is fulfilled',1),(5537,'as a result, the aggregator marks the aggregate as complete and publishes the resulting message:1a1b2f1cincomingmessagescorrelationidentifermessagebodyaggregates1 a 1 a b2 f1 a b 1 a b c2 f1abcpublishedmessagesfigure 8',1),(5538,'3 illustrates the aggregator eip in action, with partial aggregated messages updated with arriving messages',1),(5539,'info241the aggregator eipas mentioned before, there are three configurations in play when using the aggregator eip: correlation identifier, completion condition, and aggregation strategy',1),(5540,'to understand how these three are specified and how they work, let’s start with the example of a camel route in the java dsl (with the configurations in bold):public void configure() throws exception {    from(\"direct:start\")',1),(5541,'to(\"mock:result\");the correlation identifier is header(\"myid\"), and it’s a camel expression',1),(5542,'it returns the header with the key \"myid\"',1),(5543,'the second configuration element is the aggregationstrategy, which is a class',1),(5544,'we’ll cover this class in more detail in a moment',1),(5545,'finally, the completion condition is based on size (there are five kinds of completion conditions, listed in table 8',1),(5546,'it simply states that when three messages have been aggregated, the completion should trigger',1),(5547,'the same example in spring xml is as follows:<bean id=\"myaggregationstrategy\"      class=\"camelinaction',1),(5548,'myaggregationstrategy\"/><camelcontext xmlns=\"http://camel',1),(5549,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>        <log message=\"sending ${body} with key ${header',1),(5550,'myid}\"/>        <aggregate strategyref=\"myaggregationstrategy\" completionsize=\"3\">            <correlationexpression>                <header>myid</header>            </correlationexpression>            <log message=\"sending out ${body}\"/>            ...',1),(5551,'this refers to a spring <bean>, which is listed in the top of the spring xml file',1),(5552,'the completion condition is also defined as a completionsize attribute',1),(5553,'the most noticeable difference is how the correlation identifier is defined',1),(5554,'in spring xml, it is defined using the <correlationexpression> tag, which has a child tag that includes the expression',1),(5555,'the source code for the book contains this example in the chapter8/aggregator directory',1),(5556,'you can run the examples using the following maven goals:mvn test -dtest=aggregateabctest mvn test -dtest=springaggregateabctestthe examples use the following unit test method:    www',1),(5557,'info242 chapter 8 enterprise integration patternspublic void testabc() throws exception {    mockendpoint mock = getmockendpoint(\"mock:result\");    mock',1),(5558,'expectedbodiesreceived(\"abc\");    template',1),(5559,'sendbodyandheader(\"direct:start\", \"a\", \"myid\", 1);    template',1),(5560,'sendbodyandheader(\"direct:start\", \"b\", \"myid\", 1);    template',1),(5561,'sendbodyandheader(\"direct:start\", \"f\", \"myid\", 2);    template',1),(5562,'sendbodyandheader(\"direct:start\", \"c\", \"myid\", 1);    assertmockendpointssatisfied(); }this unit test sends the same messages as shown in figure 8',1),(5563,'3—four messages in total',1),(5564,'when you run the test, you will see the output on the console:info route1 - sending a with correlation key 1info route1 - sending b with correlation key 1 info route1 - sending f with correlation key 2 info route1 - sending c with correlation key 1 i...',1),(5565,'as you can see from the console output, the messages with correlation key 1 were completed, because they met the completion condition, which was size based on three messages',1),(5566,'the last line of the output shows the published message, which contains the letters “abc',1),(5567,'” so what happens with the f message',1),(5568,'well, its completion condition has not been met, so it waits in the aggregator',1),(5569,'you could modify the test method to send in additional two messages to complete that second group as well:template',1),(5570,'sendbodyandheader(\"direct:start\", \"g\", \"myid\", 2); template',1),(5571,'sendbodyandheader(\"direct:start\", \"h\", \"myid\", 2);let’s now turn our focus to how the aggregator eip combines the messages, which causes the a, b, and c messages to be published as a single message',1),(5572,'this is where the aggregationstrategy comes into the picture, because it orchestrates this',1),(5573,'using aggregationstrategythe aggregationstrategy class is located in the org',1),(5574,'processor',1),(5575,'aggregation package, and it defines a single method:public interface aggregationstrategy {    exchange aggregate(exchange oldexchange, exchange newexchange); }if you are having a déjà vu moment, its most likely because aggregationstrategy is also use...',1),(5576,'listing 8',1),(5577,'1 shows the strategy used in the previous example',1),(5578,'processor',1),(5579,'aggregationstrategy;public class myaggregationstrategy implements aggregationstrategy {    public exchange aggregate(exchange oldexchange, exchange newexchange) {        if (oldexchange == null) {listing 8',1),(5580,'1 aggregationstrategy for merging messages together    www',1),(5581,'class);             string newbody = newexchange',1),(5582,'class);        string body = oldbody + newbody;                    oldexchange',1),(5583,'setbody(body);        return oldexchange;    }  }at runtime, the aggregate method is invoked every time a new message arrives',1),(5584,'in this example, it will be invoked four times: one for each arriving message a, b, f, and c',1),(5585,'to show how this works, we’ve listed the invocations as they would happen, in table 8',1),(5586,'2 that the oldexchange parameter is null on two occasions',1),(5587,'this occurs when a new correlation group is formed (no preexisting messages have arrived with the same correlation identifier)',1),(5588,'in this situation, you simply want to return the message as is, because there are no other messages to combine it with b',1),(5589,'on the subsequent aggregations, neither parameter is null so you need to merge the data into one exchange',1),(5590,'in this example, you grab the message bodies and add them together c',1),(5591,'then you replace the existing body in the oldexchange with the updated body',1),(5592,'note the aggregator eip uses synchronization, which ensures that the aggregationstrategy is thread safe—only one thread is invoking the aggregate method at any time',1),(5593,'the aggregator also ensures ordering, which means the messages are aggregated in the same order as they are sent into the aggregator',1),(5594,'you should now understand the principles of how the aggregator works',1),(5595,'for a message to be published from the aggregator, a completion condition must have been met',1),(5596,'in the next section, we’ll discuss this and review the different conditions camel provides out of the box',1),(5597,'2 completion conditions for the aggregatorcompletion conditions play a bigger role in the aggregator than you might think',1),(5598,'imagine a situation where a condition never occurs, causing aggregated messagestable 8',1),(5599,'2 sequence of invocations of aggregate method occurring at runtimearrived oldexchange newexchange descriptiona null a the first message arrives for the first groupb a b the second messages arrives for the first groupf null f the first message arrives...',1),(5600,'info244 chapter 8 enterprise integration patternsnever to be published',1),(5601,'for example, suppose the c message never arrived in the example in section 8',1),(5602,'to remedy this, you could add a timeout condition that would react if all messages aren’t received within a certain time period',1),(5603,'to cater for that situation and others, camel provides five different completion conditions, which are listed in table 8',1),(5604,'the aggregator supports using multiple completion conditions, such as using both the completionsize and completiontimeout conditions',1),(5605,'when using multiple conditions, though, the winner takes all—the completion condition that completes first will result in the message being published',1),(5606,'note the source code for the book contains examples in the chapter8/ aggregator directory for all conditions; you can refer to them for further details',1),(5607,'also the aggregator documentation on the camel website has more details: http://camel',1),(5608,'3 different kinds of completion conditions provided by the aggregator eipcondition descriptioncompletionsize defines a completion condition based on the number of messages aggregated together',1),(5609,'you can either use a fixed value (int) or use an expression to dynamically decide a size at runtime',1),(5610,'completiontimeout defines a completion condition based on an inactivity timeout',1),(5611,'this condition triggers if a correlation group has been inactive longer than the specified period',1),(5612,'timeouts are scheduled for each correlation group, so the timeout is individual to each group',1),(5613,'you can either use a fixed value (long) or use an expression to dynamically decide a timeout at runtime',1),(5614,'the period is defined in milliseconds',1),(5615,'you can’t use this condition together with the completioninterval',1),(5616,'completioninterval defines a completion condition based on a scheduled interval',1),(5617,'this condition triggers periodically',1),(5618,'there is a single scheduled timeout for all correlation groups, which causes all groups to complete at the same time',1),(5619,'the period (long) is defined in milliseconds',1),(5620,'you can’t use this condition together with the completiontimeout',1),(5621,'completionpredicate defines a completion condition based on whether the predicate matched',1),(5622,'see also the eagercheckcompletion option in table 8',1),(5623,'completionfrombatchconsumer defines a completion condition that is only applicable when the arriving exchanges are coming from a batchconsumer (http://camel',1),(5624,'org/batch-consumer',1),(5625,'at the time of writing, the following components support this condition: file, ftp, mail, ibatis, and jpa',1),(5626,'info245the aggregator eipwe’ll now look at how you can use multiple completion conditions',1),(5627,'using multiple completion conditionsthe source code for this book contains an example in the chapter8/aggregator directory showing how to use multiple completion conditions',1),(5628,'you can run the example using the following maven goals:mvn test -dtest=aggregatexmltest mvn test -dtest=springaggregatexmltestthe route in the java dsl is as follows:import static org',1),(5629,'xpath;public void configure() throws exception {    from(\"direct:start\")',1),(5630,'aggregate(xpath(\"/order/@customer\"), new myaggregationstrategy())',1),(5631,'to(\"mock:result\"); }as you can see from the bold code in the route, using a second condition is just a matter of adding an additional completion condition',1),(5632,'the same example in spring xml is shown here:<bean id=\"myaggregationstrategy\"      class=\"camelinaction',1),(5633,'myaggregationstrategy\"/><camelcontext xmlns=\"http://camel',1),(5634,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>        <log message=\"sending ${body}\"/>        <aggregate strategyref=\"myaggregationstrategy\"                   completionsize=\"2\" completiontimeout=\"5000\">            <correlationexpre...',1),(5635,'expectedmessagecount(2);    template',1),(5636,'sendbody(\"direct:start\",        \"<order name=\\\"motor\\\" amount=\\\"1000\\\" customer=\\\"honda\\\"/>\");    template',1),(5637,'sendbody(\"direct:start\",        \"<order name=\\\"motor\\\" amount=\\\"500\\\" customer=\\\"toyota\\\"/>\");    template',1),(5638,'sendbody(\"direct:start\",    www',1),(5639,'info246 chapter 8 enterprise integration patterns        \"<order name=\\\"gearbox\\\" amount=\\\"200\\\" customer=\\\"toyota\\\"/>\");    assertmockendpointssatisfied(); }this example should cause the aggregator to publish two outgoing messages, as shown in the f...',1),(5640,'09:37:35 - sending <order name=\"motor\" amount=\"1000\" customer=\"honda\"/> 09:37:35 - sending <order name=\"motor\" amount=\"500\" customer=\"toyota\"/> 09:37:35 - sending <order name=\"gearbox\" amount=\"200\" customer=\"toyota\"/> 09:37:35 - sending out          ...',1),(5641,'this is because its completion was triggered by the timeout, which was set to 5 seconds',1),(5642,'in the meantime, the toyota order had its completion triggered by the size of two messages, so it was published first',1),(5643,'tip the aggregator eip allows you to use up to four completion conditions; the completiontimeout and completioninterval conditions can’t be used at the same time',1),(5644,'using multiple completion conditions makes good sense if you want to ensure that aggregated messages eventually get published',1),(5645,'for example, the timeout condition ensures that after a period of inactivity the message will be published',1),(5646,'in that regard, you can use the timeout condition as a fallback condition, with the price being that the published message will only be partly aggregated',1),(5647,'suppose you expected two messages to be aggregated into one, but you only received one message; the next section reveals how you can tell which condition triggered the completion',1),(5648,'aggregated exchange propertiescamel enriches the published exchange with the completion details listed in table 8',1),(5649,'4 properties on the exchange related to aggregationproperty type descriptionexchange',1),(5650,'aggregatedsizeinteger the total number of arrived messages aggregated',1),(5651,'possible values are \"size\", \"timeout\", \"interval\", \"predicate\", and \"consumer\"',1),(5652,'the \"consumer\" value represents the completion from batch consumer',1),(5653,'aggregatedcorrelation keystring the correlation identifier as a string',1),(5654,'info247the aggregator eipthe information listed in table 8',1),(5655,'4 allows you to know how a published aggregated exchange was completed, and how many messages were combined',1),(5656,'for example, you could log to the console which condition completed, simply by adding this to the camel route:',1),(5657,'camelaggregatedcompletedby}\")this information might come in handy in your business logic, when you need to know whether or not all messages were aggregated',1),(5658,'you can tell this by checking the aggregated_completed_by property, which could contain either the value \"size\" or \"timeout\"',1),(5659,'if the value is \"size\", all the messages were aggregated; if the value is \"timeout\", a timeout occurred, and not all expected message were aggregated',1),(5660,'the aggregator has additional configuration options that you may need to use',1),(5661,'for example, you can specify how it should react when an arrived message contains an invalid correlation identifier',1),(5662,'additional configuration optionsthe aggregator is the most sophisticated eip implemented in camel, and table 8',1),(5663,'5 lists the additional configuration options you can use to tweak it to fit your needs',1),(5664,'5 additional configuration options available for the aggregator eipconfiguration option default descriptioneagercheckcompletion false this option specifies whether or not to eagercheck for completion',1),(5665,'eager checking means camel will check for completion conditions before aggregating',1),(5666,'this option is used to control how the completion-predicate condition behaves',1),(5667,'if the option is false, the completion predicate will use the aggregated exchange for evaluation',1),(5668,'if true, the incoming exchange is used for evaluation',1),(5669,'closecorrelationkeyoncompletionnull this option determines whether a given correlation group should be marked as closed when it’s completed',1),(5670,'if a correlation group is closed, any subsequent arriving exchanges are rejected and a closedcorrelationkeyexceptionis thrown',1),(5671,'this option uses an integer parameter that represents a maximum bound for a least recently used (lru) cache, which keeps track of closed correlation keys',1),(5672,'note that this cache is inmemory only and will be reset if camel is restarted',1),(5673,'info248 chapter 8 enterprise integration patternsif you want to learn more about the configuration options listed in table 8',1),(5674,'5, there are examples for each option in the source code for the book in the chapter8/aggregator directory',1),(5675,'you can run test examples using the following maven goals:mvn test -dtest=aggregateabceagertest mvn test -dtest=springaggregateabceagertest mvn test -dtest=aggregateabcclosetest mvn test -dtest=springaggregateabcclosetest mvn test -dtest=aggregateabc...',1),(5676,'the aggregator, by default, uses an in-memory repository to hold the current in-progress aggregated messages, and those messages will be lost if the application is stopped or the server crashes',1),(5677,'to remedy this, you need to use a persisted repository',1),(5678,'3 using persistence with the aggregatorthe aggregator is a stateful eip because it needs to store the in-progress aggregates until completion conditions occur and the aggregated message can be published',1),(5679,'by default, the aggregator will keep state in memory only',1),(5680,'if the application is shut down or the host container crashes, the state will be lost',1),(5681,'to remedy this problem, you need to store the state in a persistent repository',1),(5682,'camel provides a pluggable feature so you can use a repository of your choice',1),(5683,'this comes in two flavors:■ aggregationrepository—an interface that defines the general operations for working with a repository, such as adding data to and removing data from it',1),(5684,'by default, camel uses memoryaggregationrepository, which is a memoryonly repository',1),(5685,'ignoreinvalidcorrelationkeysfalse this option specifies whether or not to ignore invalid correlation keys',1),(5686,'by default, camel throws a camelexchange-exception for invalid keys',1),(5687,'you can suppress this by setting this option to true, in which case camel skips the invalid message',1),(5688,'groupexchanges false this option is used for grouping arriving exchanges into a single combined exchangeholder that contains the exchanges',1),(5689,'if it’s enabled, you should not configure an aggregationstrategy',1),(5690,'5 additional configuration options available for the aggregator eip (continued)configuration option default description    www',1),(5691,'info249the aggregator eip■ recoverableaggregationrepository—an interface that defines additional operations supporting recovery',1),(5692,'camel provides such a repository out of the box in the camel-hawtdb component',1),(5693,'we’ll cover recovery in section 8',1),(5694,'we’ll look at how you can use hawtdb as a persistent repository',1),(5695,'using camel-hawtdbto demonstrate how to use hawtdb with the aggregator, we’ll return to the abc example',1),(5696,'in essence, all you need to do is instruct the aggregator to use hawtdbaggregationrepository as its repository',1),(5697,'first, though, you must set up hawtdb, which is done as follows:aggregationrepository myrepo = new    hawtdbaggregationrepository(\"myrepo\", \"data/myrepo',1),(5698,'dat\");or, in spring xml you would do this:<bean id=\"myrepo    class=\"org',1),(5699,'hawtdbaggregationrepository\">    <property name=\"repositoryname\" value=\"myrepo\"/>    <property name=\"persistentfilename\" value=\"data/myrepo',1),(5700,'dat\"/> </bean>as you can see, this creates a new instance of hawtdbaggregationrepository and provides two parameters: the repository name, which is a symbolic name, and the physical filename to use as persistent storage',1),(5701,'the repository name must be specified because you can have multiple repositories in the same file',1),(5702,'tip you can find information about the additional supported options for the hawtdb component at the camel website: http://camel',1),(5703,'org/hawtdbto use hawtdbaggregationrepository in the camel route, you can instruct the aggregator to use it as shown here',1),(5704,'aggregationrepository myrepo = new    hawtdbaggregationrepository(\"myrepo\", \"data/myrepo',1),(5705,'log(\"consuming ${file:name}\")listing 8',1),(5706,'2 using hawtdb with aggregator in java dslabout hawtdbhawtdb is a lightweight and embeddable file-based key/value database',1),(5707,'it allows camel to provide persistence for various camel features, such as the aggregator',1),(5708,'in the future, other camel features will leverage hawtdb',1),(5709,'you can find more information about hawtdb at its website: http:// hawtdb',1),(5710,'fusesource',1),(5711,'info250 chapter 8 enterprise integration patterns',1),(5712,'aggregate(constant(true), new myaggregationstrategy())',1),(5713,'aggregationrepository(myrepo)',1),(5714,'to(\"mock:result\");here’s the same example in spring xml',1),(5715,'<bean id=\"myaggregationstrategy\"      class=\"camelinaction',1),(5716,'myaggregationstrategy\"/><bean id=\"myrepo                                            class=\"org',1),(5717,'hawtdbaggregationrepository\">    <property name=\"repositoryname\" value=\"myrepo\"/>    <property name=\"persistentfilename\" value=\"data/myrepo',1),(5718,'dat\"/> </bean><camelcontext xmlns=\"http://camel',1),(5719,'org/schema/spring\">    <route>        <from uri=\"file://target/inbox\"/>        <log message=\"consuming ${file:name}\"/>        <aggregate strategyref=\"myaggregationstrategy\" completionsize=\"3\"                    aggregationrepositoryref=\"myrepo\">     ...',1),(5720,'3, a spring bean tag is defined with the id \"myrepo\" b, which sets up the persistent aggregationrepository',1),(5721,'the name for the repository and the filename are configured as properties on the bean tag',1),(5722,'in the camel route, you then refer to this repository using the aggregationrepositoryref attribute on the aggregate tag',1),(5723,'running the examplethe source code for the book contains this example in the chapter8/aggregator directory',1),(5724,'you can run it using the following maven goals:mvn test -dtest=aggregateabchawtdbtest mvn test -dtest=springaggregateabchawtdbtestto demonstrate how the persistence store works, the example will start up and run for 20 seconds',1),(5725,'in that time, you can copy files in the target/inbox directory and have those files consumed and aggregated',1),(5726,'on every third file, the aggregator will complete and publish a message',1),(5727,'the example will display instructions on the console about how to do this:copy 3 files to target/inbox to trigger the completion files to copy:  copy src/test/resources/a',1),(5728,'txt target/inboxlisting 8',1),(5729,'3 using hawtdb with aggregator in spring xmlhawtdb persistent repositoryb    www',1),(5730,'info251the aggregator eip  copy src/test/resources/b',1),(5731,'txt target/inbox  copy src/test/resources/c',1),(5732,'txt target/inboxsleeping for 20 secondsyou can let the test terminate (or press ctrl + c) and then start it again which should let you be able to resume',1),(5733,'for example, if you copy the first two files and then let the example terminate, you’ll see the following:cd chapter8/aggregator chapter8/aggregator$ cp src/test/resources/a',1),(5734,'txt target/inbox chapter8/aggregator$ cp src/test/resources/b',1),(5735,'txt target/inboxthe console should indicate that it consumed two files and was shut down:2010-04-25 info route1 - consuming file a',1),(5736,'txt 2010-04-25 info route1 - consuming file b',1),(5737,'0 is shutdown the next time you start the example, you can resume where you left off, and copy the last file:chapter8/aggregator$ cp src/test/resources/c',1),(5738,'txt target/inboxthen the aggregator should complete and publish the message:2010-04-25 info hawtdbaggregationrepository - on startup there are 1    aggregate exchanges (not completed) in repository: myrepo 2010-04-25 info defaultcamelcontext - apache...',1),(5739,'0 is started',1),(5740,'2010-04-25 info route1 - consuming file c',1),(5741,'txt 2010-04-25 info route1 - sending out abcnotice how it logs on startup how many exchanges are in the persistent repository',1),(5742,'in this example there is one existing exchange on startup',1),(5743,'now you’ve seen the persistent aggregator in action',1),(5744,'let’s move on to look at using recovery with the aggregator, which ensures that published messages can be safely recovered and be routed in a transactional way',1),(5745,'4 using recovery with the aggregatorthe examples covered in the previous section focused on ensuring that messages are persisted during aggregation',1),(5746,'but there’s another place where messages may be lost: messages that have been published (send out) from the aggregator, could potentially fail during routing as well',1),(5747,'to remedy this problem you could use one of these two approaches:■ camel error handlers (covered in chapter 5)—these provide redelivery and dead letter channel capabilities',1),(5748,'■ the hawtdb component—the hawtdbaggregationrepository provides recovery, redelivery, dead letter channel, and transactional capabilities',1),(5749,'info252 chapter 8 enterprise integration patternscamel error handlers aren’t tightly coupled with the aggregator, so message handling is in the hands of the error handler',1),(5750,'if a message repeatedly fails, the error handler can only deal with this by retrying or eventually giving up and moving the message to a dead letter channel',1),(5751,'note recoverableaggregationrepository is an interface extending aggregationrepository, which offers the recovery, redelivery, and dead letter channel features',1),(5752,'the hawtdbaggregationrepository implements this interface',1),(5753,'the hawtdbaggregationrepository on the other hand, is tightly integrated into the aggregator, which allows additional benefits such as leveraging the persistence store for recovery and offering transactional capabilities',1),(5754,'it ensures published messages that fail will be recovered and redelivered',1),(5755,'you can think of this as what a jms broker, such as apache activemq, can do by bumping failed messages back up on the jms queue for redelivery',1),(5756,'understanding recoveryto better understand how recovery works, we’ve provided the following two figures',1),(5757,'4 shows what happens when an aggregated message is being published for the first time, and the message fails during processing',1),(5758,'this could also be the situation when a server crashes while processing the message',1),(5759,'an aggregated message is complete, so the aggregator signals b this to the recoverableaggregationrepository, which fetches the aggregated message to bepersistentstorerecoverableaggregationrepositoryprocessingfailedprocessgetcamel routeaggregator mess...',1),(5760,'4 an aggregated message is completed b, it’s published from the aggregator c, and processing fails d, so the message is rolled back',1),(5761,'info253the aggregator eippublished c',1),(5762,'the message is then routed in camel—but suppose it fails during routing d',1),(5763,'a signal is sent from the aggregator to the recoverableaggregationrepository, which can act accordingly',1),(5764,'now imagine the same message is recovered and redelivered, as shown in figure 8',1),(5765,'the aggregator uses a background task, which runs every 5 seconds, to scan for previously published messages to be recovered b',1),(5766,'any such messages will be republished c, and the message will be routed again',1),(5767,'this time, the message could be processed successfully, which lets the aggregator issue a commit d',1),(5768,'the repository confirms e the message, ensuring it won’t be recovered on subsequent scans',1),(5769,'note the transactional behavior provided by recoverableaggregationrepository isn’t based on spring’s transactionmanager (which we’ll cover in chapter 9)',1),(5770,'the transactional behavior is based on hawtdb’s own transaction mechanism',1),(5771,'running the examplethe source code for the book contains this example in the chapter8/aggregator directory',1),(5772,'you can run it using the following maven goals:mvn test -dtest=aggregateabcrecovertest mvn test -dtest=springaggregateabcrecovertestthe example is constructed to fail when processing the published messages, no matter what',1),(5773,'this means that eventually you’ll have to move the message to a dead letter channel',1),(5774,'persistentstorerecoverableaggregationrepositoryprocessingsuccededprocessgetcamel routeaggregator messagerecovercommitmessagepublishrmbc defigure 8',1),(5775,'5 the aggregator recovers b failed messages, which are published again c, and this time the messages completed d successfully e',1),(5776,'info254 chapter 8 enterprise integration patterns to use recovery with routes in the java dsl, you have to set up hawtdbaggregationrepository as shown here:hawtdbaggregationrepository hawtdb = new    hawtdbaggregationrepository(\"myrepo\", \"data/myrepo',1),(5777,'setuserecovery(true); hawtdb',1),(5778,'setmaximumredeliveries(4); hawtdb',1),(5779,'setrecoveryinterval(3000);in spring xml, you can set this up as a spring <bean> tag, as follows:<bean id=\"myrepo\"    class=\"org',1),(5780,'hawtdbaggregationrepository\">    <property name=\"repositoryname\" value=\"myrepo\"/>    <property name=\"persistentfilename\" value=\"data/myrepo',1),(5781,'dat\"/>    <property name=\"userecovery\" value=\"true\"/>    <property name=\"recoveryinterval\" value=\"3000\"/>    <property name=\"maximumredeliveries\" value=\"4\"/>    <property name=\"deadletteruri\" value=\"mock:dead\"/> </bean>the options may make sense as y...',1),(5782,'in this example, the aggregator will check for messages to be recovered every 3 seconds',1),(5783,'to avoid a message being repeatedly recovered, the maximum redeliveries are set to 4',1),(5784,'this means that after 4 failed recovery attempts, the message is exhausted and is moved to the dead letter channel',1),(5785,'if you omit the maximum redeliveries option, camel will keep recovering failed messages forever until they can be processed successfully',1),(5786,'if you run the example, you’ll notice that the console outputs the failures as stack traces, and at the end you’ll see a warn entry that indicates the message has been moved to the dead letter channel:2010-04-26 [aggregaterecoverchecker] warn - the r...',1),(5787,'the preceding log output identifies the number of redelivery attempts, but how does camel know this',1),(5788,'obviously camel stores this information on the exchange',1),(5789,'6 reveals where this information is stored',1),(5790,'6 headers on exchange related to redeliveryheader type descriptionexchange',1),(5791,'the counter starts with the value of 1',1),(5792,'redelivered boolean whether this exchange is being redelivered',1),(5793,'redelivery_ exhaustedboolean whether this exchange has attempted all redeliveries and still failed (also known as being exhausted)',1),(5794,'6 is only available when camel performs a recovery',1),(5795,'these headers are absent on the regular first attempt',1),(5796,'it’s only when a recovery is triggered that these headers are set on the exchange',1),(5797,'7 lists the options for the recoverableaggregationrepository that are related to recovery',1),(5798,'we won’t go into more detail regarding the options in table 8',1),(5799,'7, as we’ve already covered an example using them',1),(5800,'this concludes our extensive coverage of the sophisticated and probably most complex eip implemented in camel—the aggregator',1),(5801,'in the next section, we’ll look at the splitter pattern',1),(5802,'3 the splitter eipmessages passing through an integration solution may consist of multiple elements, such as an order, which typically consists of more than a single line item',1),(5803,'each line in the order may need to be handled differently, so you need an approach that processes the complete order, treating each line item individually',1),(5804,'the solution to this problem is the splitter eip, illustrated in figure 8',1),(5805,'in this section, we’ll teach you all you need to know about the splitter',1),(5806,'we’ll start with a simple example and move on from there',1),(5807,'7 recoverableaggregationrepository configuration options related to recoveryoption default descriptionuserecovery true whether or not recovery is enabled',1),(5808,'recoveryinterval 5000 how often the recovery background tasks are executed',1),(5809,'the value is in milliseconds',1),(5810,'deadletteruri null an optional dead letter channel, where published messages that are exhausted should be sent',1),(5811,'this is similar to the deadletterchannel error handler, which we covered in chapter 5',1),(5812,'this option is disabled by default',1),(5813,'when in use, the maximumredeliveries option must be configured as well',1),(5814,'maximumredeliveries null a limit that defines when published messages that repeatedly fail are considered exhausted and should be moved to the dead letter uri',1),(5815,'this option is disabled by default',1),(5816,'emessage1emessage2emessage3dmessage splitterfigure 8',1),(5817,'6 the splitter breaks out the incoming message into a series of individual messages',1),(5818,'info256 chapter 8 enterprise integration patterns8',1),(5819,'1 using the splitterusing the splitter in camel is straightforward, so let’s try a basic example that will split one message into three messages, each containing one of the letters a, b, and c',1),(5820,'listing 8',1),(5821,'4 shows the example using a java dsl–based camel route and a unit test',1),(5822,'public class splitterabctest extends cameltestsupport {    public void testsplitabc() throws exception {        mockendpoint mock = getmockendpoint(\"mock:split\");        mock',1),(5823,'expectedbodiesreceived(\"a\", \"b\", \"c\");        list<string> body = new arraylist<string>();        body',1),(5824,'sendbody(\"direct:start\", body);        assertmockendpointssatisfied();    }    protected routebuilder createroutebuilder() throws exception {        return new routebuilder() {            public void configure() throws exception {                from...',1),(5825,'to(\"mock:split\");            }        };    } }the test method sets up a mock endpoint that expects three messages to arrive, in the order a, b, and c',1),(5826,'then you construct a single combined message body that consists of a list of strings containing the three letters',1),(5827,'the camel route will use the splitter eip to split up the message body b',1),(5828,'if you run this test, the console should log the three messages, as follows:info  route1 - split line ainfo  route1 - split line b info  route1 - split line cwhen using the splitter eip in spring xml, you have to do this a bit differently because the...',1),(5829,'in the java dsl we defined the expression shown in bold:',1),(5830,'split(body())here, body() is a method available on the routebuilder, which returns an org',1),(5831,'expression instance',1),(5832,'in spring xml you need to do this as shown in bold:<camelcontext xmlns=\"http://camel',1),(5833,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>listing 8',1),(5834,'4 a basic example of the splitter eipsplits incoming message bodyb    www',1),(5835,'info257the splitter eip        <split>            <simple>${body}</simple>            <log message=\"split line ${body}\"/>            <to uri=\"mock:split\"/>        </split>    </route> </camelcontext>in spring xml, you use the camel’s expression langu...',1),(5836,'the source code for the book contains this example in the chapter8/splitter directory',1),(5837,'you can run it using the following maven goals:mvn test -dtest=splitterabctest mvn test -dtest=springsplitterabctestnow you’ve seen the splitter in action',1),(5838,'to better understand how you can tell camel what it should split, you need to understand how it works',1),(5839,'how the splitter worksthe splitter works something like a big iterator that iterates through something and processes each entry',1),(5840,'the sequence diagram in figure 8',1),(5841,'7 shows more details about how this big iterator works',1),(5842,'bstartevaluate expressioncreate iteratornoyescopy original messagereplace body with part from iteratorprocess messageaggregate messagemore to split',1),(5843,'7 a sequence diagram showing how the splitter works internally, by using an iterator to iterate through the message and process each entry',1),(5844,'info258 chapter 8 enterprise integration patternswhen working with the splitter, you have to configure an expression, which is evaluated b when a message arrives',1),(5845,'in listing 8',1),(5846,'4, the evaluation returned the message body',1),(5847,'the result from the evaluation is used to create a java',1),(5848,'then the splitter uses the iterator d until there is no more data',1),(5849,'each message to be sent out of the iterator is a copy of the message e, which has had its message body replaced with the part from the iterator f',1),(5850,'in listing 8',1),(5851,'4, there would be three parts: each of the letters a, b, and c',1),(5852,'the message to be sent out is then processed g, and when the processing is done, the message may be aggregated h (more about this in section 8',1),(5853,'the splitter will decorate each message it sends out with properties on the exchange, which are listed in table 8',1),(5854,'you may find yourself in a situation where you need more power to do the splitting, such as to dictate exactly how a message should be split',1),(5855,'and what better power is there than java',1),(5856,'by using java code, you have the ultimate control and can tackle any situation',1),(5857,'2 using beans for splittingsuppose you need to split messages that contain complex payloads',1),(5858,'suppose the message payload is a customer object containing a list of departments, and you want to split by department, as illustrated in figure 8',1),(5859,'8 properties on the exchange related to the splitter eipproperty type descriptionexchange',1),(5860,'split_ indexinteger the index for the current message being processed',1),(5861,'the index is zero-based',1),(5862,'split_ sizeinteger the total number of messages the original message has been split into',1),(5863,'note that this information isn’t available in streaming mode (see section 8',1),(5864,'3 for more details about streaming)',1),(5865,'split_ completeboolean whether or not this is the last message being processed',1),(5866,'when camel creates the iterator c, it supports a range of types',1),(5867,'camel knows how to iterate through the following types: collection, iterator, array, org',1),(5868,'nodelist, string (with entries separated by commas)',1),(5869,'info259the splitter eipthe customer object is a simple bean containing the following information (getter and setter methods omitted):public class customer {    private int id;    private string name;    private list<department> departments; }the depa...',1),(5870,'the reason is that the message payload (the message body) isn’t a list, but a customer object',1),(5871,'therefore you need to tell camel how to split, which you do as follows:public class customerservice {    public list<department> splitdepartments(customer customer) {        return customer',1),(5872,'getdepartments();    } }the splitdepartments method returns a list of department objects, which is what you want to split by',1),(5873,'in the java dsl, you can use the customerservice bean for splitting by telling camel to invoke the splitdepartments method',1),(5874,'this is done by using the method call expression as shown in bold:public void configure() throws exception {    from(\"direct:start\")',1),(5875,'method(customerservice',1),(5876,'class, \"splitdepartments\")',1),(5877,'to(\"log:split\")',1),(5878,'to(\"mock:split\"); }in spring xml, you’d have to declare the customerservice in a spring bean tag, as follows:splittercustomerdepartment adepartment bdepartment c department adepartmentbdepartmentcfigure 8',1),(5879,'8 splitting a complex message into submessages by department    www',1),(5880,'info260 chapter 8 enterprise integration patterns<bean id=\"customerservice\" class=\"camelinaction',1),(5881,'customerservice\"/><camelcontext xmlns=\"http://camel',1),(5882,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>        <split>            <method bean=\"customerservice\" method=\"splitdepartments\"/>            <to uri=\"log:split\"/>            <to uri=\"mock:split\"/>        </split>    </route> </cam...',1),(5883,'you can run it using the following maven goals:mvn test -dtest=splitterbeantest mvn test -dtest=springsplitterbeantestthe logic in the splitdepartments method is simple, but it shows how you can use a method on a bean to do the splitting',1),(5884,'in your use cases, you may need more complex logic',1),(5885,'tip the logic in the splitdepartments method seems trivial, and it’s possible to use camel’s expression language (simple) to invoke methods on the message body',1),(5886,'in java dsl you could define the route as follows:',1),(5887,'departments}\")',1),(5888,'in spring xml you would use the <simple> tag instead of the <method> tag: <simple>${body',1),(5889,'departments}</simple>',1),(5890,'the splitter will usually operate on messages that are loaded into memory',1),(5891,'but there are situations where the messages are so big that it’s not feasible to have the entire message in memory at once',1),(5892,'3 splitting big messagesrider auto parts has an erp system that contains inventory information from all its suppliers',1),(5893,'to keep the inventory updated, each supplier must submit updates to rider auto parts',1),(5894,'some suppliers do this once a day using good old-fashioned files as a means of transport',1),(5895,'those files could potentially be very large, so you have to split those files without loading the entire file into memory',1),(5896,'this can be done by using streams, which allow you to read on demand from a stream of data',1),(5897,'this resolves the memory issue, because you can read in a chunk of data, process the data, read in another chunk, process the data, and so on',1),(5898,'9 shows the flow of the application used by auto rider parts to pick up the files from the suppliers and update the inventory',1),(5899,'file csv toobjectupdateinventorysplit linesfigure 8',1),(5900,'9 a route that picks up incoming files, splits them, and transforms them so they’re ready for updating the inventory in the erp system    www',1),(5901,'info261the splitter eipwe’ll revisit this example again in chapter 10, and cover it in much greater detail when we cover concurrency',1),(5902,'9 is easy to do in camel, as follows',1),(5903,'public void configure() throws exception {    from(\"file:target/inventory\")',1),(5904,'log(\"starting to process big file: ${header',1),(5905,'tokenize(\"\\n\"))',1),(5906,'class, \"csvtoobject\")',1),(5907,'log(\"done processing big file: ${header',1),(5908,'class, \"updateinventory\"); }as you can see in listing 8',1),(5909,'5, all you have to do is enable streaming mode using',1),(5910,'this tells camel to not load the entire payload into memory, but instead to iterate the payload in a streaming fashion',1),(5911,'also notice the use of end() cto indicate the end of the splitting route',1),(5912,'the end() in the java dsl is the equivalent of the end tag </split> when using spring xml',1),(5913,'in spring xml, you enable streaming using the streaming attribute on the <split> tag, as follows',1),(5914,'<camelcontext xmlns=\"http://camel',1),(5915,'org/schema/spring\">    <route>        <from uri=\"file:target/inventory\"/>        <log message=\"processing big file: ${header',1),(5916,'camelfilename}\"/>        <split streaming=\"true\">            <tokenize token=\"\\n\"/>            <bean beantype=\"camelinaction',1),(5917,'inventoryservice\"                  method=\"csvtoobject\"/>            <to uri=\"direct:update\"/>        </split>        <log message=\"done processing big file: ${header',1),(5918,'inventoryservice\"              method=\"updateinventory\"/>    </route> </camelcontext>you may have noticed in listings 8',1),(5919,'6 that the files are split using a tokenizer',1),(5920,'the tokenizer is a powerful feature that works well with streaming',1),(5921,'the tokenizer leverages java',1),(5922,'scanner, which supports streaming',1),(5923,'the scanner is capable of iterating, which means that it only reads chunks of data into memory',1),(5924,'a token must belisting 8',1),(5925,'5 splitting big files using streaming modelisting 8',1),(5926,'6 splitting big files using streaming mode in spring xmlsplits file using streaming modebdenotes where the splittingroute ends c    www',1),(5927,'info262 chapter 8 enterprise integration patternsprovided to indicate the boundaries of the chunks',1),(5928,'in the preceding code, you use a newline (\\n) as the token',1),(5929,'so, in this example, the scanner will only read the file into memory on a line-by-line basis, resulting in low memory consumption',1),(5930,'note when using streaming mode, be sure the message you’re splitting can be split into well-known chunks that can be iterated',1),(5931,'you can use the tokenizer or convert the message body to a type that can be iterated, such as an iterator',1),(5932,'the splitter eip in camel includes an aggregation feature that lets you recombine split messages into single outbound messages, while they are being routed',1),(5933,'4 aggregating split messagesbeing able to split and aggregate messages again is a powerful mechanism',1),(5934,'you could use this to split an order into individual order lines, process them, and then recombine them into a single outgoing message',1),(5935,'this pattern is known as the composed message processor, which we briefly touched on in section 8',1),(5936,'it’s shown in figure 8',1),(5937,'the camel splitter provides a built-in aggregator, which makes it even easier to aggregate split messages back into single outgoing messages',1),(5938,'10 illustrates this principle, with the help of the “abc” message example',1),(5939,'suppose you want to translate each of the a, b, and c messages into a phrase, and have all the phrases combined into a single message again',1),(5940,'this can easily be done with the splitter—all you need to provide is the logic that combines the messages',1),(5941,'this logic is created using an aggregationstrategy implementation',1),(5942,'10 can be done as follows in the java dsl',1),(5943,'the configuration of the aggregationstrategy is shown in bold:splitter aggregatormessagecmessageamessagebmessagetranslatormessagetranslatormessagetranslatoraggregatedmessagemessageabcfigure 8',1),(5944,'10 the splitter has a built-in aggregator that can recombine split messages into a combined outgoing message',1),(5945,'info263the splitter eipfrom(\"direct:start\")',1),(5946,'bean(wordtranslatebean',1),(5947,'class)',1),(5948,'to(\"mock:split\")',1),(5949,'to(\"mock:result\");in spring xml, you have to declare the aggregationstrategy as a spring bean tag, as shown in bold:<bean id=\"translate\" class=\"camelinaction',1),(5950,'wordtranslatebean\"/><bean id=\"myaggregationstrategy\"      class=\"camelinaction',1),(5951,'myaggregationstrategy\"/><camelcontext xmlns=\"http://camel',1),(5952,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>        <split strategyref=\"myaggregationstrategy\">            <simple>body</simple>            <log message=\"split line ${body}\"/>            <bean ref=\"translate\"/>            <to uri=...',1),(5953,'public class myaggregationstrategy implements aggregationstrategy {    public exchange aggregate(exchange oldexchange, exchange newexchange) {        if (oldexchange == null) {            return newexchange;        }        string body = newexchange',1),(5954,'class);        string existing = oldexchange',1),(5955,'class);        oldexchange',1),(5956,'setbody(existing + \"+\" + body);        return oldexchange;    } }as you can see from listing 8',1),(5957,'7, you combine the messages into a single string body, with individual phrases (from the message bodies) being separated with + signs',1),(5958,'the source code for the book contains this example in the chapter8/splitter directory',1),(5959,'you can run it using the following maven goals:mvn test -dtest=splitteraggregateabctest mvn test -dtest=springsplitteraggregateabctestlisting 8',1),(5960,'7 combining split messages back into a single outgoing message    www',1),(5961,'info264 chapter 8 enterprise integration patternsthe example uses the three phrases: “aggregated camel rocks”, “hi mom”, and “yes it works”',1),(5962,'when you run the example, you’ll see the console output the aggregated message at the end',1),(5963,'info  route1 - split line ainfo  route1 - split line b info  route1 - split line c info  route1 - aggregated camel rocks+hi mom+yes it worksbefore we wrap up our coverage of the splitter, let’s take a look at what happens if one of the split messages...',1),(5964,'5 when errors occur during splittingthe splitter processes messages and those messages can fail when some business logic throws an exception',1),(5965,'camel’s error handling is active during the splitting, so the errors you have to deal with in the splitter are errors that camel’s error handling couldn’t handle',1),(5966,'you have two choices for handling errors with the splitter:■ stop—the splitter will split and process each message in sequence',1),(5967,'suppose the second message failed',1),(5968,'in this situation, you could either immediately stop and let the exception propagate back, or you could continue splitting the remainder of the messages, and let the exception propagate back at the end (default behavior)',1),(5969,'■ aggregate—you could handle the exception in the aggregationstrategy and decide whether or not the exception should be propagated back',1),(5970,'let’s look into the choices',1),(5971,'using stoponexceptionthe first solution requires you to configure the stoponexception option on the splitter as follows:from(\"direct:start\")',1),(5972,'bean(wordtranslatebean',1),(5973,'class)',1),(5974,'to(\"mock:split\")',1),(5975,'to(\"mock:result\");in spring xml, you use the stoponexception attribute on the <split> tag, as follows:<split strategyref=\"myaggregationstrategy\" stoponexception=\"true\">the source code for the book contains this example in the chapter8/splitter directory',1),(5976,'you can run it using the following maven goals:mvn test -dtest=splitterstoponexceptionabctest mvn test -dtest=springsplitterstoponexceptionabctestthe second option is to handle exceptions from the split messages in the aggregationstrategy',1),(5977,'info265the splitter eiphandling exceptions using aggregationstrategythe aggregationstrategy allows you to handle the exception by either ignoring it or letting it be propagated back',1),(5978,'here’s how you could ignore the exception',1),(5979,'public class myignorefailureaggregationstrategy                implements aggregationstrategy {    public exchange aggregate(exchange oldexchange, exchange newexchange) {        if (newexchange',1),(5980,'class);        string existing = oldexchange',1),(5981,'class);        oldexchange',1),(5982,'setbody(existing + \"+\" + body);        return oldexchange;    } }when handling exceptions in the aggregationstrategy, you can detect whether an exception occurred or not by checking the getexception method from the newexchange parameter',1),(5983,'the preceding example ignores the exception by returning the oldexchange b',1),(5984,'if you want to propagate back the exception, you need to keep it stored on the aggregated exception, which can be done as follows',1),(5985,'public class mypropagatefailureaggregationstrategy                implements aggregationstrategy {    public exchange aggregate(exchange oldexchange, exchange newexchange) {        if (newexchange',1),(5986,'= null) {            if (oldexchange == null) {                return newexchange;            } else {                oldexchange',1),(5987,'class);        string existing = oldexchange',1),(5988,'class);        oldexchange',1),(5989,'setbody(existing + \"+\" + body);listing 8',1),(5990,'8 handling an exception by ignoring itlisting 8',1),(5991,'9 propagating back an exceptionignores the exceptionbpropagates exceptionb    www',1),(5992,'info266 chapter 8 enterprise integration patterns        return oldexchange;    } }as you can see, it requires a bit more work to keep the exception',1),(5993,'on the first invocation of the aggregate method, the oldexchange parameter is null and you simply return the newexchange (which has the exception)',1),(5994,'otherwise you must transfer the exception to the oldexchange b',1),(5995,'warning when using a custom aggregationstrategy with the splitter, it’s important to know that you’re responsible for handling exceptions',1),(5996,'if you don’t propagate the exception back, the splitter will assume you have handled the exception and will ignore it',1),(5997,'the source code for the book contains this example in the chapter8/splitter directory',1),(5998,'you can run it using the following maven goals:mvn test -dtest=splitteraggregateexceptionabctest mvn test -dtest=springsplitteraggregateexceptionabctestnow you’ve learned all there is to know about the splitter',1),(5999,'well, almost all',1),(6000,'we’ll revisit the splitter in chapter 10 when we look at concurrency',1),(6001,'in the next two sections, we’ll look at eips that support dynamic routing, starting with the routing slip pattern',1),(6002,'4 the routing slip eipthere are times when you need to route messages dynamically',1),(6003,'for example, you may have an architecture that requires incoming messages to undergo a sequence of processing steps and business rule validations',1),(6004,'because the steps and validations vary widely, you can implement each step as a separate filter',1),(6005,'the filter acts as a dynamic model to apply the business rule and validations',1),(6006,'this architecture could be implemented using the pipes and filters eip together with the filter eip',1),(6007,'but as often happens with eips, there’s a better way, known as the routing slip eip',1),(6008,'the routing slip acts as a dynamic router that dictates the next step a message should undergo',1),(6009,'11 shows this principle',1),(6010,'routingslipmessage endpoint bendpoint aendpoint cmessagea c route messageaccording to slipfigure 8',1),(6011,'11 the incoming message has a slip attached that specifies the sequence of the processing steps',1),(6012,'the routing slip eip reads the slip and routes the message to the next endpoint in the list',1),(6013,'info267the routing slip eipthe camel routing slip eip requires a preexisting header or expression as the attached slip',1),(6014,'either way, the initial slip must be prepared before the message is sent to the routing slip eip',1),(6015,'1 using the routing slip eipwe’ll start with a simple example that shows how to use the routing slip eip to perform the sequence outlined in figure 8',1),(6016,'in the java dsl, the route is as simple as this:from(\"direct:start\")',1),(6017,'routingslip(\"myslip\");it’s also easy in spring xml:<route>    <from uri=\"direct:start\"/>    <routingslip>        <header>myslip</header>    </routingslip> </route>this example assumes the incoming message contains the slip in the header with the key ...',1),(6018,'the following test method shows how you should fill out the key:public void testroutingslip() throws exception {    getmockendpoint(\"mock:a\")',1),(6019,'expectedmessagecount(1);    getmockendpoint(\"mock:b\")',1),(6020,'expectedmessagecount(0);    getmockendpoint(\"mock:c\")',1),(6021,'expectedmessagecount(1);    template',1),(6022,'sendbodyandheader(\"direct:start\", \"hello world\",                               \"myslip\", \"mock:a,mock:c\");    assertmockendpointssatisfied(); }as you can see, the value of the key is the endpoint uris separated by commas',1),(6023,'the comma is the default delimiter, but the routing slip supports using custom delimiters',1),(6024,'for example, to use a semicolon, you could do this:from(\"direct:start\")',1),(6025,'routingslip(\"myslip\", \";\");and in spring xml, you’d do this:<routingslip uridelimiter=\";\">    <header>myslip</header> </routingslip>this example expects a preexisting header containing the routing slip',1),(6026,'but what if the message doesn’t contain such a header',1),(6027,'in those situations, you have to compute the header in any way you like',1),(6028,'in the next example, we look at how to compute the header using a bean',1),(6029,'2 using a bean to compute the routing slip headerto keep things simple, the logic to compute a header that contains two or three steps has been kept in a single method, as follows:    www',1),(6030,'info268 chapter 8 enterprise integration patternspublic class computeslip {    public string compute(string body) {        string answer = \"mock:a\";        if (body',1),(6031,'contains(\"cool\")) {            answer += \",mock:b\";        }        answer += \",mock:c\";        return answer;    } }all you how to do now is leverage this bean to compute the header to be used as routing slip',1),(6032,'in the java dsl, you can use the method call expression to invoke the bean and set the header:from(\"direct:start\")',1),(6033,'class)',1),(6034,'routingslip(\"myslip\");in spring xml, you can do it as follows:<route>    <from uri=\"direct:start\"/>    <setheader headername=\"myslip\">        <method beantype=\"camelinaction',1),(6035,'computeslip\"/>   </setheader>     <routingslip>        <header>myslip</header>    </routingslip> </route>in this example, you use a method call expression to set a header that is then used by the routing slip',1),(6036,'but you might want to skip the step of setting the header and instead use the expression directly',1),(6037,'3 using an expression as the routing slipinstead of setting a header, you can use an expression, such as the method call expression we covered in the previous section',1),(6038,'here’s how you’d do so with the java dsl:from(\"direct:start\")',1),(6039,'class);the equivalent spring xml is as follows:<route>    <from uri=\"direct:start\"/>    <routingslip>        <method beantype=\"camelinaction',1),(6040,'computeslip\"/>    </routingslip> </route>another way of using the routing slip eip in camel is to use beans and annotations',1),(6041,'4 using @routingslip annotationthe @routingslip annotation allows you to turn a regular bean method into the routing slip eip',1),(6042,'let’s go over an example',1),(6043,'suppose you have the following slipbean:public class slipbean {    @routingslip    public string slip(string body) {        string answer = \"mock:a\";        if (body',1),(6044,'contains(\"cool\")) {            answer += \",mock:b\";        }        answer += \",mock:c\";        return answer;    } }as you can see, all this does is annotate the slip method with @routingslip',1),(6045,'when camel invokes the slip method, it detects the @routingslip annotation and continues routing according to the routing slip eip',1),(6046,'warning when using @recipientlist it’s important to not use recipientlist in the dsl at the same time',1),(6047,'by doing this, camel will double up using recipient list eip, which is not the intention',1),(6048,'instead, do as shown in the example below',1),(6049,'notice that there’s no mention of the routing slip in the dsl',1),(6050,'the route is just invoking a bean',1),(6051,'from(\"direct:start\")',1),(6052,'class);here it is in the spring dsl:<bean id=\"mybean\" class=\"camelinaction',1),(6053,'slipbean\"/><route>    <from uri=\"direct:start\"/>    <bean ref=\"mybean\"/> </route>why might you want to use this',1),(6054,'well, by using @routingslip on a bean, it becomes more flexible in the sense that the bean is accessible using a endpoint uri',1),(6055,'any camel client or route could easily send a message to the bean and have it continued being routed as a routing slip',1),(6056,'for example, using a producertemplate you could send a message to the bean:producertemplate template =',1),(6057,'sendbody(\"bean:mybean\", \"camel rocks\");that \"camel rocks\" message would then be routed as a routing slip with the slip generated as the result of the mybean method invocation',1),(6058,'the source code for the book contains the examples we’ve covered in the chapter8/routingslip directory',1),(6059,'you can try them using the following maven goals:    www',1),(6060,'info270 chapter 8 enterprise integration patternsmvn test -dtest=routingslipsimpletest mvn test -dtest=springroutingslipsimpletest mvn test -dtest=routingslipheadertest mvn test -dtest=springroutingslipheadertest mvn test -dtest=routingsliptest mvn t...',1),(6061,'5 the dynamic router eipin the previous section, you learned that the routing slip pattern acts as a dynamic router',1),(6062,'so what’s the difference between the routing slip and dynamic router eips',1),(6063,'the difference is minimal: the routing slip needs to compute the slip up front, whereas the dynamic router will evaluate on-the-fly where the message should go next',1),(6064,'1 using the dynamic router just like the routing slip, the dynamic router requires you to provide logic, which determines where the message should be routed',1),(6065,'such logic is easily implemented using java code, and in this code you have total freedom to determine where the message should go next',1),(6066,'for example, you might query a database or a rules engine to compute where the message should go',1),(6067,'listing 8',1),(6068,'10 shows the java bean used in the example',1),(6069,'public class dynamicrouterbean {public string route(string body,    @header(exchange',1),(6070,'slip_endpoint) string previous) {           return wheretogo(body, previous);                    }private string wheretogo(string body, string previous) {    if (previous == null) {        return \"mock://a\";    } else if (\"mock://a\"',1),(6071,'equals(previous)) {        return \"language://simple:bye ${body}\";    } else {        return null;                                } } }the idea with the dynamic router is to let camel keep invoking the route method until it indicates the end',1),(6072,'the first time the route method is invoked, the previous parameter will be null b',1),(6073,'on every subsequent invocation, the previous parameter contains the endpoint uri of the last step',1),(6074,'listing 8',1),(6075,'10 java bean deciding where the message should be routed nextprevious endpoint uribends routerc    www',1),(6076,'info271the dynamic router eip as you can see in the wheretogo method, you use this fact and return different uris depending on the previous step',1),(6077,'when the dynamic router is to end, you return null c',1),(6078,'using the dynamic router from the java dsl is easy to do:from(\"direct:start\")',1),(6079,'class, \"route\"))',1),(6080,'to(\"mock:result\");the same route in spring xml is just as easy as shown:<bean id=\"mydynamicrouter\" class=\"camelinaction',1),(6081,'dynamicrouterbean\"/><camelcontext xmlns=\"http://camel',1),(6082,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>        <dynamicrouter>            <method ref=\"mydynamicrouter\" method=\"route\"/>        </dynamicrouter>        <to uri=\"mock:result\"/>    </route> </camelcontext>the source code for th...',1),(6083,'you can try it using the following maven goals:mvn test -dtest=dynamicroutertest mvn test -dtest=springdynamicroutertestthere is also a dynamic router annotation you can use',1),(6084,'2 using the @dynamicrouter annotationto demonstrate how to use the @dynamicrouter annotation let’s change the previous example to use the annotation instead',1),(6085,'to do that, just annotate the java code from listing 8',1),(6086,'10 as follows:@dynamicrouter public string route(string body,                    @header(exchange',1),(6087,'slip_endpoint) string previous) {',1),(6088,'}the next step is to invoke the route method on the bean, as if it were a regular bean',1),(6089,'that means you should not use the routing slip eip in the route, but use a bean instead',1),(6090,'in the java dsl, this is done as follows:from(\"direct:start\")',1),(6091,'class, \"route\")',1),(6092,'to(\"mock:result\");in spring xml, you likewise change the <dynamicrouter> to a <bean> tag:<camelcontext xmlns=\"http://camel',1),(6093,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>    www',1),(6094,'info272 chapter 8 enterprise integration patterns        <bean ref=\"mydynamicrouter\" method=\"route\"/>        <to uri=\"mock:result\"/>    </route> </camelcontext>warning when using @dynamicrouter its important to not use dynamicrouter in the dsl at the...',1),(6095,'instead do as shown above',1),(6096,'the source code for the book contains this example in the chapter8/dynamicrouter directory',1),(6097,'you can try it using the following maven goals:mvn test -dtest=dynamicrouterannotationtest mvn test -dtest=springdynamicrouterannotationtestthis concludes the coverage of the dynamic routing patterns',1),(6098,'in the next section, you’ll learn about camel’s built-in load balancer eip, which is useful when an existing load-balancing solution isn’t in place',1),(6099,'load balancing is a technique to distribute workload across computers or other resources, “in order to get optimal resource utilization, maximize throughput, minimize response time, and avoid overload” (http://en',1),(6100,'this service can be provided either in the form of a hardware device or as a piece of software, such as the load balancer eip in camel',1),(6101,'note the load balancer was not distilled in the eip book, but it will likely be added if there is a second edition of the book',1),(6102,'in this section, we’ll introduce the load balancer eip by walking through an example',1),(6103,'then, in section 8',1),(6104,'2, we’ll look at the various types of load balancers camel offers out of the box',1),(6105,'we’ll focus on the failover type in section 8',1),(6106,'3 and finally show how you can build your own load balancer in section 8',1),(6107,'1 introducing the load balancer eipthe camel load balancer eip is a processor that implements the org',1),(6108,'processor',1),(6109,'the loadbalancer offers methods to add and remove processors that should participate in the load balancing',1),(6110,'by using processors instead of endpoints, the load balancer is capable of balancing anything you can define in your camel routes',1),(6111,'but, that said, you’ll most often balance across a number of remote services',1),(6112,'such an example is illustrated in figure 8',1),(6113,'12, where a camel application needs to load balance across two services',1),(6114,'when using the load balancer eip, you have to select a balancing strategy',1),(6115,'a common and understandable strategy is to take turns among the services—this is known as the round robin strategy',1),(6116,'in section 8',1),(6117,'2, we’ll take a look at all the strategies camel provides out of the box',1),(6118,'info273the load balancer eiplet’s look at how you can use the load balancer with the round robin strategy',1),(6119,'here’s the java dsl with the load balancer:from(\"direct:start\")',1),(6120,'to(\"seda:a\")',1),(6121,'to(\"seda:b\")',1),(6122,'end();from(\"seda:a\")',1),(6123,'to(\"mock:a\");from(\"seda:b\")',1),(6124,'to(\"mock:b\");the equivalent route in spring xml is as follows:<route>    <from uri=\"direct:start\"/>    <loadbalance>        <roundrobin/>        <to uri=\"seda:a\"/>        <to uri=\"seda:b\"/>    </loadbalance> </route><route>    <from uri=\"seda:a\"/>   ...',1),(6125,'in a real-life situation, the remote services could be a web service',1),(6126,'suppose you start sending messages to the route',1),(6127,'the first message would be sent to the \"seda:a\" endpoint, and the next would go to \"seda:b\"',1),(6128,'the third message would start over and be sent to \"seda:a\", and so forth',1),(6129,'12 a camel application load balances across two services',1),(6130,'info274 chapter 8 enterprise integration patterns the source code for the book contains this example in the chapter8/loadbalancer directory',1),(6131,'you can try it by using the following maven goals:mvn test -dtest=loadbalancertest mvn test -dtest=springloadbalancertestif you run the example, the console will output something like this:[camel thread 0 - seda://a] info route2 - a received: hello [...',1),(6132,'2 load-balancing strategiesa load-balancing strategy dictates which processor should process an incoming message—it’s up to each strategy how the processor is chosen',1),(6133,'camel allows the six different strategies listed in table 8',1),(6134,'the first four strategies in table 8',1),(6135,'9 are easy to set up and use in camel',1),(6136,'for example, using the random strategy is just a matter of specifying it in the java dsl:from(\"direct:start\")',1),(6137,'to(\"seda:a\")',1),(6138,'to(\"seda:b\")',1),(6139,'end();it’s similar in spring xml:<route>    <from uri=\"direct:start\"/>    <loadbalance>        <random/>        <to uri=\"seda:a\"/>        <to uri=\"seda:b\"/>    </loadbalance> </route>table 8',1),(6140,'9 load-balancing strategies provided by camelstrategy descriptionrandom chooses a processor randomly',1),(6141,'round robin chooses a processor in a round robin fashion, which spreads the load evenly',1),(6142,'this is a classic and well-known strategy',1),(6143,'we covered this in section 8',1),(6144,'sticky uses an expression to calculate a correlation key that dictates the processor chosen',1),(6145,'you can think of this as the session id used in http requests',1),(6146,'topic sends the message to all processors',1),(6147,'this is like sending to a jms topic',1),(6148,'failover retries using another processor',1),(6149,'we’ll cover this in section 8',1),(6150,'custom uses your own custom strategy',1),(6151,'this is covered in section 8',1),(6152,'info275the load balancer eipthe sticky strategy requires you provide a correlation expression, which is used to calculate a hashed value to indicate which processor should be used',1),(6153,'suppose your messages contain a header indicating different levels',1),(6154,'by using the sticky strategy, you can have messages with the same level chose the same processor over and over again',1),(6155,'in the java dsl, you would provide the expression using a header expression as shown here:from(\"direct:start\")',1),(6156,'to(\"seda:a\")',1),(6157,'to(\"seda:b\")',1),(6158,'end();in spring xml, you’d do the following:<route>    <from uri=\"direct:start\"/>    <loadbalance>        <sticky>            <correlationexpression>                <header>type</header>            </correlationexpression>        </sticky>        <to...',1),(6159,'to try the random, sticky, or topic strategies, use the following maven goals:mvn test -dtest=randomloadbalancertest mvn test -dtest=springrandomloadbalancertest mvn test -dtest=stickyloadbalancertest mvn test -dtest=springstickyloadbalancertest mvn ...',1),(6160,'3 using the failover load balancerload balancing is often used to implement failover—the continuation of a service after a failure',1),(6161,'the camel failover load balancer detects the failure when an exception occurs and reacts by letting the next processor take over processing the message',1),(6162,'given the following route snippet, the failover will always start by sending the messages to the first processor (\"direct:a\") and only in the case of a failure will it let the next processor (\"direct:b\") take over',1),(6163,'from(\"direct:start\")',1),(6164,'info276 chapter 8 enterprise integration patternsthe equivalent snippet in spring xml is as follows:<route>    <from uri=\"direct:start\"/>    <loadbalance>        <failover/>        <to uri=\"direct:a\"/>        <to uri=\"direct:b\"/>    </loadbalance> </...',1),(6165,'you can try it using the following maven goals:mvn test -dtest=failoverloadbalancertest mvn test -dtest=springfailoverloadbalancertestif you run the example, it will send in four messages',1),(6166,'the second message will failover and be processed by the \"direct:b\" processor',1),(6167,'the other three messages will be processed successfully by \"direct:a\"',1),(6168,'in this example, the failover load balancer will react to any kind of exception being thrown, but you can provide it with a number of exceptions to react to',1),(6169,'suppose you only want to failover if an ioexception is thrown (which indicates communication errors with remote services, such as no connection)',1),(6170,'this is easy to configure, as shown in the java dsl:from(\"direct:start\")',1),(6171,'class)',1),(6172,'end();here it is configured in spring xml:<route>    <from uri=\"direct:start\"/>    <loadbalance>        <failover>            <exception>java',1),(6173,'ioexception</exception>        </failover>        <to uri=\"direct:a\"/>        <to uri=\"direct:b\"/>    </loadbalance> </route>in this example, only one exception is specified, but you can specify multiple exceptions, as follows: from(\"direct:start\")',1),(6174,'class, sqlexception',1),(6175,'class)',1),(6176,'end();in spring xml, you do as follows:<route>    <from uri=\"direct:start\"/>    <loadbalance>        <failover>    www',1),(6177,'sqlexception</exception>        </failover>        <to uri=\"direct:a\"/>        <to uri=\"direct:b\"/>    </loadbalance> </route>you may have noticed in the failover examples that it always chooses the first processor, and sends the failover to subseque...',1),(6178,'you can think of this as the first processor being the master, and the others slaves',1),(6179,'but the failover load balancer also offers a strategy that combines round robin with failure support',1),(6180,'using failover with round robinthe camel failover load balancer in round robin mode gives you the best of both worlds; it distributes the load evenly between the services, and it provides automatic failover',1),(6181,'in this scenario, you have three configuration options on the load balancer to dictate how it operates, as listed in table 8',1),(6182,'to better understand the options in table 8',1),(6183,'10 and how the round robin mode works, we’ll start with a fairly simple example',1),(6184,'in the java dsl, you have to configure failover with all the options in bold:from(\"direct:start\")',1),(6185,'failover(1, false, true)',1),(6186,'end();in this example, the maximumfailoverattempts option is set to 1, which means it will at most try to failover once (it will make one attempt for the initial request and one more for the failover attempt)',1),(6187,'if both attempts fail, camel will propagate the exception back to the caller',1),(6188,'10 failover load balancer configuration optionsconfiguration option default descriptionmaximumfailoverattempts-1 specifies how many failover attempts to try before exhausting (giving up): ■ use -1 to attempt forever (never give up)',1),(6189,'■ use 0 to never failover (give up immediately)',1),(6190,'■ use a positive value to specify a number of attempts',1),(6191,'for example, a value of 3 will try up to 3 failover attempts before giving up',1),(6192,'inheriterrorhandlertrue specifies whether or not camel error handling is being used',1),(6193,'if disabled, the load balancer will failover immediately if an exception is thrown',1),(6194,'roundrobin false specifies whether or not the load balancer operates in round robin mode',1),(6195,'info278 chapter 8 enterprise integration patterns the second parameter is set to false, which means it isn’t inheriting camel’s error handling',1),(6196,'this allows the failover load balancer to failover immediately when an exception occurs, instead of having to wait for the camel error handler to give up first',1),(6197,'the last parameter indicates that it’s using the round robin mode',1),(6198,'in spring xml, you configure the options as attributes on the failover tag:<route>    <from uri=\"direct:start\"/>    <loadbalance>        <failover roundrobin=\"true\" maximumfailoverattempts=\"1\"/>        <to uri=\"direct:a\"/>        <to uri=\"direct:b\"/>...',1),(6199,'you can try it using the following maven goals:mvn test -dtest=failoverloadbalancertest mvn test -dtest=springfailoverloadbalancertestif you’re curious about the inheriterrorhandler configuration option, take a look at the following examples in the s...',1),(6200,'the next section explains how to implement and use your own custom strategy, which you may want to do when you need to use special load-balancing logic',1),(6201,'4 using a custom load balancercustom load balancers allow you to be in full control of the balancing strategy in use',1),(6202,'for example, you could build a strategy that acquires load statistics from various services and picks the service with the lowest load',1),(6203,'let’s look at an example',1),(6204,'suppose you want to implement a priority-based strategy that sends gold messages to a certain processor and the remainder to a secondary destination',1),(6205,'13 illustrates this principle',1),(6206,'rrmessagegoldmessageothermessage  figure 8',1),(6207,'13 using a custom load balancer to route gold messages to processor 1 and other messages to processor 2    www',1),(6208,'info279the load balancer eipwhen implementing a custom load balancer, you will often extend the simpleloadbalancersupport class, which provides a good starting point',1),(6209,'listing 8',1),(6210,'11 shows how you can implement a custom load balancer',1),(6211,'processor; import org',1),(6212,'processor',1),(6213,'simpleloadbalancersupport;public class mycustomloadbalancer extends simpleloadbalancersupport {    public boolean process(exchange exchange) throws exception {        processor target = chooseprocessor(exchange);        target',1),(6214,'process(exchange);    }    @override    protected processor chooseprocessor(exchange exchange) {        string type = exchange',1),(6215,'class);        if (\"gold\"',1),(6216,'equals(type)) {            return getprocessors()',1),(6217,'get(0);        } else {            return getprocessors()',1),(6218,'get(1);        }    } }as you can see, it doesn’t take much code',1),(6219,'in the process() method, you invoke the chooseprocessor() method, which is the strategy that picks the processor to process the message',1),(6220,'in this example, it will pick the first processor if the message is a gold type, and the second processor if not',1),(6221,'in the java dsl, you use a custom load balancer as shown in bold:from(\"direct:start\")',1),(6222,'loadbalance(new mycustomloadbalancer())',1),(6223,'to(\"seda:a\")',1),(6224,'to(\"seda:b\")',1),(6225,'end();in spring xml, you need to declare a spring bean tag:<bean id=\"mycustom\" class=\"camelinaction',1),(6226,'mycustomloadbalancer\"/>which you then refer to from the <loadbalance> tag:<route>    <from uri=\"direct:start\"/>    <loadbalance ref=\"mycustom\">        <to uri=\"seda:a\"/>        <to uri=\"seda:b\"/>    </loadbalance> </route>the source code for the book...',1),(6227,'you can try it using the following maven goals:mvn test -dtest=customloadbalancertest mvn test -dtest=springcustomloadbalancertestlisting 8',1),(6228,'11 custom load balancer    www',1),(6229,'info280 chapter 8 enterprise integration patternswe’ve now covered the load balancer eip in camel, which brings us to the end of our long journey to visit five great eips implemented in camel',1),(6230,'7 summary and best practicessince the arrival of the enterprise integration patterns book on the scene, we have had a common vocabulary, graphical notation, and concepts for designing applications to tackle today’s integration challenges',1),(6231,'you have encountered these eips throughout this book',1),(6232,'in chapter 2 we reviewed the most common patterns, and this chapter reviews five of the most complex and sophisticated patterns in great detail',1),(6233,'you may view the eip book as the theory and camel as the software implementation of the book',1),(6234,'here are some eip best practices to take away from this chapter:■ learn the patterns',1),(6235,'take the time to study the eips, especially the common patterns we covered in chapter 2 and those we presented in this chapter',1),(6236,'consider getting the eip book to read more about the patterns—there’s great advice given in the book',1),(6237,'the patterns are universal and the knowledge you gain when using eips with camel is something you can take with you',1),(6238,'■ use the patterns',1),(6239,'if you have a problem you don’t know how to resolve, there’s a good chance others have scratched that itch before',1),(6240,'consult the eip book and the online camel patterns catalog: http://camel',1),(6241,'org/enterpriseintegration-patterns',1),(6242,'■ start simply',1),(6243,'when learning to use an eip, you should create a simple test to try out the pattern and learn how to use it',1),(6244,'having too many new moving parts in a camel route can clutter your view and make it difficult to understand what’s happening and maybe why it doesn’t do what you expected',1),(6245,'■ come back to this chapter',1),(6246,'if you’re going to use any of the five eips covered in this chapter, we recommend you reread the relevant parts of the chapter',1),(6247,'these patterns are very sophisticated and have many features and options to tweak',1),(6248,'the transactional client eip is useful for controlling transactions, and it’s the topic of the next chapter',1),(6249,'infopart 3out in the wildwith camel’s core concepts under your belt, you may feel like you can tackle any integration problem with camel',1),(6250,'there is still more to cover, though',1),(6251,'in this final part of the book, we’ll cover the topics that are useful when you know the core concepts and want to build something for the real world',1),(6252,'one concept you’ll encounter in many real-world applications is transactions',1),(6253,'in chapter 9, we’ll explain how to use spring’s transaction framework to let camel routes participate in transactions',1),(6254,'in chapter 10, we’ll discuss the important, and sometimes complex, topic of concurrency',1),(6255,'understanding how to configure and tune threading in camel is a must-read for performance-centric projects',1),(6256,'we’ll also cover how you can improve the scalability of your camel applications',1),(6257,'in chapter 11, we’ll discuss a topic you could really read right after part 1: how to develop new camel projects',1),(6258,'in this chapter, we’ll show you how to create new camel projects, which could be camel applications, custom components, or interceptors',1),(6259,'the scala dsl is also touched on here',1),(6260,'once your application is running in the wild, you’ll need to know how to manage it and monitor its operations',1),(6261,'chapter 12 discusses topics in this category ranging from viewing the camel logs to controlling camel with jmx, to extending the notification mechanism in camel so it works with your own custom monitoring application',1),(6262,'a topic you’ll need to read about before your camel application is in production is deployment',1),(6263,'camel was designed as a framework, and, as such, it has virtually unlimited deployment possibilities',1),(6264,'in chapter 13, we’ll discuss some of the most popular deployment options for camel',1),(6265,'we’ll also cover the various ways you can start and stop camel',1),(6266,'info in the last chapter of the book, chapter 14, we cover what we consider \"extra features\" of camel: routing with beans and using remoting to hide camel apis',1),(6267,'we think of these as extra features because they perform routing without using any of camel’s dsls and, in some cases, without any camel apis at all',1),(6268,'they use a quite different approach than what has been discussed throughout the book',1),(6269,'info283using transactionsto help explain what transactions are, let’s look at an example from real life',1),(6270,'you may well have ordered this book from manning’s online bookstore, and if you did, you likely followed these steps:1 find the book camel in action2 put the book into the basket3 maybe continue shopping and look for other books4 go to the checkout5 ...',1),(6271,'info284 chapter 9 using transactionswhat seems like an everyday scenario is actually a fairly complex series of events',1),(6272,'you have to put books in the basket before you can check out; you must fill in the shipping and credit card details before you can confirm the purchase; if your credit card is declined, the purchase won’t be confirmed; and so on',1),(6273,'the ultimate resolution of this transaction is either of two states: either the purchase was accepted and confirmed, or the purchase was declined, leaving your credit card balance uncharged',1),(6274,'this particular story involves computer systems because it’s about using an online bookstore, but the same main points happen when you shop in the supermarket',1),(6275,'either you leave the supermarket with your groceries or without',1),(6276,'in the software world, transactions are often explained in the context of sql statements manipulating database tables—updating or inserting data',1),(6277,'while the transaction is in progress, a system failure could occur, and that would leave the transaction’s participants in an inconsistent state',1),(6278,'that’s why the series of events is described as atomic: either they all are completed or they all fail—it’s all or nothing',1),(6279,'in transactional terms, they either commit or roll back',1),(6280,'note i expect you know about the database acid properties, so i won’t explain what atomic, consistent, isolated, and durable mean in the context of transactions',1),(6281,'if you aren’t familiar with acid, the wikipedia page is a good place to start learning about it: http://en',1),(6282,'in this chapter, we’ll first look at the reasons why you should use transactions (in the context of rider auto parts)',1),(6283,'then we’ll look at transactions in more detail and at spring’s transaction management, which orchestrates the transactions',1),(6284,'you’ll learn about the difference between local and global transactions and how to configure and use transactions',1),(6285,'toward the end of the chapter, you’ll see how to compensate for when you’re using resources that don’t support transactions',1),(6286,'1 why use transactions',1),(6287,'there are many good reasons why using transactions makes sense',1),(6288,'but before we focus on using transactions with camel, let’s look at what can go wrong when you don’t use transactions',1),(6289,'in this section, we’ll review an application rider auto parts uses to collect metrics that will be published to an incident management system',1),(6290,'we’ll see what goes wrong when the application doesn’t use transactions, and then we’ll apply transactions to the application',1),(6291,'1 the rider auto parts partner integration applicationlately rider auto parts has had a dispute with a partner about whether or not their service meets the terms of the service level agreement (sla)',1),(6292,'when such incidents occur, it’s often a labor-intensive task to investigate and remedy the incident',1),(6293,'in light of this, rider auto parts has developed an application to record what happens, as evidence for when a dispute comes up',1),(6294,'the application periodically measures    www',1),(6295,'info285why use transactions',1),(6296,'the communication between rider auto parts and its external partner servers',1),(6297,'the application records performance and uptime metrics, which are sent to a jms queue, where the data awaits further processing',1),(6298,'rider auto parts already has an existing incident management application with a web user interface for upper management',1),(6299,'what’s missing is an application to populate the collected metrics to the database used by the incident management application',1),(6300,'1 illustrates the scenario',1),(6301,'it’s a fairly simple task: a jms consumer listens for new messages on the jms queue b',1),(6302,'then the data is transformed from xml to sql c before it’s written to the database d',1),(6303,'in no time, you can come up with a route that matches figure 9',1),(6304,'1:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(6305,'org/schema/spring\">    <route id=\"partnertodb\">        <from uri=\"activemq:queue:partners\"/>          <bean ref=\"partner\" method=\"tosql\"/>           <to uri=\"jdbc:mydatasource\"/>              </route> </camelcontext>the reports are sent to the jms qu...',1),(6306,'xml version=\"1',1),(6307,'> <partner id=\"123\">    <date>200911150815</date>    <code>200</code>    <time>4387</time> </partner>the database table that stores the data is also mapped easily because it has the following layout:create table partner_metric     ( partner_id varcha...',1),(6308,'because you’re pragmatic and want to make a simple and elegant solution that anybody should be capable of maintaining in the future, you decide not to bring in thejmsqueue transform jdbc databasejmsqueuecameljms broker databaseb c dfigure 9',1),(6309,'1 partner reports are received from the jms broker, transformed in camel to sql format, and then written to the database',1),(6310,'info286 chapter 9 using transactionsbig guns with the java persistence api (jpa) or hibernate',1),(6311,'you put the following mapping code in a good old-fashioned bean',1),(6312,'xpath;public class partnerservicebean {    public string tosql(@xpath(\"partner/@id\") int id,                                @xpath(\"partner/date/text()\") string date,                        @xpath(\"partner/code/text()\") int statuscode,               ...',1),(6313,'append(\"insert into partner_metric (partner_id, time_occurred,                  status_code, perf_time) values (\");               sb',1),(6314,'append(\"\', \");        sb',1),(6315,'append(\"\', \");        sb',1),(6316,'append(statuscode)',1),(6317,'append(\"\', \");        sb',1),(6318,'append(responsetime)',1),(6319,'append(\"\')\");        return sb',1),(6320,'tostring();     } }coding the 10 or so lines in listing 9',1),(6321,'1 was faster than getting started on the jpa wagon or opening any heavyweight and proprietary mapping software',1),(6322,'the code speaks for itself, but let’s go over it anyway',1),(6323,'first you define the method to accept the four values to be mapped',1),(6324,'notice that you use the @xpath annotation to grab the data from the xml document b',1),(6325,'then you use a stringbuilder to construct the sql insert statement with the input values c',1),(6326,'to test this, you can crank up a unit test as follows:public void testsendpartnerreportintodatabase() throws exception {    string sql = \"select count(*) from partner_metric\";    assertequals(0, jdbc',1),(6327,'queryforint(sql));                 string xml = \"<',1),(6328,'xml version=\\\"1',1),(6329,'0\\\"',1),(6330,'>                 + <partner id=\\\"123\\\"><date>200911150815</date>                 + <code>200</code><time>4387</time></partner>\";    template',1),(6331,'sendbody(\"activemq:queue:partners\", xml);       thread',1),(6332,'sleep(5000);    assertequals(1, jdbc',1),(6333,'queryforint(sql));           }this test method outlines the principle',1),(6334,'first you check that the database is empty b',1),(6335,'then you construct sample xml data and send it to the jms queue using the camel producertemplate',1),(6336,'because the processing of the jms message is asynchronous, you must wait a bit to let it process',1),(6337,'at the end, you check that the database contains one row c',1),(6338,'listing 9',1),(6339,'1 using a bean to map from xml to sqlextracts data from xml payloadbconstructs sql statementcasserts there are no rows in databasebasserts one row was inserted into databasec    www',1),(6340,'info287why use transactions',1),(6341,'2 setting up the jms broker and the databaseto run this unit test, you need to use a local jms broker and a database',1),(6342,'you can use apache activemq as the jms broker and hsqldb (hypersql database) as the database',1),(6343,'hsqldb can be used as an in-memory database without the need to run it separately',1),(6344,'apache activemq is an extremely versatile broker, and it’s even embeddable in unit tests',1),(6345,'all you have to do is master a bit of spring xml magic to set up the jms broker and the database',1),(6346,'this is shown in listing 9',1),(6347,'<beans xmlns=\"http://www',1),(6348,'org/schema/beans\"    xmlns:xsi=\"http://www',1),(6349,'org/2001/xmlschema-instance\"    xmlns:broker=\"http://activemq',1),(6350,'org/schema/core\"    xsi:schemalocation=\"    http://www',1),(6351,'org/schema/beans    http://www',1),(6352,'org/schema/beans/spring-beans-2',1),(6353,'xsd    http://camel',1),(6354,'org/schema/spring    http://camel',1),(6355,'org/schema/spring/camel-spring',1),(6356,'xsd    http://activemq',1),(6357,'org/schema/core    http://activemq',1),(6358,'org/schema/core/activemq-core',1),(6359,'xsd\"><bean id=\"partner\" class=\"camelinaction',1),(6360,'partnerservicebean\"/><camelcontext id=\"camel\" xmlns=\"http://camel',1),(6361,'org/schema/spring\">    <route id=\"partnertodb\">        <from uri=\"activemq:queue:partners\"/>        <bean ref=\"partner\" method=\"tosql\"/>        <to uri=\"jdbc:mydatasource\"/>    </route> </camelcontext><bean id=\"activemq\"                              ...',1),(6362,'activemqcomponent\">    <property name=\"brokerurl\" value=\"tcp://localhost:61616\"/> </bean><broker:broker usejmx=\"false\" persistent=\"false\" brokername=\"localhost\">    <broker:transportconnectors>                                        <broker:transport...',1),(6363,'datasource',1),(6364,'drivermanagerdatasource\">    <property name=\"driverclassname\" value=\"org',1),(6365,'hsqldb',1),(6366,'jdbcdriver\"/>    <property name=\"url\" value=\"jdbc:hsqldb:mem:partner\"/>    <property name=\"username\" value=\"sa\"/>    <property name=\"password\" value=\"\"/> </bean></beans>in listing 9',1),(6367,'2, you first define the partner bean from listing 9',1),(6368,'1 as a spring bean that you’ll use in the route',1),(6369,'then, to allow camel to connect to activemq, you must define it as a camel component b',1),(6370,'the brokerurl property is configured with the url forlisting 9',1),(6371,'2 xml configuration for the camel route, jms broker, and databaseconfigures activemq componentbsets up embedded jms broker csets up databased    www',1),(6372,'info288 chapter 9 using transactionsthe remote activemq broker, which, in this example, happens to be running on the same machine',1),(6373,'then you set up a local embedded activemq broker c, which is configured to use tcp connectors',1),(6374,'finally, you set up the jdbc data source d',1),(6375,'the full source code for this example is located in the chapter9/riderautoparts-partner directory, and you can try out the example by running the following maven goal: mvn test -dtest=riderautopartspartnertestin the source code, you’ll also see how w...',1),(6376,'3 the story of the lost messagethe previous test is testing a positive situation, but what happens if the connection to the database fails',1),(6377,'how can you test that',1),(6378,'chapter 6 covered how to simulate a connection failure using camel interceptors',1),(6379,'writing a unit test is just a matter of putting all that logic in a single method, as shown in listing 9',1),(6380,'public void testnoconnectiontodatabase() throws exception {    routebuilder rb = new routebuilder() {                    public void configure() throws exception {            interceptsendtoendpoint(\"jdbc:*\")',1),(6381,'advicewith(context, rb);                              string sql = \"select count(*) from partner_metric\";    assertequals(0, jdbc',1),(6382,'queryforint(sql));       string xml = \"<',1),(6383,'xml version=\\\"1',1),(6384,'0\\\"',1),(6385,'>                 + <partner id=\\\"123\\\"><date>200911150815</date>listing 9',1),(6386,'3 simulating a connection failure that causes lost messages using vm instead of tcp with an embedded activemq brokerif you use an embedded activemq broker, you can use the vm protocol instead of tcp; doing so bypasses the entire tcp stack and is much...',1),(6387,'for example, in listing 9',1),(6388,'2, you could use vm://localhost instead of tcp://localhost:61616',1),(6389,'actually, the localhost in vm://localhost is the broker name, not a network address',1),(6390,'for example, you could use vm://mycoolbroker as the broker name and configure the name on the broker tag accordingly: brokername=\"mycoolbroker\"',1),(6391,'a plausible reason why you’re using vm://localhost in listing 9',1),(6392,'2 is that the engineers are lazy, and they changed the protocol from tcp to vm but left the broker name as localhost',1),(6393,'simulates no connection to databasebadvises simulation into existing routec    www',1),(6394,'info289transaction basics                 + <code>200</code><time>4387</time></partner>\";    template',1),(6395,'sendbody(\"activemq:queue:partners\", xml);       thread',1),(6396,'sleep(5000);       assertequals(0, jdbc',1),(6397,'queryforint(sql));          }to test a failed connection to the database, you need to intercept the routing to the database and simulate the error',1),(6398,'you do this with the routebuilder, where you define this scenario b',1),(6399,'next you need to add the interceptor with the existing route c, which is done using the advicewith method',1),(6400,'the remainder of the code is almost identical to the previous test, but you test that no rows are added to the database d',1),(6401,'note you can read about simulating errors using interceptors in chapter 6, section 6',1),(6402,'the test runs successfully',1),(6403,'but what happened to the message you sent to the jms queue',1),(6404,'it was not stored in the database, so where did it go',1),(6405,'it turns out that the message is lost because you’re not using transactions',1),(6406,'by default, the jms consumer uses auto-acknowledge mode, which means the client acknowledges the message when it’s received, and the message is dequeued from the jms broker',1),(6407,'what you must do instead is use transacted acknowledge mode',1),(6408,'we’ll look at how to do this in section 9',1),(6409,'3, but first we’ll discuss how transactions work in camel',1),(6410,'2 transaction basicsa transaction is a series of events',1),(6411,'the start of a transaction is often named begin, and the end is commit (or rollback if the transaction isn’t successfully completed)',1),(6412,'2 illustrates this',1),(6413,'to demonstrate the sequence in figure 9',1),(6414,'2, you could write what are known as locally managed transactions, where the transaction is managed manually in the code',1),(6415,'the following code illustrates this; it’s based on using jpa-managed transactions',1),(6416,'getentitymanager();entitytransaction tx = em',1),(6417,'gettransaction(); try {    tx',1),(6418,'begin();asserts no rows inserted into databasedevent 1 event 2 event n',1),(6419,'begin committransactionfigure 9',1),(6420,'2 a transaction is a series of events between begin and commit',1),(6421,'info290 chapter 9 using transactions    tx',1),(6422,'close();you start the transaction using the begin method',1),(6423,'then you have a series of events to do whatever work needs to be done',1),(6424,'at the end, you either commit or roll back the transaction, depending on whether an exception was thrown or not',1),(6425,'you may already be familiar with this principle, and transactions in camel use the same principle at a higher level of abstraction',1),(6426,'in camel transactions, you don’t invoke begin and commit methods from java code—you use declarative transactions, which are configured in the spring xml file',1),(6427,'we’ll look at the details of how this works in the next section, so don’t worry if it’s still a bit unclear',1),(6428,'what are the benefits of defining transactions declaratively',1),(6429,'with spring’s approach, you configure all this in the spring xml regardless of which runtime environment you’re using',1),(6430,'this removes the need for changing java code to match the targeted environment',1),(6431,'spring also makes it easy to set up diverse environments using minimal configuration',1),(6432,'spring’s transaction support is a great piece of technology, and that’s why camel leverages it instead of rolling out it’s own transaction framework',1),(6433,'note for more information on spring’s transaction management, see chapter 10, “transaction management,” in the spring framework reference documentation: http: //static',1),(6434,'springsource',1),(6435,'org/spring/docs/3',1),(6436,'x/spring-framework-reference/ html/transaction',1),(6437,'now that we’ve established that camel works with spring’s transaction support, let’s look at how they work together',1),(6438,'1 about spring’s transaction supportto understand how camel works together with spring’s transaction support, take a look at figure 9',1),(6439,'this figure shows that spring orchestrates the transaction while camel takes care of the rest',1),(6440,'4 adds more details, to illustrate that the jms broker also plays an active part in the transaction',1),(6441,'in this figure you can see how the jms broker, camel, and the spring jmstransactionmanager work together',1),(6442,'the jmstransactionmanager orchestrates the resources that participate in the transaction b, which in this example is the jms broker',1),(6443,'jmsqueue transform jdbccameltransactionmanagerspringtransaction requiredbegin commitfigure 9',1),(6444,'3 spring’s transactionmanagerorchestrates the transaction by issuing begins and commits',1),(6445,'the entire camel route is transacted, and the transaction is handled by spring',1),(6446,'info291transaction basicswhen a message has been consumed from the queue and fed into the camel application, camel issues a begin c to the jmstransactionmanager',1),(6447,'depending on whether the camel route completes with success or failure d, the jmstransactionmanager will ensure the jms broker commits or rolls back',1),(6448,'it’s now time to see how this works in practice',1),(6449,'in the next section, we’ll fix the lostmessage problem by adding transactions',1),(6450,'2 adding transactionsat the end of section 9',1),(6451,'1, you left rider auto parts with the problem of losing messages because you did not use transactions',1),(6452,'your task now is to apply transactions, which should remedy the problem',1),(6453,'you’ll start by introducing spring transactions to the spring xml file and adjusting the configuration accordingly',1),(6454,'listing 9',1),(6455,'4 shows how this is done',1),(6456,'<bean id=\"activemq\"      class=\"org',1),(6457,'activemqcomponent\">    <property name=\"transacted\" value=\"true\"/>               <property name=\"transactionmanager\" ref=\"txmanager\"/> </bean><bean id=\"txmanager\"                class=\"org',1),(6458,'jmstransactionmanager\"> listing 9',1),(6459,'4 xml configuration using spring transactionsjmstransactionmanagerspringjmsbrokerorchestratesjmsqueue transform jdbccameltransaction requiredcommitbeginbcdfigure 9',1),(6460,'4 the spring jmstransactionmanager orchestrates the transaction with the jms broker',1),(6461,'the camel route completes successfully and signals the commit to the jmstransactionmanager',1),(6462,'enables transacted acknowledge modebconfigures spring jmstransactionmanagerc    www',1),(6463,'info292 chapter 9 using transactions    <property name=\"connectionfactory\" ref=\"jmsconnectionfactory\"/>   </bean><bean id=\"jmsconnectionfactory\"      class=\"org',1),(6464,'activemqconnectionfactory\">    <property name=\"brokerurl\" value=\"tcp://localhost:61616\"/> </bean>the first thing you do is turn on transacted for the activemq component b, which instructs it to use transacted acknowledge mode',1),(6465,'then you need to refer to the transaction manager, which is a spring jmstransactionmanager c that manages transactions when using jms messaging',1),(6466,'the transaction manager needs to know how to connect to the jms broker, which refers to the connection factory',1),(6467,'in the jmsconnectionfactory definition, you configure the brokerurl to point at the jms broker',1),(6468,'tip the jmstransactionmanager has other options for configuring transaction behavior, such as timeouts, strategies for rollback on commit failure, and so on',1),(6469,'consult the spring documentation for details: http://static',1),(6470,'springsource',1),(6471,'org/ spring/docs/3',1),(6472,'x/spring-framework-reference/html/transaction',1),(6473,'so far you’ve only reconfigured beans in the spring xml file, which is mandatory when using spring',1),(6474,'in camel, itself, you have not yet configured anything in relation to transactions',1),(6475,'camel offers great convention over configuration for transaction support, so all you have to do is to add <transacted/> to the route, right after <from>, as highlighted here:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(6476,'org/schema/spring\">    <route id=\"partnertodb\">        <from uri=\"activemq:queue:partners\"/>        <transacted/>        <bean ref=\"partner\" method=\"tosql\"/>        <to uri=\"jdbc:mydatasource\"/>    </route> </camelcontext>when you specify <transacted...',1),(6477,'under the hood, camel looks up the spring transaction manager and leverages it',1),(6478,'this is the convention over configuration kicking in',1),(6479,'using transacted in the java dsl is just as easy, as shown here:from(\"activemq:queue:partners\")',1),(6480,'transacted()',1),(6481,'to(\"jdbc:mydatasource\");the convention over configuration only applies when you have a single spring transaction manager configured',1),(6482,'in more complex scenarios, with multiple transaction managers, you have to do additional configuration to set up transactions',1),(6483,'we’ll cover that in section 9',1),(6484,'info293transaction basicsnote when using transacted() in the java dsl, you must add it right after from() to ensure that the route is properly configured to use transactions',1),(6485,'this isn’t enforced in the dsl because the dsl is loosely defined to make it easy to maintain and develop camel',1),(6486,'there are a few tradeoffs such as this',1),(6487,'in this example, all you had to do to configure camel was to add <transacted/> in the route',1),(6488,'you relied on the transactional default configurations, which greatly reduces the effort required to set up the various bits',1),(6489,'in section 9',1),(6490,'4, we’ll go deeper into configuring transactions',1),(6491,'let’s see if this configuration is correct by testing it',1),(6492,'3 testing transactionswhen you test camel routes using transactions, it’s common to test with live resources, such as a real jms broker and a database',1),(6493,'for example, the source code for this book uses apache activemq and hsqldb as live resources',1),(6494,'we picked these because they can be easily downloaded using apache maven and they’re lightweight and embeddable, which makes them perfect for unit testing',1),(6495,'there is no upfront work needed to install them',1),(6496,'to demonstrate how this works, we’ll return to the rider auto parts example',1),(6497,'last time you ran a unit test, you lost the message when there was no connection to the database',1),(6498,'let’s try that unit test again, but this time with transactional support',1),(6499,'you can do this by running the following maven goal from the chapter9/riderautoparts-partner directory: mvn test -dtest=riderautopartspartnertxtestwhen you run the unit test, you’ll notice a lot of stacktraces printed on the console, and they’ll cont...',1),(6500,'connectexception: cannot connect to the database org',1),(6501,'transactedruntimecamelexception: java',1),(6502,'connectexception: cannot connect to the database        at org',1),(6503,'transactionerrorhandler',1),(6504,'wraptransacted runtimeexception(transactionerrorhandler',1),(6505,'transactionerrorhandler$1',1),(6506,'dointransaction withoutresult(transactionerrorhandler',1),(6507,'transaction',1),(6508,'transactioncallbackwithout result',1),(6509,'dointransaction(transactioncallbackwithoutresult',1),(6510,'transaction',1),(6511,'transactiontemplate',1),(6512,'execute (transactiontemplate',1),(6513,'transactionerrorhandler',1),(6514,'process (transactionerrorhandler',1),(6515,'info294 chapter 9 using transactionsyou can tell from the stacktrace that endpointmessagelistener (shown in bold) logged an exception at error level, which indicates the transaction is being rolled back',1),(6516,'this happens because endpointmessagelistener is a javax',1),(6517,'messagelistener, which is invoked when a new message arrives on the jms destination',1),(6518,'it will roll back the transaction if an exception is thrown',1),(6519,'so where is the message now',1),(6520,'it should be on the jms queue, so let’s add a little code to the unit test to check that',1),(6521,'add the following code at the end of the unit test method in listing 9',1),(6522,'object body = consumer',1),(6523,'receivebodynowait(\"activemq:queue:partners\"); assertnotnull(\"should not lose message\", body);now you can run the unit test to ensure that the message wasn’t lost—and the unit test will fail with this assertion error:java',1),(6524,'assertionerror: should not lose message    at org',1),(6525,'assert',1),(6526,'fail(assert',1),(6527,'assert',1),(6528,'asserttrue(assert',1),(6529,'assert',1),(6530,'assertnotnull(assert',1),(6531,'riderautopartspartnertxtest',1),(6532,'testnoconnectiontodatabase (riderautopartspartnertxtest',1),(6533,'java:96)we’re using transactions, and they’ve been configured correctly, but the message is still being lost',1),(6534,'what’s wrong',1),(6535,'if you dig into the stacktraces, you’ll discover that the message is always redelivered six times, and then no further redelivery is conducted',1),(6536,'tip if you’re using apache activemq, we recommend you pick up a copy of activemq in action, by bruce snyder, dejan bosanac, and rob davies',1),(6537,'among other things, this book explains how to use transactions and redelivery in more detail',1),(6538,'what happens is that activemq performs the redelivery according to its default settings, which say it will redeliver at most six times before giving up and moving the message to a dead letter queue',1),(6539,'this is, in fact, the dead letter channel eip',1),(6540,'you may remember that we covered this in chapter 5 (look back to figure 5',1),(6541,'activemq implements this pattern, which ensures that the broker won’t be doomed by a poison message that can’t be successfully processed and that would cause arriving messages to stack up on the queue',1),(6542,'instead of looking for the message on the partner’s queue, you should look for the message in the default activemq dead letter queue, which is named activemq',1),(6543,'if you change the code accordingly (as shown in bold), the test will pass:object body = consumer',1),(6544,'dlq\"); assertnotnull(\"should not lose message\", body);tests run: 2, failures: 0, errors: 0, skipped: 0you need to do one additional test to cover the situation where the connection to the database only fails at first, but works on subsequent calls',1),(6545,'here’s that test',1),(6546,'info295transaction basicspublic void testfailfirsttime() throws exception {    routebuilder rb = new routebuilder() {        public void configure() throws exception {            interceptsendtoendpoint(\"jdbc:*\")',1),(6547,'isequalto(\"false\"))',1),(6548,'throwexception(new connectexception(                                 \"cannot connect to the database\"))',1),(6549,'advicewith(context, rb);    string sql = \"select count(*) from partner_metric\";    assertequals(0, jdbc',1),(6550,'queryforint(sql));    string xml = \"<',1),(6551,'xml version=\\\"1',1),(6552,'0\\\"',1),(6553,'>                 + <partner id=\\\"123\\\"><date>200911150815</date>                 + <code>200</code><time>4387</time></partner>\";    template',1),(6554,'sendbody(\"activemq:queue:partners\", xml);    thread',1),(6555,'sleep(5000);    assertequals(1, jdbc',1),(6556,'queryforint(sql));    object dlq = consumer',1),(6557,'dlq\");    assertnull(\"should not be in the dlq\", dlq);                        }the idea is to throw a connectionexception only the first time',1),(6558,'you do this by relying on the fact that any message consumed from a jms destination has a set of standard jms headers, and the jmsredelivered header is a boolean type indicating whether the jms message is being redelivered or not',1),(6559,'the interceptor logic is done in a camel routebuilder, so you have the full dsl at your disposal',1),(6560,'you use the content-based router eip b to test the jmsredelivered header and only throw the exception if it’s false, which means it’s the first delivery',1),(6561,'the rest of the unit test should verify correct behavior, so you first check that the database is empty before sending the message to the jms queue',1),(6562,'then you sleep a bit to let the routing complete',1),(6563,'after completion, you check that the database has one row',1),(6564,'because you previously were tricked by the jms broker’s dead letter queue, you also check that it’s empty c',1),(6565,'the example we’ve just covered uses what are called local transactions, because they’re based on using only a single resource in the transaction—spring was only orchestrating the jms broker',1),(6566,'but there was also the database resource, which, in the example, was not under transactional control',1),(6567,'leveraging both the jms broker and the database as resources participating in the same transaction requires more work, and the next section explains about using single and multiple resources in a transaction',1),(6568,'first, we’ll look at this from the eip perspective',1),(6569,'listing 9',1),(6570,'5 testing a simulated rollback on the first try and a commit on the second trycauses failure first timebasserts message not in dlqc    www',1),(6571,'info296 chapter 9 using transactions9',1),(6572,'3 the transactional client eip the transactional client eip distills the problem of how a client can control transactions when working with messaging',1),(6573,'it’s depicted in figure 9',1),(6574,'5 shows how this pattern was portrayed in gregor hohpe and bobby woolf’s enterprise integration patterns book, so it may be a bit difficult to understand how it relates to using transactions with camel',1),(6575,'what the figure shows is that both a sender and a receiver can be transactional by working together',1),(6576,'when a receiver initiates the transaction, the message is neither sent nor removed from the queue until the transaction is committed',1),(6577,'when a sender initiates the transaction, the message isn’t available to the consumer until the transaction has been committed',1),(6578,'6 illustrates this principle',1),(6579,'messagesendermessagetransactionreceivermessagetransactiontransactionalproducertransactionalconsumerfigure 9',1),(6580,'5 a transactional client handles the client’s session with the receivers so the client can specify transaction boundaries that encompass the receiver',1),(6581,'consumer transactionalclient producer queue bqueue amessagemessagearrivedmessagedeletedmessagenot arrivedmessagerouteinprogresscommitqueue a queue bin progressfigure 9',1),(6582,'6 a message is being moved from queue a to queue b',1),(6583,'transactions ensure the message is moved in what appears to be an atomic operation',1),(6584,'info297the transactional client eip the top section of figure 9',1),(6585,'6 illustrates the route using eip icons, with a message being moved from queue a to b using a transaction',1),(6586,'the remainder of the figure shows a use case when one message is being moved',1),(6587,'the middle section shows a snapshot in time when the message is being moved',1),(6588,'the message still resides in queue a and has not yet arrived in queue b',1),(6589,'the message stays on queue a until a commit is issued, which ensures that the message isn’t lost in case of a severe failure',1),(6590,'the bottom section shows the situation when a commit has been issued',1),(6591,'the message is then deleted from queue a and inserted into queue b',1),(6592,'transactional clients make this whole process appear as an atomic, isolated, and consistent operation',1),(6593,'when talking about transactions, we need to distinguish between single- and multiple-resource transactions',1),(6594,'the former are also known as local transactions and the latter as global transactions',1),(6595,'in the next two sections, we’ll look at these two flavors',1),(6596,'1 using local transactionsfigure 9',1),(6597,'7 depicts the situation of using a single resource, which is the jms broker',1),(6598,'in this situation, the jmstransactionmanager orchestrates the transaction with the single participating resource, which is the jms broker b',1),(6599,'the jmstransactionmanager from spring can only orchestrate jms-based resources, so the database isn’t orchestrated',1),(6600,'in the rider auto parts example in section 9',1),(6601,'1, the database didn’t participate as a resource in the transaction, but the approach seemed to work anyway',1),(6602,'that wasjmstransactionmanagerspringjmsbroker databaseorchestratesjmsqueue transform jdbccameltransaction requiredcommitbeginbcfigure 9',1),(6603,'7 using jmstransactionmanager as a single resource in a transaction',1),(6604,'the database isn’t a participant in the transaction',1),(6605,'info298 chapter 9 using transactionsbecause if the database decides to roll back the transaction, it will throw an exception that the camel transactionerrorhandler propagates back to the jmstransactionmanager, which reacts accordingly and issues a ro...',1),(6606,'this scenario isn’t exactly equivalent to enrolling the database in the transaction, because it still has failure scenarios that could leave the system in an inconsistent state',1),(6607,'for example, the jms broker could fail after the database is successfully updated, but before the jms message is committed',1),(6608,'to be absolutely sure that both the jms broker and the database are in sync in terms of the transaction, you must use the much heavier global transactions',1),(6609,'let’s take a look at that now',1),(6610,'2 using global transactionsusing transactions with a single resource is appropriate when a single resource is involved',1),(6611,'but the situation changes dramatically when you need to span multiple resources in the same transaction, such as jms and jdbc resources, as depicted in figure 9',1),(6612,'in this figure, we’ve switched to using the jtatransactionmanager, which handles multiple resources',1),(6613,'camel consumes a message from the queue, and a begin is issued b',1),(6614,'the message is processed, updating the database, and it completes successfully c',1),(6615,'so what is the jtatransactionmanager, and how is it different from the jmstransactionmanager used in the previous section (see figure 9',1),(6616,'to answer this, you first need to learn a bit about global transactions and where the java transaction api (jta) fits in',1),(6617,'jtatransactionmanagerspringjmsbroker databaseorchestratesjmsqueue transform jdbccameltransaction requiredcommitorchestratesbegin bcfigure 9',1),(6618,'8 using jtatransactionmanager with multiple resources in a transaction',1),(6619,'both the jms broker and the database participate in the transaction',1),(6620,'info299the transactional client eip in java, jta is an implementation of the xa standard protocol, which is a global transaction protocol',1),(6621,'to be able to leverage xa, the resource drivers must be xa-compliant, which some jdbc and most jms drivers are',1),(6622,'jta is part of the java ee specification, which means that any java ee-compliant application server must provide jta support',1),(6623,'this is one of the benefits of java ee servers, which have jta out of the box, unlike some lightweight alternatives, such as apache tomcat',1),(6624,'using jta outside a java ee server takes some work to set up because you have to find and use a jta transaction manager, such as one of these:■ jotm—http://jotm',1),(6625,'org/xwiki/bin/view/main/webhome■ atomikos—http://www',1),(6626,'bethen you need to figure out how to install and use it in your container and unit tests',1),(6627,'the good news is that using jta with camel and spring is just a matter of configuration',1),(6628,'note for more information on jta, see the wikipedia page on the subject: http://en',1),(6629,'org/wiki/java_transaction_api',1),(6630,'xa is also briefly discussed: http://en',1),(6631,'when using jta (xa), there are a couple of differences from using local transactions',1),(6632,'first, you have to use xa-capable drivers, which means you have to use the activemqxaconnectionfactory to let activemq participate in global transactions',1),(6633,'<bean id=\"jmsxaconnectionfactory\"      class=\"org',1),(6634,'activemqxaconnectionfactory\">    <property name=\"brokerurl\" value=\"tcp://localhost:61616\"/> </bean>the same applies for the jdbc driver—you need to use an xa-capable driver',1),(6635,'hsqldb doesn’t support xa, so you can fall back and use an atomikos feature that’s capable of simulating xa for non-xa jdbc drivers:<bean id=\"mydatasource\"      class=\"com',1),(6636,'atomikosnonxadatasourcebean\">    <property name=\"uniqueresourcename\" value=\"hsqldb\"/>    <property name=\"driverclassname\" value=\"org',1),(6637,'hsqldb',1),(6638,'jdbcdriver\"/>    <property name=\"url\" value=\"jdbc:hsqldb:mem:partner\"/>    <property name=\"user\" value=\"sa\"/>    <property name=\"password\" value=\"\"/>    <property name=\"poolsize\" value=\"3\"/> </bean>in a real production system, you should prefer to us...',1),(6639,'you can find out more about this at the atomikos website listed previously',1),(6640,'having configured the xa drivers, you also need to use the spring jtatransactionmanager',1),(6641,'it should refer to the real xa transaction manager, which is atomikos in this example:    www',1),(6642,'info300 chapter 9 using transactions<bean id=\"jtatransactionmanager\"      class=\"org',1),(6643,'transaction',1),(6644,'jtatransactionmanager\">    <property name=\"transactionmanager\" ref=\"atomikostransactionmanager\"/>    <property name=\"usertransaction\" ref=\"atomikosusertransaction\"/> </bean>the remainder of the configuration involves configuring atomikos itself, whic...',1),(6645,'suppose you want to add an additional step in the route shown in figure 9',1),(6646,'you’ll process the message after it has been inserted into the database',1),(6647,'this additional step will influence the outcome of the transaction, whether or not it throws an exception',1),(6648,'suppose it does indeed throw an exception, as portrayed in figure 9',1),(6649,'9, the message is being routed b and, at the last step in the route (in the bottom-right corner with the x), it fails by throwing an exception',1),(6650,'the jtatransactionmanager handles this by issuing rollbacks c to both the jms broker and the database',1),(6651,'because this scenario uses global transactions, both the database and the jms broker will roll back, and the final result is as if the entire transaction hadn’t taken place',1),(6652,'jtatransactionmanagerspringjmsbroker databasejmsqueue transform jdbccameltransaction requiredrollbackorchestratesproce sorchestratesbegin bcfigure 9',1),(6653,'9 a failure to process a message at the last step in the route causes the jtatransactionmanager to issue rollbacks to both the jms broker and the database',1),(6654,'info301configuring and using transactionsthe source code for the book contains this example in the chapter9/xa directory',1),(6655,'you can test it using the following maven goals:mvn test -dtest=atomikosxacommittest mvn test -dtest=atomikosxarollbackbeforedbtest mvn test -dtest=atomikosxarollbackafterdbtestwe’ll leave the topic of global transactions here and move on to learn mo...',1),(6656,'4 configuring and using transactionsso far, we’ve used convention over configuration when configuring transactions in camel, by just adding <transacted/> to the route',1),(6657,'this is often all you’ll need to use, but there can be situations where you need more fine-grained control, such as when specifying transaction propagation settings',1),(6658,'that’s the first thing we’ll look at in this section',1),(6659,'then we’ll look at how transactions work when multiple routes are used',1),(6660,'at the end of the section, we’ll look at how you can return custom responses to the caller when a transaction fails',1),(6661,'1 configuring transactionswhen you configure transactions, you’ll come across the term transaction propagation',1),(6662,'in this section, you’ll learn what that term means and why it’s related to configuring transactions',1),(6663,'if you have ever worked with enterprise javabeans (ejbs), you may be familiar with transaction propagation already',1),(6664,'transaction propagation options specify what will happen if a method is invoked and a transaction context already exists',1),(6665,'for example, should it join the existing transaction',1),(6666,'should a new transaction be started',1),(6667,'or should it fail',1),(6668,'in most use cases, you end up using one of two options: joining the existing transaction (propagation_required) or starting a new transaction (propagation_ requires_new)',1),(6669,'to use transaction propagation, you must configure it in the spring xml file as shown in the following example',1),(6670,'this example uses propagation_required as indicated in bold:<bean id=\"required\"                                                      class=\"org',1),(6671,'springtransactionpolicy\">     <property name=\"transactionmanager\" ref=\"txmanager\"/>      <property name=\"propagationbehaviorname\"              value=\"propagation_required\"/> </bean><camelcontext id=\"camel\" xmlns=\"http://camel',1),(6672,'org/schema/spring\">    <route id=\"partnertodb\">        <from uri=\"activemq:queue:partners\"/>        <transacted ref=\"required\"/>                            <bean ref=\"partner\" method=\"tosql\"/>        <to uri=\"jdbc:mydatasource\"/>    </route> </camelc...',1),(6673,'info302 chapter 9 using transactionsfirst you define a bean with the id \"required\", which is a springtransactionpolicy type b',1),(6674,'the bean must refer to both the transaction manager and the choice of transaction propagation to be used',1),(6675,'in the camel route, you then refer to the required bean from within the <transacted> tag, using the ref attribute c',1),(6676,'if you want to use propagation_requires_new, it’s just a matter of changing the property on the bean as shown in bold:<property name=\"propagationbehaviorname\"          value=\"propagation_requires_new\"/if you have ever used spring transactions, you ma...',1),(6677,'springtransactionpolicy\">     <property name=\"transactionmanager\" ref=\"txmanager\"/>  </bean>there is no practical difference between these two styles—it’s a matter of taste as to which you prefer',1),(6678,'notice that you don’t have to specify the propagationbehaviorname property on the bean',1),(6679,'this is because camel uses convention over configuration to detect whether the bean id matches any of the known propagation behavior names',1),(6680,'in this example, the bean id is \"propagation_required\", which tells camel to use this propagating behavior',1),(6681,'all together, it allows you to avoid repeating yourself by specifying the propagationbehaviorname property as well',1),(6682,'let’s look at what else is specified by convention over configuration',1),(6683,'using convention over configuration for transactions in camel routesin section 9',1),(6684,'2, you used the default transaction configuration, which relies on convention over configuration',1),(6685,'this works well when you want to use the required transaction propagation, because it removes the need for some boilerplate configuration',1),(6686,'the first example from section 9',1),(6687,'2 could be reduced to only the camel route, as follows:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(6688,'org/schema/spring\">    <route id=\"partnertodb\">        <from uri=\"activemq:queue:partners\"/>        <transacted/>        <bean ref=\"partner\" method=\"tosql\"/>        <to uri=\"jdbc:mydatasource\"/>    </route> </camelcontext>all you do here is declare <...',1),(6689,'camel will use propagation_required by convention, and will look up the spring transaction manager for you',1),(6690,'note this is a common situation',1),(6691,'usually all you have to do is configure the spring transaction manager and add <transacted/> in the camel route',1),(6692,'info303configuring and using transactionsyou have now learned how to configure and use transactions with camel',1),(6693,'but there’s more to learn',1),(6694,'in the next section, we’ll look at how transactions work when you have multiple routes and when you need different propagation behavior',1),(6695,'2 using transactions with multiple routesin camel, it’s common to have multiple routes and to let one route reuse another by sending messages to it',1),(6696,'in this section, we’ll look at how this works when one or all routes are transacted',1),(6697,'then we’ll look at some of the implications of using transactions with request-response messaging style',1),(6698,'we’ll start out simply and look at what happens when you use a non-transacted route from a transacted route',1),(6699,'using transactions with a non-transacted routelisting 9',1),(6700,'6 shows the parts of a unit test that you can use to see what happens when a transacted route calls a non-transacted route',1),(6701,'public class txtonontxtest extends camelspringtestsupport {protected abstractxmlapplicationcontext createapplicationcontext() {    return new classpathxmlapplicationcontext(\"spring-context',1),(6702,'xml\");  }protected int getexpectedroutecount() {    return 0; }protected routebuilder createroutebuilder() throws exception {    return new springroutebuilder() {        public void configure() throws exception {            from(\"activemq:queue:a\")',1),(6703,'transacted()',1),(6704,'contains(\"camel\"))',1),(6705,'transform(constant(\"camel rocks\"))',1),(6706,'contains(\"donkey\"))',1),(6707,'throwexception(new illegalargumentexception(                                \"donkeys not allowed\"))',1),(6708,'otherwise()',1),(6709,'transform(body()',1),(6710,'prepend(\"hello \"));        }    }; }in listing 9',1),(6711,'6, you first import the spring xml file, which contains all the spring configuration to set up the jms broker, spring, and the camel activemq component',1),(6712,'the content of the spring-context',1),(6713,'xml file is the same as in listing 9',1),(6714,'listing 9',1),(6715,'6 unit test with a transacted route calling a non-transacted routetransacted routebnon-transacted routec    www',1),(6716,'info304 chapter 9 using transactions the getexpectedroutecount method may at first seem a bit odd, but it’s needed to indicate to camelspringtestsupport that the spring xml file doesn’t contain any camel routes—it does this by saying that there are 0...',1),(6717,'first, the transacted route b moves messages from queue a to b',1),(6718,'during this move, the message is also processed by the non-transacted route c, which transforms the message using a content-based router',1),(6719,'notice that if the message contains the word \"donkey\", the route will force a failure by throwing an exception',1),(6720,'you can run this unit test by running the following maven goal from the chapter9/ multuple-routes directory: mvn test -dtest=txtonontxtestthe unit test has three methods: two test situations that commit the transaction, and one rolls back the transac...',1),(6721,'here are two tests showing the commit and rollback situations: public void testwithcamel() throws exception {    template',1),(6722,'sendbody(\"activemq:queue:a\", \"hi camel\");    object reply = consumer',1),(6723,'receivebody(\"activemq:queue:b\", 10000);    assertequals(\"camel rocks\", reply); }public void testwithdonkey() throws exception {    template',1),(6724,'sendbody(\"activemq:queue:a\", \"donkey\");    object reply = consumer',1),(6725,'receivebody(\"activemq:queue:b\", 10000);    assertnull(\"there should be no reply\", reply);    reply = consumer',1),(6726,'dlq\", 10000);    assertnotnull(\"it should have been moved to dlq\", reply); }what can you learn from this',1),(6727,'the unit test proves that when a transacted route uses a non-transacted route, the transactional behavior works as if all routes are transacted, which is what you’d expect',1),(6728,'the last unit test proves that when the non-transacted route fails by throwing an exception, the transacted route detected this and issued a rollback',1),(6729,'you can see this because the message is moved to the jms broker’s dead letter queue',1),(6730,'this is great news, because there are no surprises',1),(6731,'it’s safe for transacted routes to reuse existing non-transacted routes',1),(6732,'note the transaction manager requires messages to be processed in the same thread context, to support the transaction',1),(6733,'this means that when you use multiple routes, you must link them together in a way that ensures the message is processed in the same thread',1),(6734,'using the direct component does this—the direct component was used in listing 9',1),(6735,'6 to link the two routes together',1),(6736,'this won’t work with the seda component, which routes messages using another thread',1),(6737,'let’s continue and see what happens when both routes are transacted',1),(6738,'info305configuring and using transactionsusing transactions with another transacted routenow let’s modify the unit test from listing 9',1),(6739,'6 and create a new situation, where both routes are transacted, and see what happens',1),(6740,'public void configure() throws exception {    from(\"activemq:queue:a\")',1),(6741,'transacted()',1),(6742,'transacted()',1),(6743,'contains(\"camel\"))',1),(6744,'otherwise()',1),(6745,'throwexception(new illegalargumentexception                        (\"unsupported animal\")); }you can run this example by running the following maven goal:mvn test -dtest=txtotxtestonce again, the unit test will prove that there are no surprises here',1),(6746,'when the exception is thrown, the entire route is rolled back, which is what you’d expect',1),(6747,'when the message hits the second route and the second transacted, it participates in the existing transaction',1),(6748,'this is because propagation_required is the default propagation behavior when using transacted',1),(6749,'next, we’ll make it more challenging by using two different transaction propagations',1),(6750,'using multiple transactions with one exchangein some situations, you may need to use multiple transactions with the same exchange, as illustrated in figure 9',1),(6751,'10 an exchange is being routed in camel',1),(6752,'it starts off using the required transaction, and then you need to use another transaction that’s independent of the existing transaction',1),(6753,'you can do this by using propagation_requires_new, which will start a new transaction regardless of whether an existing transaction existslisting 9',1),(6754,'7 two transacted routes propagation_requiredpropagation_requires_newtransaction 1 transaction 2exchangefigure 9',1),(6755,'10 using two independent transactions in a single exchange    www',1),(6756,'info306 chapter 9 using transactionsor not',1),(6757,'when the exchange completes, the transaction manager will issue commits to these two transactions, which ensures that they both commit at the same point',1),(6758,'10 requires the transaction manager to support the suspension and resumption of transactions',1),(6759,'this isn’t supported by all transaction manager implementations',1),(6760,'in camel, a route can only be configured to use at most one transaction propagation, which means figure 9',1),(6761,'10 must use two routes',1),(6762,'the first route uses propagation_ required and the second route uses propagation_requires_new',1),(6763,'suppose you have an application that updates orders in a database',1),(6764,'the application must store all incoming orders in an audit log, and then it either updates or inserts the order in the order database',1),(6765,'the audit log should always insert a record, even if subsequent processing of the order fails',1),(6766,'implementing this in camel should be done using two routes, as follows:from(\"direct:ordertodb\")',1),(6767,'transacted(\"propagation_required\")',1),(6768,'to(\"direct:saveorderindb\");   from(\"direct:saveorderindb\")',1),(6769,'class)',1),(6770,'markrollbackonlylast()',1),(6771,'transacted(\"propagation_requires_new\")',1),(6772,'beanref(\"orderdao\", \"updateorinsertorder\");the first route uses propagation_required to make the route transactional',1),(6773,'the second route, in contrast, uses propagation_requires_new to ensure that a new transaction is used within this route',1),(6774,'now suppose an error occurs while processing the second route—you could either let both routes roll back, or only roll back the second route',1),(6775,'camel will, by default, roll back both routes, and because you only want the second route to roll back, you have to tell camel this',1),(6776,'this is done by declaring a route-level onexception where you leverage markrollbackonlylast, to instruct camel to only roll back the last (current) transaction',1),(6777,'if you wanted to roll back both routes, you could either remove the onexception declaration or use markrollbackonly instead of markrollbackonlylast',1),(6778,'in the next section, we’ll return to rider auto parts and look at an example that covers a common use case: using web services together with transactions',1),(6779,'how do you return a custom web service response if a transaction fails',1),(6780,'3 returning a custom response when a transaction failsrider auto parts has a camel application that exposes a web service to a selected number of business partners',1),(6781,'the partners use this application to submit orders',1),(6782,'11 illustrates the application',1),(6783,'as you can see in the figure, the business partners invoke a web service to submit an order b',1),(6784,'the received order is stored in a database for audit purposes c',1),(6785,'info307configuring and using transactionsorder is then processed by the enterprise resource planning (erp) system d, and a reply is returned to the waiting business partner e',1),(6786,'the web service is deliberately kept simple so partners can easily leverage it with their it systems',1),(6787,'there is a single return code that indicates whether or not the order succeeded or failed',1),(6788,'the following code snippet is part of the wsdl definition for the reply (outputorder):<xs:element name=\"outputorder\">    <xs:complextype>        <xs:sequence>            <xs:element type=\"xs:string\" name=\"code\"/>        </xs:sequence>    </xs:complex...',1),(6789,'this means that the camel application must deal with any thrown exceptions and return a custom failure message, instead of propagating the thrown exception back to the web service',1),(6790,'your camel application needs to do the following three things:■ catch the exception and handle it to prevent it propagating back■ mark the transaction to roll back■ construct a reply message with a code value of \"error\"camel can support such complex ...',1),(6791,'what you do is add an onexception to the camelcontext, as shown here:<onexception>    <exception>java',1),(6792,'exception</exception>    <handled><constant>true</constant></handled>    <transform><method bean=\"order\" method=\"replyerror\"/></transform>    <rollback markrollbackonly=\"true\"/> </onexception>you first tell camel that this onexception should trigger ...',1),(6793,'you then mark the exception as handled, which removes the exceptionorderweb serviceprocessordercamelpartnerrider autopartserpordercopyb c defigure 9',1),(6794,'11 a web service used by business partners to submit orders',1),(6795,'a copy of the order is stored in a database before it’s processed by the erp system',1),(6796,'info308 chapter 9 using transactionsfrom the exchange, because you want to use a custom reply message instead of the thrown exception',1),(6797,'note the <rollback/> definition must always be at the end of the onexception because it stops the message from being further routed',1),(6798,'that means you must have prepared the reply message before you issue the <rollback/>',1),(6799,'to construct the reply message, you use the order bean, invoking its replyerror method:public outputorder replyerror(exception cause) {     outputorder error = new outputorder();    error',1),(6800,'setcode(\"error: \" + cause',1),(6801,'getmessage());    return error; }this is easy to do, as you can see',1),(6802,'you first define the replyerror method to have an exception as a parameter—this will contain the thrown exception',1),(6803,'you then create the outputorder object, which you populate with the \"error\" text and the exception message',1),(6804,'the source code for the book contains this example in the chapter9/ riderautoparts-order directory',1),(6805,'you can start the application by using the following maven goal: mvn camel:runthen you can send web service requests to http://localhost:9000/order',1),(6806,'the wsdl is accessible at http://localhost:9000/order',1),(6807,'wsdl',1),(6808,'to work with this example, you need to use web services',1),(6809,'org/) is a popular application for testing with web services',1),(6810,'it’s also easy to set up and get started',1),(6811,'you create a new project and import the wsdl file from http: //localhost:9000/order',1),(6812,'wsdl',1),(6813,'then you create a sample web service request and fill in the request parameters, as shown in figure 9',1),(6814,'you then send the request by clicking the green play button, and it will display the reply in the pane on the right side',1),(6815,'12 shows an example where we caused a failure to occur',1),(6816,'our example behaves according to what you specify in the refno field',1),(6817,'you can force different behavior by specifying either fatal or fail-once in the refno field',1),(6818,'12 a web service message causes the transaction to roll back, and a custom reply message is returned',1),(6819,'info309compensating for unsupported transactionswill cause the request to succeed',1),(6820,'as figure 9',1),(6821,'12 shows, we entered fatal, which causes an exception to occur and an error reply to be returned',1),(6822,'so far we’ve been using resources that support transactions, such as jms and jdbc, but the majority of components don’t support transactions',1),(6823,'so what can you do instead',1),(6824,'in the next section, we’ll look at compensating when transactions aren’t supported',1),(6825,'5 compensating for unsupported transactionsthe number of resources that can participate in transactions is limited—they’re mostly confined to jms- and jdbc-based resources',1),(6826,'this section covers what you can do to compensate for the absence of transactional support in other resources',1),(6827,'compensation, in camel, involves the unit of work concept',1),(6828,'first, we’ll look at how a unit of work is represented in camel and how you can use this concept',1),(6829,'then we’ll walk through an example demonstrating how the unit of work can help simulate the orchestration that a transaction manager does',1),(6830,'we’ll also discuss how you can use a unit of work to compensate for the lack of transactions by doing the work that a transaction manager’s rollback would do in the case of failure',1),(6831,'1 introducing unitofworkthe concept of the unit of work is to batch together a group of tasks as a single coherent unit',1),(6832,'the idea is to use the unit of work as a way of mimicking transactional boundaries',1),(6833,'in camel the unit of work is represented by the org',1),(6834,'unitofwork interface offering a range of methods including the following:void addsynchronization(synchronization synchronization); void removesynchronization(synchronization synchronization); void done(exchange exchange);the addsynchronization and re...',1),(6835,'the done method is invoked when the unit of work is complete, and it invokes the registered callbacks',1),(6836,'the synchronization callback is the interesting part for camel end users because it’s the interface you use to execute custom logic when an exchange is complete',1),(6837,'it’s represented by the org',1),(6838,'synchronization interface and offers these two methods:void oncomplete(exchange exchange); void onfailure(exchange exchange);when the exchange is done, either the oncomplete or onfailure method is invoked, depending on whether the exchange failed or not',1),(6839,'13 illustrates how these concepts are related to each other',1),(6840,'as you can see from this figure, each exchange has exactly one unitofwork, which you can access using the getunitofwork method from the exchange',1),(6841,'the unitofwork is private to the exchange and is not shared with others',1),(6842,'info310 chapter 9 using transactionswhen an exchange is done being routed, you hit the end boundary of the unitofwork, and the registered synchronization callbacks are invoked one by one',1),(6843,'this is the same mechanism the camel components leverage to add their custom synchronization callbacks to the exchange',1),(6844,'for example, the file and ftp components use this mechanism to perform after-processing operations such as moving or deleting processed files',1),(6845,'tip use synchronization callbacks to execute any after-processing you want done when the exchange is complete',1),(6846,'don’t worry about throwing exceptions from your custom synchronization—camel will catch those and log them at warn level, and will then continue to invoke the next callback',1),(6847,'this ensures that all callbacks are invoked even if one happens to fail',1),(6848,'a good way of understanding how this works is to review an example, which we’ll do now',1),(6849,'2 using synchronization callbacksrider auto parts has a camel application that sends email messages containing invoice details to customers',1),(6850,'first, the email content is generated, and then, before the email is sent, a backup of the email is stored in a file for reference',1),(6851,'whenever an invoice is to be sent to a customer, the camel application is involved',1),(6852,'14 shows the principle of this application',1),(6853,'imagine what would happen if there were a problem sending an email',1),(6854,'you can’t use transactions to roll back, because filesystem resources can’t participate in transactions',1),(6855,'instead, you can perform custom logic, which compensates for the failure by deleting the file',1),(6856,'getunitofworkgetin getoutidexchangeaddsynchronizationremovesynchronizationdoneidunitofworkoncompleteonfailuresynchronizationhas*has1figure 9',1),(6857,'13 an exchange has one unitofwork, which in turn has from zero to many synchronizations',1),(6858,'how unitofwork is orchestratedcamel will automatically inject a new unitofwork into an exchange when it’s routed',1),(6859,'this is done by an internal processor, unitofworkprocessor, which is involved in the start of every route',1),(6860,'when the exchange is done, this processor invokes the registered synchronization callbacks',1),(6861,'the unitofwork boundaries are always at the beginning and end of camel routes',1),(6862,'info311compensating for unsupported transactionsthe compensation logic is trivial to implement, as shown here:public class filerollback implements synchronization {    public void oncomplete(exchange exchange) {    }    public void onfailure(exchange...',1),(6863,'class);        log',1),(6864,'warn(\"failure occurred so deleting backup file: \" + name);        fileutil',1),(6865,'deletefile(new file(name));    } }in the onfailure method, you delete the backup file, retrieving the filename used by the camel file component from the exchange',1),(6866,'what you must do next is instruct camel to use the filerollback class to perform this compensation',1),(6867,'to do so, you can add it to the unitofwork by using the addsynchronization method, which was depicted in figure 9',1),(6868,'this can be done using the java dsl as highlighted:public void configure() throws exception {    from(\"direct:confirm\")',1),(6869,'process(new processor() {            public void process(exchange exchange) throws exception {                exchange',1),(6870,'class, \"createmail\")',1),(6871,'log(\"trying to send mail to ${header',1),(6872,'class, \"sendmail\")',1),(6873,'log(\"mail send to ${header',1),(6874,'to}\"); }the source code for the book contains this example in the chapter9/uow directory',1),(6875,'you can try it by using the following maven goal:mvn test -dtest=filerollbacktestif you run the example, it will output something like the following to the console: mail copytranslate send emailinvoicecamelfigure 9',1),(6876,'14 emails are sent to customers listing their invoice details',1),(6877,'before the email is sent, a backup is stored in the file system',1),(6878,'info312 chapter 9 using transactionsinfo  route1 - saving mail backup fileinfo  route1 - trying to send to fatal error defaulterrorhandler - failed delivery for exchangeid:  9edc1ecb-43be-43ee-9f32-7371452967bd',1),(6879,'warn  filerollback - failure occurred so deleting backup file:  target/mail/backup/02630ec4-724d-4e73-8eb6-c969720578cone thing that may bother you is that you must use an inlined processor to add the filerollback class as a synchronization',1),(6880,'camel offers a convenient method on the exchange, so you could do it with less code:exchange',1),(6881,'addoncompletion(new filerollback());but it still requires the inlined processor',1),(6882,'isn’t there a more convenient way',1),(6883,'yes there is, and that’s where oncompletion comes into the picture',1),(6884,'3 using oncompletiononcompletion takes the synchronization into the world of routing, enabling you to easily add the filerollback class as synchronization',1),(6885,'so let’s see how it’s done',1),(6886,'oncompletion is available in both java dsl and spring xml variations',1),(6887,'here’s how oncompletion is used with spring xml',1),(6888,'<bean id=\"orderservice\" class=\"camelinaction',1),(6889,'orderservice\"/><bean id=\"filerollback\" class=\"camelinaction',1),(6890,'filerollback\"/><camelcontext xmlns=\"http://camel',1),(6891,'org/schema/spring\">    <oncompletion onfailureonly=\"true\">        <bean ref=\"filerollback\" method=\"onfailure\"/>    </oncompletion>    <route>        <from uri=\"direct:confirm\"/>        <bean ref=\"orderservice\" method=\"createmail\"/>        <log messag...',1),(6892,'to}\"/>        <bean ref=\"orderservice\" method=\"sendmail\"/>        <log message=\"mail send to ${header',1),(6893,'to}\"/>    </route></camelcontext>as you can see from the code, <oncompletion> is defined as a separate camel route',1),(6894,'it will be executed right after the regular route has completed',1),(6895,'you’re only interested in executing oncompletion when the exchange fails, so you can specify this by setting the onfailureonly attribute to true',1),(6896,'the source code for the book contains this example, which you can run using the following maven goal:mvn test -dtest=springfilerollbacktestlisting 9',1),(6897,'8 using oncompletion as a transactional rollback    www',1),(6898,'info313summary and best practiceswhen you run it, you’ll find that it acts just like the previous example',1),(6899,'oncompletion can also be used in situations where the exchange did not fail',1),(6900,'suppose you want to log activity about exchanges being processed',1),(6901,'for example, in the java dsl you could do it as follows:oncompletion()',1),(6902,'beanref(\"logservice\", \"logexchange\");oncompletion also supports scoping, exactly the same onexception does at either context or route scope (as you saw in chapter 5)',1),(6903,'you could create a java dsl–based version of listing 9',1),(6904,'8 using route-scoped oncompletion as follows:from(\"direct:confirm\")',1),(6905,'class, \"onfailure\")',1),(6906,'class, \"createmail\")',1),(6907,'log(\"trying to send mail to ${header',1),(6908,'class, \"sendmail\")',1),(6909,'log(\"mail send to ${header',1),(6910,'to}\");now you’ve learned all there is to know about oncompletion, which brings us to the end of this chapter',1),(6911,'6 summary and best practicestransactions play a crucial role when grouping distinct events together so that they act as a single, coherent, atomic event',1),(6912,'in this chapter, we looked at how transactions work in camel and discovered that camel lets spring orchestrate and manage transactions',1),(6913,'by leveraging spring transactions, camel lets you use an existing and proven transaction framework thatthe difference between oncompletion and synchronizationthere is one major difference between using oncompletion and using a synchronization, and th...',1),(6914,'synchronization uses the same thread to perform the tasks, so it will block and wait until it completes',1),(6915,'in contrast, oncompletion transfers the exchange to be executed by a separate thread',1),(6916,'the reason for this design decision is that oncompletion should not affect the original exchange and its outcome',1),(6917,'suppose during oncompletion an exception was thrown—what should happen then',1),(6918,'or what if oncompletion unexpectedly or deliberately changed the content of the exchange, which would affect the reply being sent back to the caller',1),(6919,'the bottom line is that oncompletion uses a separate route based on a copy of the completed exchange',1),(6920,'info314 chapter 9 using transactionsworks well with the most popular application servers, message brokers, and database systems',1),(6921,'here are the best practices you should take away from this chapter:■ use transactions when appropriate',1),(6922,'transactions can only be used by a limited number of resources, such as jms and jdbc',1),(6923,'therefore, it only makes sense to use transactions when you can leverage these kinds of resources',1),(6924,'if transactions aren’t applicable, you can consider using your own code to compensate and to work as a rollback mechanism',1),(6925,'■ local or global transactions',1),(6926,'if your route only involves one transactional resource, use local transactions',1),(6927,'they’re simpler and much less resource-intensive',1),(6928,'only use global transactions if multiple resources are involved',1),(6929,'■ test your transactions',1),(6930,'build unit and integration tests to ensure that your transactions work as expected',1),(6931,'we’ll now turn our attention to using concurrency with camel',1),(6932,'you’ll learn to how to improve performance, understand the threading model used in camel, and more',1),(6933,'info315concurrency and scalabilityconcurrency is another word for multitasking, and we multitask all the time in our daily lives',1),(6934,'we put the coffee on, start up the computer, and while it’s booting grab the paper to glance at the news',1),(6935,'computers are also capable of doing multiple tasks—you may have multiple tabs open in your web browser while your mail application is fetching new email, for example',1),(6936,'juggling multiple tasks is also very common in enterprise systems, such as when you’re processing incoming orders, handling invoices, and doing inventory management, and these demands only grow over time',1),(6937,'with concurrency, you canthis chapter covers■ camel’s threading model■ configuring thread pools and thread profiles■ using concurrency with eips ■ message synchronicity and concurrency■ camel’s client concurrency api■ scalability with camel    www',1),(6938,'info316 chapter 10 concurrency and scalabilityachieve higher performance; by executing in parallel, you can get more work done in less time',1),(6939,'camel processes multiple messages concurrently in camel routes, and it leverages the concurrency features from java, so we’ll first discuss how concurrency works in java before we can move on to how thread pools work and how you define and use them i...',1),(6940,'the thread pool is the mechanism in java that orchestrates multiple tasks',1),(6941,'after we’ve discussed thread pools, we’ll move on to how you can use concurrency with the eips, and we’ll dive into how message synchronicity works',1),(6942,'we’ll then look at camel’s client concurrency api, which makes it easier for clients to work with concurrency',1),(6943,'the last section of this chapter focuses on how you can achieve high scalability with camel and how you can leverage this in your custom components',1),(6944,'1 introducing concurrencyas we’ve mentioned, you can achieve higher performance with concurrency',1),(6945,'when performance is limited by the availability of a resource, we say it’s bound by that resource: cpu-bound, io-bound, database-bound, and so on',1),(6946,'integration applications are often io-bound, waiting for replies to come back from remote servers, or for files to load from a disk',1),(6947,'this usually means you can achieve higher performance by utilizing resources more effectively, such as by keeping cpus busy doing useful work',1),(6948,'camel is often used to integrate disparate systems, where data is exchanged over the network',1),(6949,'this means there’s often a mix of resources, which are either cpu-bound or io-bound',1),(6950,'it’s very likely you can achieve higher performance by using concurrency',1),(6951,'rider auto parts has an inventory of all the parts its suppliers currently have in stock',1),(6952,'it’s vital for any business to have the most accurate and up-to-date information in their central erp system',1),(6953,'having the information locally in the erp system means the business can operate without depending on online integration with their suppliers',1),(6954,'1 illustrates this business process',1),(6955,'update inventorycamel applicationriderauto partserpsuppliersuppliersupplierfigure 10',1),(6956,'1 suppliers send inventory updates, which are picked up by a camel application',1),(6957,'the application synchronizes the updates to the erp system',1),(6958,'2 shows the route of the inventory-updating camel application from figure 10',1),(6959,'this application is responsible for loading the files and splitting the file content on a line-by-line basis using the splitter eip, which converts the line from csv format to an internal object model',1),(6960,'the model is then sent to another route that’s responsible for updating the erp system',1),(6961,'implementing this in camel is straightforward',1),(6962,'public void configure() throws exception {    from(\"file:rider/inventory\")',1),(6963,'log(\"starting to process file: ${header',1),(6964,'tokenize(\"\\n\"))',1),(6965,'class, \"csvtoobject\")',1),(6966,'log(\"done processing file: ${header',1),(6967,'class, \"updateinventory\"); }listing 10',1),(6968,'1 shows the configure method of the camel routebuilder that contains the two routes for implementing the application',1),(6969,'as you can see, the first route picks up the files and then splits the file content line by line b',1),(6970,'this is done by using the splitter eip in streaming mode',1),(6971,'the streaming mode ensures that the entire file isn’t loaded into memory; instead it’s loaded piece by piece on demand, which ensures low memory usage',1),(6972,'to convert each line from csv to an object, you use a bean—the inventoryservice class',1),(6973,'to update the erp system, you use the updateinventory method of the inventoryservice, as shown in the second route c',1),(6974,'now suppose you’re testing the application by letting it process a big file with 100,000 lines',1),(6975,'if each line takes a tenth of a second to process, processing the file would take 10,000 seconds, which is roughly 167 minutes',1),(6976,'that’s a long time',1),(6977,'in fact, you might end up in a situation where you can’t process all the files within the given timeframe',1),(6978,'in a moment, we’ll look at different techniques for speeding things up by leveraging concurrency',1),(6979,'but first we’ll set up the example to run without concurrency to create a baseline to compare to the concurrent solutions',1),(6980,'listing 10',1),(6981,'1 rider auto parts application for updating inventoryfile csv toobjectupdateinventorysplit linesfigure 10',1),(6982,'2 a route picks up incoming files, which are split and transformed to be ready for updating the inventory in the erp system',1),(6983,'splits file line by linebupdates erp systemc    www',1),(6984,'info318 chapter 10 concurrency and scalability10',1),(6985,'1 running the example without concurrencythe source code for the book contains this example (both with and without concurrency) in the chapter10/bigfile directory',1),(6986,'first, you need a big file to be used for testing',1),(6987,'to create a file with 1000 lines, use the following maven goal: mvn compile exec:java -pcreatebigfile -dlines=1000a bigfile',1),(6988,'csv file will be created in the target/inventory directory',1),(6989,'the next step is to start a test that processes the bigfile',1),(6990,'csv without concurrency',1),(6991,'this is done by using the following maven goal: mvn test -dtest=bigfiletestwhen the test runs, it will output its progress to the console',1),(6992,'bigfiletest simulates updating the inventory by sleeping for a tenth of a second, which means it should complete processing the bigfile',1),(6993,'csv in approximately 100 seconds',1),(6994,'when the test completes, it should log the total time taken:[ad 0 - file://target/inventory] info - inventory 997 updated [ad 0 - file://target/inventory] info - inventory 998 updated [ad 0 - file://target/inventory] info - inventory 999 updated [ad ...',1),(6995,'2 using concurrencythe application can leverage concurrency by updating the inventory in parallel',1),(6996,'3 shows this principle by using the concurrent consumers eip',1),(6997,'as you can see in figure 10',1),(6998,'3, the idea is to use concurrency d after the lines have been split c',1),(6999,'by doing this, you can parallelize steps e and f in the route',1),(7000,'in this example, those two steps could process messages concurrently',1),(7001,'the last step f, which sends messages to the erp system concurrently, is only possible if the system allows a client to send messages concurrently to it',1),(7002,'there can be situations where a system does not permit concurrency, or it may only allow up to afile csv toobjectupdateinventorysplit lines concurrentconsumersb c d e ffigure 10',1),(7003,'3 using the concurrent consumers eip to leverage concurrency and process inventory updates in parallel    www',1),(7004,'info319introducing concurrencycertain number of concurrent messages',1),(7005,'check the sla (service level agreement) for the system you integrate with',1),(7006,'another reason to disallow concurrency would be if the messages have to be processed in the exact order they are split',1),(7007,'let’s try out three different ways to run the application faster with concurrency:■ using parallelprocessing options on the splitter eip■ using a custom thread pool on the splitter eip■ using staged event-driven architecture (seda)the first two solut...',1),(7008,'the last solution is based on the seda principle, which uses queues between tasks',1),(7009,'using parallelprocessingthe splitter eip offers an option to switch on parallel processing, as shown here:',1),(7010,'tokenize(\"\\n\"))',1),(7011,'parallelprocessing()',1),(7012,'class, \"csvtoobject\")',1),(7013,'end()configuring this in spring xml is very simple as well:<split streaming=\"true\" parallelprocessing=\"true\">    <tokenize token=\"\\n\"/>    <bean beantype=\"camelinaction',1),(7014,'inventoryservice\"          method=\"csvtoobject\"/>    <to uri=\"direct:update\"/> </split>to run this example, use the following maven goals:mvn test -dtest=bigfileparalleltest mvn test -dtest=springbigfileparalleltestas you’ll see, the test is now much...',1),(7015,'n] info - done processing big file took 11 secondswhat happens is that when parallelprocessing is enabled, the splitter eip uses a thread pool to process the messages concurrently',1),(7016,'the thread pool is, by default, configured to use 10 threads, which helps explain why it’s about 10 times faster: the application is mostly io-bound (reading files and remotely communicating with the erp system involves a lot of io activity)',1),(7017,'the test would not be 10 times faster if it were solely cpu-bound; for example, if all it did was “crunch numbers',1),(7018,'info320 chapter 10 concurrency and scalabilitynote in the console output you’ll see that the thread name is displayed, containing a unique thread number, such as camel thread 4 - split',1),(7019,'this thread number is a sequential, unique number assigned to each thread as it’s created, in any thread pool',1),(7020,'this means if you use a second splitter eip, the second splitter will most likely have numbers assigned from 11 upwards',1),(7021,'you may have noticed from the previous console output that the lines were processed in order; it ended by updating 995, 996, 997, 998, and 999',1),(7022,'this is a coincidence, because the 10 concurrent threads are independent and they run at their own pace',1),(7023,'the reason why they appear in order here is because we simulated the update by delaying the message for a tenth of a second, which means they’ll all take approximately the same amount of time',1),(7024,'but if you take a closer look in the console output, you’ll probably see some interleaved lines, such as with order lines 954 and 953:[camel thread 5 - split] info - inventory 951 updated [camel thread 7 - split] info - inventory 952 updated [camel t...',1),(7025,'what if you want to have more control over which thread pool is being used',1),(7026,'using a custom thread poolthe splitter eip also allows you to use a custom thread pool for concurrency',1),(7027,'you can create a thread pool using the java',1),(7028,'executors factory:executorservice threadpool = executors',1),(7029,'newcachedthreadpool();the newcachedthreadpool method will create a thread pool suitable for executing many small tasks',1),(7030,'the pool will automatically grow and shrink on demand',1),(7031,'to use this pool with the splitter eip, you need to configure it as shown here:',1),(7032,'tokenize(\"\\n\"))',1),(7033,'class, \"csvtoobject\")',1),(7034,'end()creating the thread pool using spring xml is done as follows:<bean id=\"mypool\" class=\"java',1),(7035,'executors\"      factory-method=\"newcachedthreadpool\"/>the splitter eip uses the pool by referring to it, using the executorserviceref attribute, as shown:<split streaming=\"true\" executorserviceref=\"mypool\">    <tokenize token=\"\\n\"/>    <bean beantype...',1),(7036,'inventoryservice\"          method=\"csvtoobject\"/>    <to uri=\"direct:update\"/> </split>    www',1),(7037,'info321introducing concurrencyto run this example, use the following maven goals:mvn test -dtest=bigfilecachedthreadpooltest mvn test -dtest=springbigfilecachedthreadpooltestthe test is now much faster and completes within a few seconds:[pool-1-threa...',1),(7038,'the reason is that the cached thread pool is designed to be very aggressive and to spawn new threads on demand',1),(7039,'it has no upper bounds and no internal work queue, which means that when a new task is being handed over, it will create a new thread if there are no available threads in the thread pool',1),(7040,'you may also have noticed the thread name in the console output, which indicates that many threads were created; the output shows thread numbers 442, 443, and 449',1),(7041,'many threads have been created because the splitter eip splits the file lines more quickly than the tasks update the inventory',1),(7042,'this means that the thread pool receives new tasks at a higher pace than it can execute them; new threads are created to keep up',1),(7043,'this can cause unpredicted side effects in an enterprise system—a high number of newly created threads may impact applications in other areas',1),(7044,'that’s why it’s often desirable to use thread pools with an upper limit for the number of threads',1),(7045,'for example, instead of using the cached thread pool, you could use a fixed thread pool',1),(7046,'you can use the same executors factory to create such a pool:executorservice threadpool = executors',1),(7047,'newfixedthreadpool(20);creating a fixed thread pool in spring xml is done as follows:<bean id=\"mypool\" class=\"java',1),(7048,'executors\"      factory-method=\"newfixedthreadpool\">    <constructor-arg index=\"0\" value=\"20\"/> </bean>to run this example, use the following maven goals:mvn test -dtest=bigfilefixedthreadpooltest mvn test -dtest=springbigfilefixedthreadpooltestthe t...',1),(7049,'noop=true] info - done processing big file took 6 secondsas you can see by running this test, you can process the 1,000 lines in about 6 seconds using only 20 threads',1),(7050,'the previous test was faster, as it completed in about 2 seconds, but it used nearly 500 threads (this number can vary on different systems)',1),(7051,'by increasing    www',1),(7052,'info322 chapter 10 concurrency and scalabilitythe fixed thread pool to a reasonable size, you should be able to reach the same timeframe as with the cached thread pool',1),(7053,'for example, running with 50 threads completes in about 3 seconds',1),(7054,'you can experiment with different pool sizes',1),(7055,'now, on to the last concurrency solution, seda',1),(7056,'using sedaseda (staged event-driven architecture) is an architecture design that breaks down a complex application into a set of stages connected by queues',1),(7057,'in camel lingo, that means using internal memory queues to hand over messages between routes',1),(7058,'note the direct component in camel is the counterpart to seda',1),(7059,'direct is fully synchronized, and it works like a direct method call invocation',1),(7060,'4 shows how you can use seda to implement the example',1),(7061,'the first route runs sequentially in a single thread',1),(7062,'the second route uses concurrent consumers to process the messages that arrive on the seda endpoint, using multiple concurrent threads',1),(7063,'listing 10',1),(7064,'2 shows how to implement this solution in camel by using the seda endpoints, shown in bold',1),(7065,'public void configure() throws exception {    from(\"file:rider/inventory\")',1),(7066,'log(\"starting to process file: ${header',1),(7067,'tokenize(\"\\n\"))',1),(7068,'class, \"csvtoobject\")',1),(7069,'to(\"seda:update\")',1),(7070,'log(\"done processing file: ${header',1),(7071,'camelfilename}\");    from(\"seda:update',1),(7072,'concurrentconsumers=20\")',1),(7073,'class, \"updateinventory\"); }listing 10',1),(7074,'2 rider auto parts inventory-update application using sedafile csv toobjectupdateinventorysplit lines sedaconcurrentconsumerssecond routefirst routefigure 10',1),(7075,'4 messages pass from the first to the second route using seda',1),(7076,'concurrency is used in the second route',1),(7077,'seda consumers using concurrencyb    www',1),(7078,'info323using thread poolsby default, a seda consumer will only use one thread',1),(7079,'to leverage concurrency, you use the concurrentconsumers option to increase the number of threads—to 20 in this listing b',1),(7080,'to run this example, use the following maven goals:mvn test -dtest=bigfilesedatest mvn test -dtest=springbigfilesedatestthe test is fast and completes in about 6 seconds',1),(7081,'[ead 20 - seda://update] info - inventory 997 updated [ead 18 - seda://update] info - inventory 998 updated [read 9 - seda://update] info - inventory 999 updated took 6 secondsas you can see from the console output, you’re now using 20 concurrent thr...',1),(7082,'for example, the last three thread numbers from the output are 20, 18, and 9',1),(7083,'note when using concurrentconsumers with seda endpoints, the thread pool uses a fixed size, which means that a fixed number of active threads are waiting at all times to process incoming messages',1),(7084,'that’s why it’s best to leverage the concurrency features provided by the eips, such as the parallelprocessing on the splitter eip',1),(7085,'it will leverage a thread pool that can grow and shrink on demand, so it won’t consume as many resources as a seda endpoint will',1),(7086,'we’ve now covered three different solutions for applying concurrency to an existing application, and they all greatly improve performance',1),(7087,'we were able to reduce the 11-second processing time down to 3 to 7 seconds, using a reasonable size for the thread pool',1),(7088,'in the next section, we’ll review thread pools in more detail and learn about the threading model used in camel',1),(7089,'with this knowledge, you can go even further with concurrency',1),(7090,'2 using thread poolsusing thread pools is common when using concurrency',1),(7091,'in fact, thread pools were used in the example in the previous section',1),(7092,'it was a thread pool that allowed the splitter eip to work in parallel and speed up the performance of the application',1),(7093,'in this section, we’ll start from the top and briefly recap what a thread pool is and how it’s represented in java',1),(7094,'then we’ll look at the default thread pool profile used by camel and how to create custom thread pools using java dsl and spring xml',1),(7095,'we’ll also look at how you can use a custom strategy to delegate the creation of thread pools to an external resource, such as a java workmanager on a java ee server',1),(7096,'1 understanding thread pools in javaa thread pool is a group of threads that are created to execute a number of tasks in a task queue',1),(7097,'5 shows this principle',1),(7098,'info324 chapter 10 concurrency and scalabilitynote for more info on the thread pool pattern, see the wikipedia article on the subject: http://en',1),(7099,'thread pools were introduced into java 1',1),(7100,'5 by the new concurrency api residing in the java',1),(7101,'in the concurrency api, the executorservice interface is the client api that you use to submit tasks for execution',1),(7102,'clients of this api are both camel end users and camel itself, because camel fully leverages the concurrency api from java',1),(7103,'note readers already familiar with java’s concurrency api may be in familiar waters as we go further in this chapter',1),(7104,'in java, the threadpoolexecutor class is the implementation of the executorservice interface, and it provides a thread pool with the options listed in table 10',1),(7105,'1 options provided by thread poolsoption type descriptioncorepoolsize int specifies the number of threads to keep in the pool, even if they’re idlemaximumpoolsize int specifies the maximum number of threads to keep in the poolkeepalivetime long sets ...',1),(7106,'5 tasks from the task queue wait to be executed by a thread from the thread pool',1),(7107,'info325using thread poolsas you can see from table 10',1),(7108,'1, there are many options you can use when creating thread pools in java',1),(7109,'to make it easier to create commonly used types of pools, java provides executors as a factory, which you saw in section 10',1),(7110,'in section 10',1),(7111,'3, you’ll see how camel makes creating thread pools even easier',1),(7112,'when working with thread pools, there are often additional tasks you must deal with',1),(7113,'for example, it’s important to ensure the thread pool is shut down when your application is being shut down; otherwise it can lead to memory leaks',1),(7114,'this is particularly important in server environments when running multiple applications in the same server container, such as a java ee or osgi container',1),(7115,'when using camel to create thread pools, the activities listed in table 10',1),(7116,'another good practice that’s often neglected is to use human-understandable thread names, because those names are logged in production logs',1),(7117,'by allowing camel to name the threads using a common naming standard, you can better understand what happens when looking at log files (particularly if your application is running together with other frameworks that create their own threads)',1),(7118,'for example, this log entry indicates it’s a thread from the camel file component:[camel thread 7 - file://riders/inbox] debug - total 3 files to consumeif camel didn’t do this, the thread name would be generic and wouldn’t give any hint that it’s fr...',1),(7119,'[thread 0] debug - total 3 files to consumetip camel uses a customizable pattern for naming threads',1),(7120,'the default pattern is \"camel thread ${counter} - ${name}\"',1),(7121,'a custom pattern can be configured using executorservicestrategy',1),(7122,'6 the default pattern has been improved to include the camel id \"camel (${camelid}) thread ${counter} - ${name}\"',1),(7123,'workqueue blockingqueue identifies the task queue for holding waiting tasks before they’re executedthreadfactory threadfactory specifies a factory to use when a new thread is createdtable 10',1),(7124,'2 activities for managing thread poolsactivity descriptionshutdown ensures the thread pool will be properly shut down, which happens when camel shuts down',1),(7125,'management registers the thread pool in jmx, which allows you to manage the thread pool at runtime',1),(7126,'unique thread names ensures the created threads will use unique and human-readable names',1),(7127,'activity logging logs lifecycle activity of the pool',1),(7128,'1 options provided by thread pools (continued)option type description    www',1),(7129,'info326 chapter 10 concurrency and scalabilitywe’ll cover the options listed in table 10',1),(7130,'1 in more detail in the next section, when we review the default thread profile used by camel',1),(7131,'2 camel thread pool profilesthread pools aren’t created and configured directly, but via the configuration of thread pool profiles',1),(7132,'a thread pool profile is a profile that dictates how a thread pool should be created, based on a selection of the options listed earlier in table 10',1),(7133,'thread pool profiles are organized in a simple two-layer hierarchy with custom and default profiles',1),(7134,'there is always one default profile and you can optionally have multiple custom profiles',1),(7135,'the default profile is defined using the options listed in table 10',1),(7136,'as you can see from the default values in table 10',1),(7137,'3, the default thread pool can use from 10 to 20 threads to execute tasks concurrently',1),(7138,'the rejectedpolicy option corresponds to the rejected option from table 10',1),(7139,'1, and it’s an enum type allowing four different values: abort, callerruns, discardoldest, and discard',1),(7140,'the callerruns option will use the caller thread to execute the task itself',1),(7141,'the other three options will either abort by throwing an exception, or discard an existing task from the task queue',1),(7142,'there is no one-size-fits-all solution for every camel application, so you may have to tweak the default profile values',1),(7143,'but usually you’re better off leaving the default values alone',1),(7144,'only by load testing your applications can you determine that tweaking the values will produce better results',1),(7145,'in java, you access the threadpoolprofile starting from camelcontext',1),(7146,'the following code shows how to change the maximum pool size to 50',1),(7147,'executorservicestrategy strategy = context',1),(7148,'getexecutorservicestrategy(); threadpoolprofile profile = strategy',1),(7149,'3 settings for the default thread pool profileoption default value descriptionpoolsize 10 the thread pool will always contain at least 10 threads in the pool',1),(7150,'maxpoolsize 20 the thread pool can grow up to at most 20 threads',1),(7151,'keepalivetime 60 idle threads are kept alive for 60 seconds, after which they’re terminated',1),(7152,'maxqueuesize 1000 the task queue can contain up to 1000 tasks before the pool is exhausted',1),(7153,'rejectedpolicy callerruns if the pool is exhausted, the caller thread will execute the task',1),(7154,'info327using thread poolsthe default threadpoolprofile is accessible from executorservicestrategy, which is an abstraction in camel allowing you to plug in different thread pool providers',1),(7155,'we’ll cover executorservicestrategy in more detail in section 10',1),(7156,'in spring xml, you configure the default thread pool profile using the <threadpoolprofile> tag:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(7157,'org/schema/spring\">   <threadpoolprofile id=\"mydefaultprofile\"                       defaultprofile=\"true\"                       maxpoolsize=\"50\"/>',1),(7158,'</camelcontext>it’s important to set the defaultprofile attribute to true to tell camel that this is the default profile',1),(7159,'you can add additional options if you want to override any of the other options from table 10',1),(7160,'there are situations where one profile isn’t sufficient, so you can also define custom profiles',1),(7161,'configuring custom thread pool profilesdefining custom thread pool profiles is much like configuring the default profile',1),(7162,'in java dsl, a custom profile is created using the threadpoolprofilesupport class:threadpoolprofile custom = new threadpoolprofilesupport(\"bigpool\"); custom',1),(7163,'registerthreadpoolprofile(custom);this example increases the maximum pool size to 200',1),(7164,'all other options will be inherited from the default profile, which means it will use the default values listed in table 10',1),(7165,'3; for example, keepalivetime will be 60 seconds',1),(7166,'notice that this custom profile is given the name bigpool; you can refer to the profile in the camel routes by using executorserviceref:',1),(7167,'tokenize(\"\\n\"))',1),(7168,'class, \"csvtoobject\")',1),(7169,'end()when camel creates this route with the splitter eip, it refers to a thread pool with the name bigpool',1),(7170,'camel will now look in the registry for an executorservice type registered with the id bigpool',1),(7171,'if none is found, it will fall back and see if there is a known thread pool profile with the id bigpool',1),(7172,'and because such a profile has been registered, camel will use the profile to create a new thread pool to be used by the splitter eip',1),(7173,'all of which means that executorserviceref supports using thread pool profiles to create the desired thread pools',1),(7174,'when using spring xml, it’s simpler to define custom thread pool profiles',1),(7175,'all you have to do is use the <threadpoolprofile> tag:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(7176,'org/schema/spring\">    <threadpoolprofile id=\"bigpool\" maxpoolsize=\"100\"/>    </camelcontext>    www',1),(7177,'info328 chapter 10 concurrency and scalabilitybesides using thread pool profiles, you can create thread pools in other ways',1),(7178,'for example, you may need to create custom thread pools if you’re using a third-party library that requires you to provide a thread pool',1),(7179,'or you may need to create one as we did in section 10',1),(7180,'3 creating custom thread poolscreating thread pools with the java api is a bit cumbersome, so camel provides a nice way of doing this in both java dsl and spring xml',1),(7181,'creating custom thread pools in java dslin java dsl, you use org',1),(7182,'threadpoolbuilder to create thread pools, as follows:threadpoolbuilder builder = new threadpoolbuilder(context); executorservice mypool = builder',1),(7183,'build(\"mypool\");the threadpoolbuilder requires camelcontext in its constructor, because it will use the default thread pool profile as the baseline when building custom thread pools',1),(7184,'that means mypool will use the default value for keepalivetime, which would be 60 seconds',1),(7185,'creating custom thread pools in spring xmlin spring xml, creating a thread pool is done using the <threadpool> tag:<camelcontext xmlns=\"http://camel',1),(7186,'org/schema/spring\">    <threadpool id=\"mypool\" threadname=\"cool\"                poolsize=\"5\" maxpoolsize=\"15\" maxqueuesize=\"250\"/>    <route>        <from uri=\"direct:start\"/>        <to uri=\"log:start\"/>        <threads executorserviceref=\"mypool\"> ...',1),(7187,'this is because it needs access to the default thread profile, which is used as baseline (just as the threadpoolbuilder requires camelcontext in its constructor)',1),(7188,'the preceding route uses a <threads> tag, that references the custom thread pool b',1),(7189,'if a message is sent to the direct:start endpoint, it should be routed to <threads>, which will continue routing the message using the custom thread pool',1),(7190,'this can be seen in the console output that logs the thread names:[camel thread 0 - cool] info hello - exchange[body:hello camel]note when using executorserviceref to look up a thread pool, camel will first check for a custom thread pool',1),(7191,'if none are found, camel will fall back and see if a thread pool profile exists with the given name; if so, a new thread pool is created based on that profile',1),(7192,'using thread pool in the routeb    www',1),(7193,'info329using thread poolsall thread pool creation is done using executorservicestrategy, which defines a pluggable api for using thread pool providers',1),(7194,'4 using executorservicestrategy the org',1),(7195,'executorservicestrategy interface defines a pluggable api for thread pool providers',1),(7196,'camel will, by default, use the defaultexecutorservicestrategy class, which creates thread pools using the concurrency api in java',1),(7197,'when you need to use a different thread pool provider, for example, a provider from a java ee server, you can create a custom executorservicestrategy to work with the provider',1),(7198,'in this section, we’ll show you how to configure camel to use a custom executorservicestrategy, leaving the implementation of the provider up to you',1),(7199,'configuring camel to use a custom executorservicestrategyin java, you configure camel to use a custom executorservicestrategy via the setexecutorservicestrategy method on camelcontext:camelcontext context =',1),(7200,'setexecutorservicestrategy(myexecutorservicestrategy);in spring xml, it’s easy because all you have to do is define a spring bean',1),(7201,'camel will automatically detect and use it:<bean id=\"myexecutorservice\"      class=\"camelinaction',1),(7202,'myexecutorservicestrategy\"/>so far in this chapter, we’ve mostly used thread pools in camel routes, but they’re also used in other areas, such as in some camel components',1),(7203,'using executorservicestrategy in a custom componentthe executorservicestrategy defines methods for working with thread pools',1),(7204,'suppose you’re developing a custom camel component and you need to run a scheduled background task',1),(7205,'when running a background task, it’s recommended that you use the scheduledexecutorservice as the thread pool, because it’s capable of executing tasks in a scheduled manner',1),(7206,'creating the thread pool is easy with the help of camel’s executorservicestrategy',1),(7207,'public class mycomponent extends defaultcomponent implements runnable {    private static final log log = logfactory',1),(7208,'class);    private scheduledexecutorservice executor;    public void run() {        log',1),(7209,'info(\"i run now\");                       }    protected void dostart() throws exception {        super',1),(7210,'newscheduledthreadpool(this,listing 10',1),(7211,'3 using executorservicestrategy to create a thread poolruns scheduled taskb    www',1),(7212,'info330 chapter 10 concurrency and scalability                \"mybackgroundtask\", 1);                                       executor',1),(7213,'schedulewithfixeddelay(this, 1, 1, timeunit',1),(7214,'seconds);    }    protected void dostop() throws exception {        getcamelcontext()',1),(7215,'shutdown(executor);        super',1),(7216,'dostop();    } }listing 10',1),(7217,'3 illustrates the principle of using a scheduled thread pool to repeatedly execute a background task',1),(7218,'the custom component extends defaultcomponent, which allows you to override the dostart and dostop methods to create and shut down the thread pool',1),(7219,'in the dostart method, you create the scheduledexecutorservice using executorservicestrategy c and schedule it to run the task bonce every second using the schedulewithfixeddelay method',1),(7220,'the source code for the book contains this example in the chapter10/pools directory',1),(7221,'you can try it using the following maven goal:mvn test -dtest=mycomponenttestwhen it runs, you’ll see the following output in the console:waiting for 10 seconds before we shutdown [camel thread 0 - mybackgroundtask] info  mycomponent - i run now [cam...',1),(7222,'you also know how to leverage this to process messages concurrently in camel routes, and you saw several ways of creating and defining thread pools in camel',1),(7223,'when modeling routes in camel, you’ll often use eips to build the routes to support your business cases',1),(7224,'in section 10',1),(7225,'1, you used the splitter eip and learned to improve performance using concurrency',1),(7226,'in the next section, we’ll take a look at other eips you can use with concurrency',1),(7227,'3 using concurrency with eips some of the eips in camel support concurrency out of the box—they’re listed in table 10',1),(7228,'in this section, we’ll take a look at them and the benefits they offer',1),(7229,'4 eips in camel that supports concurrencyeip descriptionaggregate the aggregator eip allows concurrency when sending out completed and aggregated messages',1),(7230,'we covered this pattern in chapter 8',1),(7231,'multicast the multicast eip allows concurrency when sending a copy of the same message to multiple recipients',1),(7232,'we discussed this pattern in chapter 2, and we’ll use it in an example in section 10',1),(7233,'creates scheduled thread pool c    www',1),(7234,'info331using concurrency with eips all the eips from table 10',1),(7235,'4 can be configured to enable concurrency in the same way',1),(7236,'you can turn on parallelprocessing to use thread pool profiles to apply a matching thread pool; this is likely what you’ll want to use in most cases',1),(7237,'or you can refer to a specific thread pool using the executorservice option',1),(7238,'you’ve already seen this in action in section 10',1),(7239,'2, where you used the splitter eip',1),(7240,'in the following three sections, we’ll look at how to use the threads, multicast, and wire tap eips in a concurrent way',1),(7241,'1 using concurrency with the threads eipthe threads eip is the only eip that has additional options in the dsl offering finegrained definition of the thread pool to be used',1),(7242,'these additional options are listed in table 10',1),(7243,'for example, the thread pool from section 10',1),(7244,'3 could be written as follows:<camelcontext xmlns=\"http://camel',1),(7245,'org/schema/spring\">    <route>        <from uri=\"direct:start\"/>        <to uri=\"log:start\"/>        <threads threadname=\"cool\" poolsize=\"5\" maxpoolsize=\"15\"                 maxqueuesize=\"250\">            <to uri=\"log:cool\"/>        </threads>    </r...',1),(7246,'6 illustrates which threads are in use when a message is being routed using the threads eip',1),(7247,'there will be two threads active when a message is being routed',1),(7248,'the caller thread will hand over the message to the thread pool',1),(7249,'the thread pool will then find an available thread in its pool to continue routing the message',1),(7250,'recipient listthe recipient list eip allows concurrency when sending copies of a single message to a dynamic list of recipients',1),(7251,'this works in the same way as the multicast eip, so what you learned there also applies for this pattern',1),(7252,'we covered this pattern in chapter 2',1),(7253,'splitter the splitter eip allows concurrency when each split message is being processed',1),(7254,'you saw how to do this in section 10',1),(7255,'this pattern was also covered in chapter 8',1),(7256,'threads the threads eip always uses concurrency to hand over messages to a thread pool that will continue processing the message',1),(7257,'you saw an example of this in section 10',1),(7258,'3, and we’ll cover it a bit more in section 10',1),(7259,'wire tap the wire tap eip allows you to spawn a new message and let it be sent to an endpoint using a new thread, while the calling thread can continue to process the original message',1),(7260,'the wire tap eip always uses a thread pool to execute the spawned message',1),(7261,'this is covered in section 10',1),(7262,'4 eips in camel that supports concurrency (continued)eip description    www',1),(7263,'info332 chapter 10 concurrency and scalabilityyou can run this example from the chapter10/pools directory using the following maven goal:mvn test -dtest=springinlinedthreadpooltestyou’ll see the following in the console:[main]                   info ...',1),(7264,'you see, as expected, two threads in play: main is the caller thread, and cool is from the thread pool',1),(7265,'tip you can use the threads eip to achieve concurrency when using camel components that don’t offer concurrency',1),(7266,'a good example is the camel file component, which uses a single thread to scan and pick up files',1),(7267,'by using the threads eip, you can allow the picked up files to be processed concurrently',1),(7268,'let’s look at how rider auto parts improves performance by leveraging concurrency with the multicast eip',1),(7269,'2 using concurrency with the multicast eiprider auto parts has a web portal where its employees can look up information, such as the current status of customer orders',1),(7270,'when selecting a particular order, the portal needs to retrieve information from three different systems to gather an overview of the order',1),(7271,'7 illustrates this',1),(7272,'log:sta t log:cooltask queuecaller threadthread poolpooled threaddirect:startfigure 10',1),(7273,'6 caller and pooled threads are in use when a message is routed',1),(7274,'7  the web portal gathers information from three systems to compile the overview that’s presented to the employee',1),(7275,'info333using concurrency with eips your boss has summoned you to help with this portal',1),(7276,'the employees have started to complain about poor performance, and it doesn’t take you more than an hour to find out why; the portal retrieves the data from the three sources in sequence',1),(7277,'this is obviously a good use case for leveraging concurrency to improve performance',1),(7278,'you also look in the production logs and see that a single overview takes 4',1),(7279,'0 seconds (1',1),(7280,'4 + 1',1),(7281,'1 + 1',1),(7282,'5 seconds) to complete',1),(7283,'you tell your boss that you can improve the performance by gathering the data in parallel',1),(7284,'back at your desk, you build a portal prototype in camel that resembles the current implementation',1),(7285,'the prototype uses the multicast eip to retrieve data from the three external systems as follows: <route>    <from uri=\"direct:portal\"/>    <multicast strategyref=\"aggregateddata\">        <to uri=\"direct:crm\"/>        <to uri=\"direct:erp\"/>        <t...',1),(7286,'when all data has been aggregated, the combinedata bean is used to create the reply that will be displayed in the portal',1),(7287,'you decide to test this route by simulating the three systems using the same response times as from the production logs',1),(7288,'running your test yields the following performance metrics:timer - [message: 123] sent to: direct://crm took: 1404 ms',1),(7289,'timer - [message: 123] sent to: direct://erp took: 1101 ms',1),(7290,'timer - [message: 123] sent to: direct://shipping took: 1501 ms',1),(7291,'timer - [message: 123] sent to: direct://portal took: 4139 ms',1),(7292,'as you can see, the total time is 4',1),(7293,'1 seconds when running in sequence',1),(7294,'now you enable concurrency with the parallelprocessing options:<route>    <from uri=\"direct:portal\"/>        <multicast strategyref=\"aggregateddata\"                   parallelprocessing=\"true\">            <to uri=\"direct:crm\"/>            <to uri=\"di...',1),(7295,'timer - [message: 123] sent to: direct://crm took: 1402 ms',1),(7296,'timer - [message: 123] sent to: direct://shipping took: 1502 ms',1),(7297,'timer - [message: 123] sent to: direct://portal took: 1623 ms',1),(7298,'info334 chapter 10 concurrency and scalabilitythe numbers show that response time went from 4',1),(7299,'6 seconds, which is an improvement of roughly 250 percent',1),(7300,'note that the logged lines aren’t in the same order as the sequential example',1),(7301,'with concurrency enabled, the lines are logged in the order that the remote services’ replies come in',1),(7302,'without concurrency, the order is always fixed in the sequential order defined by the camel route',1),(7303,'the source code for the book contains this example in the chapter10/eip directory',1),(7304,'you can try the two scenarios using the following maven goals:mvn test -dtest=multicasttest mvn test -dtest=multicastparalleltestyou have now seen how the multicast eip can be used concurrently to improve performance',1),(7305,'the aggregate, recipient list, and splitter eips can be configured with concurrency in the same way as the multicast eip',1),(7306,'the next pattern we’ll look at using with concurrency is the wire tap eip',1),(7307,'we encountered it the first time in chapter 2, section 2',1),(7308,'3 using concurrency with the wire tap eipthe wire tap eip leverages a thread pool to process the tapped messages concurrently',1),(7309,'you can configure which thread pool it should use, and if no pool has been configured, it will fall back and create a thread pool based on the default thread pool profile',1),(7310,'suppose you want to use a custom thread pool when using the wire tap eip',1),(7311,'first you must create the thread pool to be used, and then you pass that in as a reference to the wire tap in the route, as highlighted in bold:public void configure() throws exception {    executorservice lowpool = new threadpoolbuilder(context)',1),(7312,'build(\"lowpool\");    from(\"direct:start\")',1),(7313,'log(\"incoming message ${body}\")',1),(7314,'to(\"mock:result\");    from(\"direct:tap\")',1),(7315,'log(\"tapped message ${body}\")',1),(7316,'to(\"mock:tap\"); }the equivalent route in spring xml is as follows:<camelcontext xmlns=\"http://camel',1),(7317,'org/schema/spring\">    <threadpool id=\"lowpool\"                poolsize=\"1\" maxpoolsize=\"5\" threadname=\"lowpool\"/>    <route>        <from uri=\"direct:start\"/>        <log message=\"incoming message ${body}\"/>        <wiretap uri=\"direct:tap\" executor...',1),(7318,'info335synchronicity and threading        <from uri=\"direct:tap\"/>        <log message=\"tapped message ${body}\"/>        <to uri=\"mock:tap\"/>    </route></camelcontext>the source code for the book contains this example in the chapter10/eip directory',1),(7319,'you can run the example using the following maven goals:mvn test -dtest=wiretaptest mvn test -dtest=springwiretaptestwhen you run the example, the console output should indicate that the tapped message is being processed by a thread from the lowpool ...',1),(7320,'[main]                     info route1 - incoming message hello camel [camel thread 0 - lowpool] info route2 - tapped message hello camelyou now have a better understanding of the overall concept of using thread pools for concurrency in java',1),(7321,'we’ll next look at how the synchronicity of messages impacts the way thread pools are leveraged',1),(7322,'4 synchronicity and threadinga caller can invoke a service either synchronously or asynchronously',1),(7323,'if the caller has to wait until all the processing steps are complete before it can continue, it’s a synchronous process',1),(7324,'if the caller can continue before the processing has been completed, it’s an asynchronous process',1),(7325,'the service being invoked can leverage as many threads as it wants to complete the message',1),(7326,'the number of threads doesn’t affect whether or not the caller is considered synchronous or asynchronous',1),(7327,'now imagine from this point forward that the service being invoked is a camel route',1),(7328,'as just mentioned, the service can use multiple threads to process the message',1),(7329,'in this section, we’ll focus on which factors affect how many threads are involved in processing messages in camel',1),(7330,'these factors may affect the threading model:■ component—the camel component that originates the exchange is either based on a fire-and-forget or a request-response messaging style',1),(7331,'■ eips—as you saw in section 10',1),(7332,'3, some eips support concurrency',1),(7333,'■ configured synchronicity—some components can be configured to be either synchronous or asynchronous',1),(7334,'■ transactions—if the route is transacted, the transactional context is limited to run within one thread only',1),(7335,'■ message exchange pattern (mep)—mep is information stored on the exchange that tells camel whether the message is using a fire-and-forget or request-response messaging style',1),(7336,'camel uses the terminology from the java business integration (jbi) specification (http://en',1),(7337,'org/wiki/jbi): inonly means fire-andforget, and inout means request-response',1),(7338,'info336 chapter 10 concurrency and scalabilityin the next four sections (10',1),(7339,'4), we’ll cover four different scenarios showing how synchronicity and mep affect the threading model:■ asynchronous caller, and camel uses one thread to process the message■ synchronous caller, and camel uses one thread to process the message■ async...',1),(7340,'the source code for the book contains these examples in the chapter10/synchronicity directory',1),(7341,'you can use these maven goals to run the examples:mvn test -dtest=asynconethreadtest mvn test -dtest=synconethreadtest mvn test -dtest=asyncmultiplethreadstest mvn test -dtest=syncmultiplethreadstest10',1),(7342,'1 asynchronous caller using one threadin figure 10',1),(7343,'8, you’ll see that camel uses the consumer thread all along the processing of the message',1),(7344,'in this figure, an arrow represents a thread, and the consumer thread is shown as one long arrow',1),(7345,'this scenario can be implemented in a simple camel route:from(\"seda:start\")',1),(7346,'to(\"log:b\");consumercaller camellog a log bconsumerthread poolfigure 10',1),(7347,'8 in asynchronous inonly mode, the caller doesn’t wait for a reply',1),(7348,'on the camel side, only one thread is used for all the processing of the message',1),(7349,'info337synchronicity and threadingyou can try the route from a unit test by sending an inonly message using the sendbody method from producertemplate:public void testsyncinonly() throws exception {    string body = \"hello camel\";    log',1),(7350,'info(\"caller calling camel with message: \" + body);    template',1),(7351,'sendbody(\"seda:start\", body);    log',1),(7352,'info(\"caller finished calling camel\"); }if you run this example, you should see output to the console that shows the threads in use during routing:[main] info caller - caller calling camel with message: hello camel [main] info caller - caller finishe...',1),(7353,'the last two show that the consumer thread [camel thread 0 - seda://start] is used to process the message in the entire route',1),(7354,'the caller is sending in a fire-and-forget message (inonly), which means the caller doesn’t expect a reply (and it doesn’t wait for a reply)',1),(7355,'as a result, the caller can continue while the message is being processed',1),(7356,'we view the caller’s synchronicity as asynchronous',1),(7357,'from the camel perspective, only one thread is involved in processing the message, which simplifies things',1),(7358,'5 outlines the pros and cons of this approach from the camel perspective',1),(7359,'the asynchronous inonly scenario is often used with jms messaging, where it’s common to use camel to route messages from jms queues to other destinations',1),(7360,'realworld systems might use this scenario when routing messages between jms destinations, such as a new order queue that’s routed to a validated order queue if the order passes a sanity check',1),(7361,'orders that are invalid would be routed to an invalid order queue for further manual inspection',1),(7362,'in this example, the caller didn’t expect a reply because it sent an inonly message',1),(7363,'the next scenario shows what happens when the caller sends an inout (requestresponse) message',1),(7364,'2 synchronous caller using one threadthis scenario is only slightly different from the previous one',1),(7365,'9 you can see that camel is still only using one thread (represented as one arrow)',1),(7366,'the difference istable 10',1),(7367,'5 pros and cons of using one thread from the camel perspectivepros cons■ simple and easy■ supports transactional propagation■ all the load is handled by the camel consumer threads',1),(7368,'■ the consumer can be overloaded by the number of received messages',1),(7369,'info338 chapter 10 concurrency and scalabilitythat this time the caller expects a reply, which the consumer thread in camel has to deliver back to the waiting caller',1),(7370,'the route in camel is also a bit different, because you want to transform the message to return a reply to the caller: \"bye camel\"',1),(7371,'from(\"seda:start\")',1),(7372,'transform(constant(\"bye camel\"))',1),(7373,'to(\"log:b\");you can test this by using the requestbody method from producertemplate, which sends an inout message:public void testsyncinout() throws exception {    string body = \"hello camel\";    log',1),(7374,'info(\"caller calling camel with message: \" + body);    object reply = template',1),(7375,'requestbody(\"seda:start\", body);    log',1),(7376,'info(\"caller received reply: \" + reply); }if you run this example, you should see output to the console showing the threads in use during routing',1),(7377,'[main] info caller - caller calling camel with message: hello camel [camel thread 0 - seda://start] info a - inout, hello camel [camel thread 0 - seda://start] info b - inout, bye camel [main] info caller - caller received reply: bye camelnotice how ...',1),(7378,'you can see thatconsumercaller camellog a log bconsumerthread poolfigure 10',1),(7379,'9 in synchronous inout mode, the caller waits for a reply',1),(7380,'in camel, the consumer thread is used for all the processing of the message, and it delivers the reply to the waiting caller',1),(7381,'info339synchronicity and threadingthe caller is waiting—it will log to the console after camel has processed the message',1),(7382,'because the caller waits for a reply, we consider it synchronous',1),(7383,'the pros and cons of this configuration from the camel perspective are the same as in the previous section and are listed in table 10',1),(7384,'the synchronous inout scenario can be used with jms messaging because you can return replies if the jmsreply jms property is provided on the incoming message',1),(7385,'real-world systems may want to use this approach with components that natively support request-response messaging, such as web services',1),(7386,'a system could expose a web service that clients can call to query order status',1),(7387,'the next two scenarios we’ll cover show what happens when camel uses multiple threads to process the messages',1),(7388,'3 asynchronous caller using multiple threadsthe asynchronous inonly scenario is illustrated in figure 10',1),(7389,'this time you’re leveraging two threads in camel to process the messages (represented by the two arrows)',1),(7390,'this time there are two thread pools involved in camel',1),(7391,'the consumer thread will process the first part of the routing, and then the message is transferred to another thread pool, which continues routing the message',1),(7392,'the camel route is yet again different',1),(7393,'you use the threads eip to add the asynchronous behavior to the route:from(\"seda:start\")',1),(7394,'threads(5, 10)',1),(7395,'to(\"log:b\");consumercaller camellog a log bconsumerthread poolthreadsthreadsthread poolfigure 10',1),(7396,'10 in asynchronous inonly mode, the caller doesn’t wait for a reply',1),(7397,'on the camel side, multiple threads are involved during the routing of the message',1),(7398,'info340 chapter 10 concurrency and scalabilityby using threads(5, 10), you create a thread pool with a pool size of 5 and a maximum size of 10',1),(7399,'to test this scenario, you can use the following unit test:public void testasyncinonly() throws exception {    string body = \"hello camel\";    log',1),(7400,'info(\"caller calling camel with message: \" + body);    template',1),(7401,'sendbody(\"seda:start\", body);    log',1),(7402,'info(\"caller finished calling camel\"); }if you run this example, you should see output to the console that shows the threads in use during routing:[main] info caller - caller calling camel with message: hello camel [main] info caller - caller finishe...',1),(7403,'the last two lines show the other two threads involved in routing the message inside camel',1),(7404,'in this scenario, the caller is asynchronous because it can continue without waiting for a reply',1),(7405,'this model has a different set of pros and cons from the camel perspective, as listed in table 10',1),(7406,'in a real-world situation, you might want to use this scenario when consuming files, as we did in section 10',1),(7407,'by not having the consumer thread process the file, it’s free to pick up new files',1),(7408,'and by using multiple threads in camel, you can maximize throughput as multiple threads can work simultaneously on multiple files',1),(7409,'another use case when multiple threads can be an advantage is when you process big messages that can be split into smaller submessages for further processing',1),(7410,'this is what we did in section 10',1),(7411,'1 using the parallelprocessing option on the splitter eip',1),(7412,'the next scenario is similar to this one, but it uses a request-response messaging style',1),(7413,'4 synchronous caller using multiple threadsthe synchronous inout scenario involving multiple threads inside camel is illustrated in figure 10',1),(7414,'in this scenario, the situation is a bit more complex because the caller is waiting for a reply and camel is using multiple threads to process the message',1),(7415,'this means the consumer thread that received the request must block until the routing istable 10',1),(7416,'6 pros and cons of using an asynchronous caller and having multiple threads, from the camel                     perspectivepros cons■ leverages the seda principle of decoupled stages■ dispatching is decoupled from consuming■ transaction propagation i...',1),(7417,'info341synchronicity and threadingcomplete, so it can deliver the reply back to the waiting caller',1),(7418,'if this sounds a bit confusing, don’t be alarmed',1),(7419,'we’ll unlock how this works when we look at the asynchronous client api in section 10',1),(7420,'the route you use for testing this scenario is as follows:from(\"seda:start\")',1),(7421,'threads(5, 10)',1),(7422,'transform(constant(\"bye camel\"))',1),(7423,'to(\"log:b\");the unit test uses the requestbody method to send an inout message to camel:public void testasyncinout() throws exception {    string body = \"hello camel\";    log',1),(7424,'info(\"caller calling camel with message: \" + body);    object reply = template',1),(7425,'requestbody(\"seda:start\", body);    log',1),(7426,'info(\"caller received reply: \" + reply); }if you run this example, you should see output to the console that shows the threads in use during routing:[main] info caller - caller calling camel with message: hello camel [camel thread 0 - seda://start] i...',1),(7427,'consumercaller camellog a log bconsumerthread poolthreadsthreadsthread poolfigure 10',1),(7428,'11 in synchronous mode, the caller waits for a reply',1),(7429,'on the camel side, multiple threads are involved during the routing of the message',1),(7430,'the consumer thread has to block, waiting for the reply, which it must send back to the waiting caller',1),(7431,'info342 chapter 10 concurrency and scalability what the lines also reveal is that the caller received \"bye camel\" as the reply',1),(7432,'this may seem a bit like magic, as the \"bye camel\" message was constructed in the last part of the route',1),(7433,'that means the consumer thread somehow knew that it had to block until the reply message was ready',1),(7434,'although this might seem like magic, there is no such magic in camel or the java language',1),(7435,'it’s the java concurrency api that allows you to wait for an asynchronous task to complete, using what is called a future handle',1),(7436,'we’ll cover this in more detail in section 10',1),(7437,'7 presents the pros and cons of this scenario',1),(7438,'this scenario can be used when you want to return an early reply to the waiting caller',1),(7439,'suppose you expose a web service and want to return an ok reply as quickly as possible',1),(7440,'by dispatching the received messages asynchronously, you allow the consumer thread to continue and return the early reply to the caller',1),(7441,'this may sound easy, but the mep impacts how this can be done correctly',1),(7442,'let’s take a moment to map out the pitfalls',1),(7443,'5 returning an early reply to a callerconsider an example in which a caller invokes a camel service in a synchronous manner—the caller is blocked while waiting for a reply',1),(7444,'in the camel service, you want to send a reply back to the waiting caller as soon as possible; the reply is an acknowledgement that the input has been received, so \"ok\" is returned to the caller',1),(7445,'in the meantime, camel continues processing the received message in another thread',1),(7446,'12 illustrates this example in a sequence diagram',1),(7447,'implementing this example as a camel route with the java dsl can be done as follows:table 10',1),(7448,'7 pros and cons of using a synchronous caller and having multiple threads, from the camel                     perspectivepros cons■ leverages the seda principle of decoupled stages■ dispatching is decoupled from consuming■ allows consumer to return e...',1),(7449,'12 a synchronous caller invokes a camel service',1),(7450,'the service lets the wire tap continue processing the message asynchronously while the service returns an early reply to the waiting caller',1),(7451,'info343synchronicity and threadingfrom(\"jetty:http://localhost:8080/early\")',1),(7452,'transform()',1),(7453,'constant(\"ok\");                   from(\"direct:incoming\")',1),(7454,'routeid(\"process\")',1),(7455,'class)',1),(7456,'log(\"processing done for ${body}\")',1),(7457,'to(\"mock:result\"); }you leverage the wire tap eip b to continue routing the incoming message in a separate thread',1),(7458,'this gives room for the consumer to immediately reply c to the waiting caller',1),(7459,'here’s an equivalent example using spring xml:<camelcontext xmlns=\"http://camel',1),(7460,'org/schema/spring\">    <route routeid=\"input\">        <from uri=\"jetty:http://localhost:8080/early\"/>        <wiretap uri=\"direct:incoming\"/>                           <transform>                             <constant>ok</constant>                 </...',1),(7461,'you can run the example using the following maven goals:mvn test -dtest=earlyreplytest mvn test -dtest=springearlyreplytestwhen you run the example, you should see the console output showing how the message is processed:11:18:15 [main] info - caller ...',1),(7462,'the last log line shows that the wire tap eip finished processing the message 3 seconds after the caller received the reply',1),(7463,'tap incoming messagebreturn early replyctap incoming messagebreturn early replyc    www',1),(7464,'info344 chapter 10 concurrency and scalabilitynote in the preceding example, the route with id \"process\", you need to convert the body to a string type to ensure that you can read the message multiple times',1),(7465,'this is necessary because jetty is stream-based, which causes it to only be able to read the message once',1),(7466,'or, instead of converting the body, you could enable stream caching—we’ll cover stream caching in chapter 13',1),(7467,'so far in this chapter, you’ve seen concurrency used in camel routes by the various eips that support them',1),(7468,'but camel also has a strong client api, manifested in the producertemplate and consumertemplate classes (see appendix c)',1),(7469,'these classes have easy-to-use methods for sending messages to any endpoint you choose',1),(7470,'in the next section, you’ll learn what those classes have to offer when it comes to concurrency',1),(7471,'5 the concurrency client apiyou can use the concurrency client api directly from java code, which means you’re in full control of what should happen',1),(7472,'you don’t have to use camel routes and eips to achieve concurrency',1),(7473,'to fully understand the concurrency api from the client point of view, we’ll look at how you can achieve concurrency with pure java',1),(7474,'then we’ll look at the same example using camel’s producertemplate',1),(7475,'we’ll end this section by looking at how the camel client api allows you to easily submit concurrent messages to different endpoints and leverage a callback mechanism to gather the replies when they come back',1),(7476,'1 the concurrency client api in javathe concurrency api in java is located in the java',1),(7477,'concurrent package, and it was introduced in java 5 (aka jdk 1',1),(7478,'all the concurrency behavior in camel is built on top of this api',1),(7479,'for example, the camel thread pools are all executorservice instances, which are capable of executing tasks concurrently and asynchronously',1),(7480,'java’s concurrency api includes the following classes that are interesting to learn about and understand from a developer’s point of view:■ executorservice—this is the foundation for executing tasks in an asynchronous manner',1),(7481,'■ callable—this represents an asynchronous task',1),(7482,'think of it as an improved runnable that can return a result or throw an exception',1),(7483,'■ future—this represents the lifecycle of an asynchronous task and provides methods to test whether the task has completed or been cancelled, to retrieve its result, and to cancel the task',1),(7484,'13 is a sequence diagram that depicts how these three concepts are related and how they’re involved in a typical use case where an asynchronous task is being executed',1),(7485,'13 shows how a client creates a new callable, which represents the tasks (the code) you want to be executed asynchronously',1),(7486,'the task is then submitted to an executorservice, which is responsible for further processing the task',1),(7487,'before the task    www',1),(7488,'info345the concurrency client apiis executed, a future is returned to the client',1),(7489,'the future is a handle that the client can use at any point later on to retrieve the result of the task',1),(7490,'listing 10',1),(7491,'4 shows how this works in java code',1),(7492,'public void testfuturewithdone() throws exception {    callable<string> task = new callable<string>() {               public string call() throws exception {            thread',1),(7493,'sleep(5000);            return \"camel rocks\";        }    };    executorservice executor = executors',1),(7494,'submit(task);                  boolean done = false;    while (',1),(7495,'isdone();                            log',1),(7496,'info(\"is the task done',1),(7497,'\" + done);        if (',1),(7498,'sleep(2000);        }    }    string answer = future',1),(7499,'info(\"the answer is: \" + answer); }the task to be executed is located within the call method of the callable b',1),(7500,'note that you can use generics to specify the result type as a string',1),(7501,'the task is then submitted to the executorservice c, which returns a future<string> handle; the generic type matches the type from the task',1),(7502,'while the task is being processed, you can do other computations, but in this example you just loop and wait for the task to be done d',1),(7503,'at the end, you can retrieve the result using the get method e',1),(7504,'listing 10',1),(7505,'4 asynchronous task execution using the java apiexecutorservice futuresubmitcreatesreturnscallableclientnewfigure 10',1),(7506,'13 the client submits tasks (callable) to be executed asynchronously by executorservice, which returns a future handle to the client',1),(7507,'creates taskbsubmits taskcwaits until task is donedgets task resulte    www',1),(7508,'info346 chapter 10 concurrency and scalability the source code for the book contains this example in the chapter10/client directory',1),(7509,'you can use the following maven goal to run the example:mvn test -dtest=camelfuturedonetestwhen you run the example, the console should output what’s happening:07:29:30 [main] - submitting task to executorservice 07:29:30 [main] - task submitted and ...',1),(7510,'false 07:29:32 [main] - is the task done',1),(7511,'false 07:29:34 [main] - is the task done',1),(7512,'false 07:29:35 [pool-1-thread-1] - task is now done 07:29:36 [main] - is the task done',1),(7513,'true 07:29:36 [main] - the answer is: camel rocksas you can see from the console output, the task executes in a thread named \"pool-1thread-1\" while the caller executes in the main thread',1),(7514,'this output also proves that the client waits until the task is done',1),(7515,'there’s a smarter way to retrieve the result than by looping and testing whether the task is done—you can use the get method on the future handle which will automatically wait until the task is done',1),(7516,'removing the while loop from the code in listing 10',1),(7517,'4 and running the example will output the following:07:37:20 [main] - submitting task to executorservice 07:37:20 [main] - task submitted and we got a future handle 07:37:20 [pool-1-thread-1] - starting to process task 07:37:25 [pool-1-thread-1] - ta...',1),(7518,'invoking the get method on future causes it to wait until the task is done and to react promptly when it is done',1),(7519,'the source code for the book contains this example in the chapter10/client directory',1),(7520,'you can use the following maven goal to run the example:mvn test -dtest=camelfuturegettest you’ve seen how clients leverage future to retrieve the result of tasks that have been submitted for asynchronous execution',1),(7521,'8 lists the most commonly used methods provided by future',1),(7522,'8 commonly used methods in the java',1),(7523,'future classmethod descriptionget() waits, if necessary, for tasks to complete, and then returns the result',1),(7524,'will throw an executionexception if the tasks throw an exception',1),(7525,'get(timeout, timeunit)waits, if necessary, for at most the specified time for the task to complete, and then returns the result if available',1),(7526,'will throw an executionexception if the tasks throw an exception',1),(7527,'timeoutexception is thrown if timed out',1),(7528,'isdone() returns true if the task is done; otherwise false is returned',1),(7529,'info347the concurrency client apiunderstanding the principle of future is important because it’s the same mechanism camel leverages internally when it processes messages asynchronously',1),(7530,'future also plays a role in the concurrency client api provided by camel, which we’re going to take a look at now',1),(7531,'2 the concurrency client api in camelthe client concurrency api in camel is provided in the producertemplate class',1),(7532,'it offers a range of methods that camel end users can leverage to submit messages to camel to be further processed asynchronously',1),(7533,'consider the following route:from(\"seda:quote\")',1),(7534,'transform()',1),(7535,'constant(\"camel rocks\")',1),(7536,'log(\"route is now done\");you can see that this route will delay processing the message for 5 seconds, which means it will take at least 5 seconds for the reply to be returned',1),(7537,'this is the same situation as in the previous example (section 10',1),(7538,'1), where the callable tasks also took 5 seconds to complete',1),(7539,'this allows us to compare this example with the previous one to see how easy it is in camel to use the concurrency client api',1),(7540,'sending a message asynchronously to the \"seda:quote\" endpoint is easy to do in camel by using the asyncrequestbody method as shown here:public void testfuturewithoutdone() throws exception {    log',1),(7541,'info(\"submitting task to camel\");    future<string> future = template',1),(7542,'asyncrequestbody(\"seda:quote\",                                \"hello camel\", string',1),(7543,'class);    log',1),(7544,'info(\"task submitted and we got a future handle\");    string answer = future',1),(7545,'info(\"the answer is: \" + answer); }the source code for the book contains this example in the chapter10/client directory',1),(7546,'you can use the following maven goal to run the example:mvn test -dtest=camelfuturetestif you run this example, the console should output something like the following:11:02:49 [main] - submitting task to camel 11:02:49 [main] - task submitted and we ...',1),(7547,'this allows camel end users to more easily learn and use the camel concurrency api, as it’s based on and similar to the java concurrency api',1),(7548,'info348 chapter 10 concurrency and scalability table 10',1),(7549,'9 lists the most commonly used methods, provided by producertemplate',1),(7550,'all the methods listed will return a future handle',1),(7551,'notice that all the methods listed in table 10',1),(7552,'9 start with async in their method name',1),(7553,'this makes them easy to remember when you need to send a message asynchronously',1),(7554,'the last three methods in table 10',1),(7555,'9 support a callback mechanism, which makes sense in situations where you may need to use the same callback for several tasks',1),(7556,'let’s look at an example now, to make this all a bit clearer',1),(7557,'using asynccallbackrider auto parts has a selected number of premium partners who are promoted exclusively on the rider auto parts web store',1),(7558,'whenever a customer browses the items catalog, the partners are listening and can provide feedback about related items',1),(7559,'for example, if you browse for bumper parts, the partners can suggest related items, such as bumper extensions or other car parts',1),(7560,'the partners have to return their feedback within a given time period, so the user experience of browsing the website isn’t slowed down noticeably',1),(7561,'implementing such a use case is possible using the camel concurrency client api',1),(7562,'you can use a callback to gather the partner feedback within the given time period',1),(7563,'the callback is defined in camel as the org',1),(7564,'9 commonly used asynchronous methods in the producertemplate classmethod descriptionasyncsend(endpoint, exchange) sends the exchange to the given endpointasyncsendbody(endpoint, body) sends the body to the given endpoint using inonlyas the exchange p...',1),(7565,'info349the concurrency client apipublic interface synchronization  {    void oncomplete(exchange exchange);    void onfailure(exchange exchange); }the callback has two methods: the first is invoked when the exchange is processed successfully, and the...',1),(7566,'listing 10',1),(7567,'5 shows how this can be implemented in camel',1),(7568,'public void testcallback() throws exception {    final list<string> relates = new arraylist<string>();    final countdownlatch latch = new countdownlatch(5);         synchronization callback =            new synchronizationadapter() {                ...',1),(7569,'class));            latch',1),(7570,'countdown();        }    };    string body = \"bumper\";    for (int i = 0; i < 5; i++) {        template',1),(7571,'asynccallbackrequestbody(            \"seda:partner:\" + i, body, callback);            }    log',1),(7572,'info(\"send \" + 5 + \" messages to partners',1),(7573,'info(\"got \" + relates',1),(7574,'size() + \" replies, is all',1),(7575,'\" + all);    for (string related : relates) {        log',1),(7576,'info(\"related item category is: \" + related);    }you use a countdownlatch b to let you know when you’ve received all the replies or the given time period is up',1),(7577,'the callback is used to gather the replies in the relates list',1),(7578,'you use the org',1),(7579,'synchronizationadapter class to implement the callback logic c',1),(7580,'it allows you to override the oncomplete and onfailure methods',1),(7581,'the oncomplete method is invoked when the message is routed successfully, so we get a valid reply for the business partner',1),(7582,'the onfailure method is invoked if the routing fails',1),(7583,'in both situations, you need to count down the latch to keep track of the number of replies coming back',1),(7584,'now you’re ready to send messages to the partners about which category the user is browsing',1),(7585,'in this test, the category is set to \"bumper\"',1),(7586,'you use the asynccallbackrequestbody method d, listed in table 10',1),(7587,'9, to send the \"bumper\" message to thelisting 10',1),(7588,'5 using a callback to gather replies asynchronously counts replies receivedbgathers repliescinvokes partnersdwaits for replies with timeoute    www',1),(7589,'info350 chapter 10 concurrency and scalabilitypartners and have their replies gathered by the callback',1),(7590,'this is done asynchronously, so you need to wait until the replies are gathered or the time period is up',1),(7591,'for that, you use the countdown latch e',1),(7592,'in this example, you wait until all five replies have been gathered or the timeout is triggered',1),(7593,'the source code for the book includes this example in the chapter10/client directory',1),(7594,'you can run it by invoking the following maven goal:mvn test -dtest=riderautopartscallbacktestif you run this example, you should get the following output on the console:11:03:23,078 [main] info - send 5 messages to partners',1),(7595,'11:03:24,629 [main] info - got 3 replies, is all',1),(7596,'false 11:03:24,629 [main] info - related item category is: bumper extension 11:03:24,630 [main] info - related item category is: bumper filter 11:03:24,630 [main] info - related item category is: bumper coverin this example, you send to five differen...',1),(7597,'as you’ve seen, the camel concurrency client api is powerful, as it combines the power from camel with an api resembling the equivalent concurrency api in java',1),(7598,'that’s all we have to say about the asynchronous client api',1),(7599,'the next section covers what you can do in camel to improve scalability',1),(7600,'6 the asynchronous routing enginecamel uses its routing engine to route messages either synchronously or asynchronously',1),(7601,'in this section we focus on scalability and learn that higher scalability can be achieved with the help of the asynchronous routing engine',1),(7602,'for a system, scalability is the desirable property of being capable of handling a growing amount of work gracefully',1),(7603,'in section 10',1),(7604,'1, we covered the rider auto parts inventory application, and you saw you could increase throughput by leveraging concurrent processing',1),(7605,'in that sense, the application was scalable, as it could handle a growing amount of work in a graceful manner',1),(7606,'that application could scale because it had a mix of cpu-bound and io-bound processes, and because it could leverage thread pools to distribute work',1),(7607,'in this section, we’ll look at scalability from a different angle',1),(7608,'we’ll look at what happens when messages are processed asynchronously',1),(7609,'1 hitting the scalability limitrider auto parts uses a camel application to service its web store, as illustrated in figure 10',1),(7610,'a jetty consumer handles all requests from the customers',1),(7611,'there are a variety of requests to handle, such as updating shopping carts, performing searches, gathering production information, and so on—the usual functions you expect from a web store',1),(7612,'but there’s one function that involves calculating pricing information for customers',1),(7613,'the pricing model is complex and individual for each customer—only the erp system    www',1),(7614,'info351the asynchronous routing enginecan calculate the pricing',1),(7615,'as a result, the camel application communicates with the erp system to gather the prices',1),(7616,'while the prices are being calculated by the erp system, the web store has to wait until the reply comes back, before it returns its response to the customer',1),(7617,'the business is doing well for the company, and an increasing number of customers are using the web store, which puts more load on the system',1),(7618,'lately there have been problems during peak hours, with customers reporting that they can’t access the web store or that it’s generally responding slowly',1),(7619,'the root cause has been identified: the communication with the erp system is fully synchronous, and the erp system takes an average of 5 seconds to compute the pricing',1),(7620,'this means each request that gathers pricing information has to wait (the thread is blocked) an average of 5 seconds for the reply to come back',1),(7621,'this puts a burden on the jetty thread pool, as there are fewer free threads to service new requests',1),(7622,'15 illustrates this problem',1),(7623,'you can see that the thread is blocked (the white boxes) while waiting for the erp system to return a reply',1),(7624,'riderautopartserpcustomerweb storeservicerider auto partsweb store applicationjettyconsumerfigure 10',1),(7625,'14 the rider auto parts web store communicates with the erp system to gather pricing information',1),(7626,'web storeservicejettyconsumererpcustomerhttp requestprocessrequestreplyhttp responsereturn truefigure 10',1),(7627,'15 a scalability problem illustrated by the thread being blocked (represented as white boxes) while waiting for the erp system to return a the reply',1),(7628,'info352 chapter 10 concurrency and scalabilityfigure 10',1),(7629,'15 reveals that the jetty consumer is using one thread per request',1),(7630,'this leads to a situation where you run out of threads as traffic increases',1),(7631,'you’ve hit a scalability limit',1),(7632,'let’s look into why, and look at what camel has under the hood to help mitigate such problems',1),(7633,'2 scalability in camelit would be much better if the jetty consumer could somehow borrow the thread while it waits for the erp system to return the reply, and use the thread in the meantime to service new requests',1),(7634,'this can be done by using an asynchronous processing model',1),(7635,'16 shows the principle',1),(7636,'if you compare figures 10',1),(7637,'16, you can see that the threads are much less blocked in the latter (the white boxes are smaller)',1),(7638,'in fact, there are no threads blocked while the erp system is processing the request',1),(7639,'this is a huge scalability improvement because the system is much less affected by the processing speed of the erp system',1),(7640,'if it takes 1, 2, 5, or 30 seconds to reply, it doesn’t affect the web store’s resource utilization as much as it would otherwise do',1),(7641,'the threads in the web store are much less io-bound and are put to better use doing actual work',1),(7642,'17 shows a situation in which two customer requests are served by the same thread without impacting response times',1),(7643,'in this situation, customer 1 sends a request that requires a price calculation, so the erp system is invoked asynchronously',1),(7644,'a short while thereafter, customer 2 sends a request that can be serviced directly by the web shop service, so it doesn’t leverage theweb storeservicejettyconsumererpcustomerhttp requestprocessrequestreplyreturn falsehttp responsedonereturnfigure 10',1),(7645,'16 the scalability problem is greatly improved',1),(7646,'threads are much less blocked (represented by white boxes) when you leverage asynchronous communication between the systems',1),(7647,'info353the asynchronous routing engineasynchronous processing model (it’s synchronous)',1),(7648,'the response is sent directly back to customer 2',1),(7649,'later, the erp system returns the reply, which is sent back to the waiting customer 1',1),(7650,'in this example, you can successfully process two customers without any impact on their response time',1),(7651,'you’ve achieved higher scalability',1),(7652,'in the next section, we’ll look under the hood to see how this is possible in camel using the asynchronous processing model',1),(7653,'3 components supporting asynchronous processingthe routing engine in camel is capable of routing messages either synchronously or asynchronously',1),(7654,'the latter requires the camel component to support asynchronous processing, which in turn depends on the underlying transport supporting asynchronous communication',1),(7655,'10 lists the components in camel 2',1),(7656,'5 that support asynchronous communication',1),(7657,'web storeservicejettyconsumererpcustomer 1processrequestreplyreturn falsedonereturncustomer 2processreturn truefigure 10',1),(7658,'17 the same thread services multiple customers without blocking (white and grey boxes) and without impacting response times, resulting in much higher scalability',1),(7659,'apache servicemix supports high scalabilityapache servicemix (http://servicemix',1),(7660,'org/) is an enterprise service bus (esb) that can host your camel application',1),(7661,'in terms of high scalability, servicemix offers a message bus (the jbi and nmr components) for passing messages inside your application or between applications',1),(7662,'the message bus supports the asynchronous processing model described in this chapter, which means it’s highly scalable',1),(7663,'info354 chapter 10 concurrency and scalabilitynote the camel team will add support for additional components in the future',1),(7664,'you can check the online documentation for an updated list of supported components: http://camel',1),(7665,'org/asynchronous-routing-engine',1),(7666,'in order to achieve high scalability in the rider auto parts web store, you need to use asynchronous routing at two points',1),(7667,'the communication with the erp system and with the jetty consumer must both happen asynchronously',1),(7668,'the camel-jetty component already supports this',1),(7669,'communication with the erp system must happen asynchronously too',1),(7670,'to understand how this is possible with camel, we’ll take a closer look at figure 10',1),(7671,'the figure reveals that after the request has been submitted to the erp system, the thread won’t block but will return to the jetty consumer',1),(7672,'it’s then up to the erp transport to notify camel when the reply is ready',1),(7673,'when camel is notified, it will be able to continue routing and let the jetty consumer return the http response to the waiting customer',1),(7674,'to enable all this to work together, camel provides an asynchronous api that the components must use',1),(7675,'in the next section, we’ll walk through this api',1),(7676,'4 asynchronous apicamel supports an asynchronous processing model, which we refer to as the asynchronous routing engine',1),(7677,'there are advantages and disadvantages of using asynchronoustable 10',1),(7678,'10 components that support asynchronous processingcomponent descriptioncamel-cxf supports asynchronous routing at both the consumer and producer levels',1),(7679,'camel-jbi supports asynchronous routing at both the consumer and producer levels',1),(7680,'requires apache servicemix',1),(7681,'camel-jetty supports asynchronous routing at both the consumer and producer levels',1),(7682,'camel-jms supports asynchronous routing at the producer level when using request-response over jms queues',1),(7683,'camel-netty supports asynchronous routing at the producer level',1),(7684,'camel-nmr supports asynchronous routing at both the consumer and producer levels',1),(7685,'requires apache servicemix',1),(7686,'jetty and continuationsthe jetty servlet engine uses continuations to achieve high scalability',1),(7687,'it allows camel to park a request and later retrieve the request and continue processing it',1),(7688,'you can read more about continuations at the jetty website: http://wiki',1),(7689,'eclipse',1),(7690,'info355the asynchronous routing engineprocessing, compared to using the standard synchronous processing model',1),(7691,'they’re listed in table 10',1),(7692,'the asynchronous processing model is manifested by an api that must be implemented to leverage asynchronous processing',1),(7693,'you’ve already seen a glimpse of this api in figure 10',1),(7694,'16; the arrow between the jetty consumer and the web store service has the labels return false and done',1),(7695,'let’s see the connection that those labels have with the asynchronous api',1),(7696,'asyncprocessorthe asyncprocessor is an extension of the synchronous processor api:public interface asyncprocessor extends processor {   boolean process(exchange exchange, asynccallback callback); }the asyncprocessor defines a single process method th...',1),(7697,'process sibling',1),(7698,'here are the rules that apply when using asyncprocessor:■ a non-null asynccallback must be supplied; it will be notified when the exchange processing is completed',1),(7699,'■ the process method must not throw any exceptions that occur while processing the exchange',1),(7700,'any such exceptions must be stored on the exchange’s exception property',1),(7701,'■ the process method must know whether it will complete the processing synchronously or asynchronously',1),(7702,'the method will return true if it completes synchronously; otherwise it returns false',1),(7703,'■ when the processor has completed processing the exchange, it must call the callback',1),(7704,'the donesync parameter must match the value returned by the process method',1),(7705,'the preceding rules may seem a bit confusing at first',1),(7706,'don’t worry, the asynchronous api isn’t targeted at camel end users but at camel component writers',1),(7707,'in the next section, we’ll cover an example of how to implement a custom component that acts asynchronously',1),(7708,'you’ll be able to use this example as a reference if you need to implement a custom component',1),(7709,'note you can read more about the asynchronous processing model at the camel website: http://camel',1),(7710,'org/asynchronous-processing',1),(7711,'11 advantages and disadvantages of using the asynchronous processing modeladvantages disadvantage■ processing messages asynchronously doesn’t use up threads, forcing them to wait for processors to complete on blocking calls',1),(7712,'■ it increases the scalability of the system by reducing the number of threads needed to manage the same workload',1),(7713,'■ implementing asynchronous processing is more complex',1),(7714,'info356 chapter 10 concurrency and scalabilitythe asynccallback api is a simple interface with one method:public interface asynccallback {    void done(boolean donesync); }it’s this callback that’s invoked when the erp system returns the reply',1),(7715,'this notifies the asynchronous routing engine in camel that the exchange is ready to be continued, and the engine can then continue routing it',1),(7716,'let’s see how this all fits together by digging into the example and looking at some source code',1),(7717,'5 writing a custom asynchronous componentthe source code for the book contains the web store example in the chapter10/scalability directory',1),(7718,'this example contains a custom erp component that simulates asynchronous communication with an erp system',1),(7719,'listing 10',1),(7720,'6 shows how the erpproducer is implemented',1),(7721,'asynccallback; import org',1),(7722,'defaultasyncproducer;public class erpproducer extends defaultasyncproducer {       private executorservice executor;    public erpproducer(endpoint endpoint) {        super(endpoint);        executor = endpoint',1),(7723,'newfixedthreadpool(this, \"erp\", 10);    }    public boolean process(final exchange exchange,                                  final asynccallback callback) {        executor',1),(7724,'submit(new erptask(exchange, callback));        log',1),(7725,'info(\"returning false\");        return false;                                   }    private class erptask implements runnable {        private final exchange exchange;        private final asynccallback callback;        private erptask(exchange exch...',1),(7726,'callback = callback;        }        public void run() {listing 10',1),(7727,'6 erpproducer using the asynchronous processing modelextends defaultasyncproducerbimplements asynchronous process methodcreturns false to use asynchronous processingd    www',1),(7728,'info357the asynchronous routing engine            log',1),(7729,'class);            exchange',1),(7730,'setbody(in + \";516\");                       log',1),(7731,'done(false);                 }    } }when implementing a custom asynchronous component, it’s most often the producer that leverages asynchronous communication, and a good starting point is to extend the defaultasyncproducer b',1),(7732,'to simulate asynchronous communication, you use a thread pool to execute tasks asynchronously; this means you need to create a thread pool in the constructor',1),(7733,'to support the asynchronous processing model, the erpproducer must also implement the asynchronous process method c',1),(7734,'to simulate the communication, which takes 5 seconds to reply, you submit erptask to the thread pool',1),(7735,'when the 5 seconds are up, the reply is ready, and it’s set on the exchange e',1),(7736,'according to the rules, when you’re using asyncprocessor the callback must be notified when you’re done with a matching synchronous parameter f',1),(7737,'in this example, false is used as the synchronous parameter because the process method returned false d',1),(7738,'by returning false, you instruct the camel routing engine to leverage asynchronous routing from this point forward for the given exchange',1),(7739,'you can try this example by running the following maven goal from the chapter10/scalability directory:mvn test -dtest=scalabilitytestthis runs two test methods: one request is processed fully synchronously (not using the erp component), and the other...',1),(7740,'when running the test, pay attention to the console output',1),(7741,'the synchronous test will log input and output as follows:2010-07-16 11:41:42 [     qtp1444378545-11] info  input - exchange[exchangepattern:inout, body:1234;4;1719;bumper] 2010-07-16 11:41:42 [     qtp1444378545-11] info  output - exchange[exchangep...',1),(7742,'sets reply on exchangeenotifies callback reply is readyf    www',1),(7743,'info358 chapter 10 concurrency and scalability the asynchronous example is different, as the console output reveals:2010-07-16 11:49:48 [     qtp515060127-11] info  input - exchange[exchangepattern:inout, body:1234;4;1719;bumper] 2010-07-16 11:49:48 ...',1),(7744,'the first is the thread from jetty, which received the http request',1),(7745,'as you can see, this thread was used to route the message to the erpproducer',1),(7746,'the other thread takes over communication with the erp system',1),(7747,'when the reply is received from the erp system, the callback is notified, which lets camel highjack the thread and use it to continue routing the exchange',1),(7748,'you can see this from the last line, which shows the exchange routed to the log component',1),(7749,'this concludes our coverage of scalability with camel',1),(7750,'7 summary and best practicesin this chapter, we looked at thread pools, which are the foundation for concurrency in java',1),(7751,'we saw how concurrency greatly improves performance and we looked at all the possible ways to create, define, and use thread pools in camel',1),(7752,'you saw how easy it was to use concurrency with the numerous eips in camel, and you also saw how synchronicity affects the way threading occurs in camel',1),(7753,'java provides a concurrency api, which we compared to the camel concurrency api',1),(7754,'both apis offer you full control over submitting and executing asynchronous tasks',1),(7755,'here are some best practices related to concurrency:■ leverage concurrency if possible',1),(7756,'concurrency can greatly speed up your applications',1),(7757,'note that using concurrency requires business logic that can be invoked in a concurrent manner',1),(7758,'■ tweak thread pools judiciously',1),(7759,'only tweak the thread pools when you have a means of measuring the changes',1),(7760,'it’s often better to rely on the default settings',1),(7761,'understand the asynchronous api from java, such as callable and the future handle',1),(7762,'■ use asynchronous processing for high scalability',1),(7763,'if you require high scalability, try using the camel components that support the asynchronous processing model (listed in table 10',1),(7764,'you will learn, among other things, how to start a new camel project from scratch',1),(7765,'info359developing camel projectsat this point you should know a thing or two about how to develop camel routes and how to take advantage of many camel features',1),(7766,'but do you know how to best start a camel project from scratch',1),(7767,'you could take an existing example and modify it to fit your use case, but that’s not always ideal',1),(7768,'and what if you need to integrate with a system that isn’t supported out of the box by camel',1),(7769,'in this chapter, we’ll show you how to build your own camel applications',1),(7770,'we’ll go over the maven archetype tooling that’ll allow you to skip the boring boilerplate project setup and create new camel projects with a single command',1),(7771,'we’ll also show you how to start a camel project from eclipse, when you need the extra power that an ide provides',1),(7772,'this chapter covers■ creating camel projects with maven■ creating camel projects in the eclipse ide■ creating custom components ■ creating custom interceptors■ using camel in alternative languages    www',1),(7773,'info360 chapter 11 developing camel projects after that, we’ll show you how to extend camel by creating custom components and custom interceptors',1),(7774,'finally, we’ll wrap up by showing you how camel projects can be created in languages other than java, like scala',1),(7775,'1 managing projects with mavencamel was built using apache maven right from the start, so it makes sense that creating new camel projects is easiest when using maven',1),(7776,'in this section, we’ll show you camel’s maven archetypes, which are preconfigured templates for creating various types of camel projects',1),(7777,'after that, we’ll talk about using maven dependencies to load camel modules and their third-party dependencies into your project',1),(7778,'2 of chapter 1 has an overview of apache maven',1),(7779,'if you need a maven refresher, you might want to review that section before continuing on here',1),(7780,'1 using camel maven archetypescreating maven-based projects is a pretty simple task',1),(7781,'you mainly have to worry about creating a pom file and the various standard directories that you’ll be using in your project',1),(7782,'but if you’re creating many projects, this can get pretty repetitive because there’s a lot of boilerplate setup required for new projects',1),(7783,'archetypes in maven provide a means to define project templates and generate new projects based on those templates',1),(7784,'they make creating new maven-based projects easy because they create all the boilerplate pom elements, as well as key source and configuration files useful for particular situations',1),(7785,'note for more information on maven archetypes, see the guide on the official maven website: http://maven',1),(7786,'org/guides/introduction/ introduction-to-archetypes',1),(7787,'sonatype also provides a chapter on archetypes in the freely available maven: the complete reference book: http:// www',1),(7788,'com/books/mvnref-book/reference/archetypes',1),(7789,'as illustrated in figure 11',1),(7790,'1, this is all coordinated by the maven archetype plugin',1),(7791,'this plugin accepts user input and replaces portions of the archetype to form a new project',1),(7792,'to demonstrate how this works, let’s look at the maven quickstart archetype, which will generate a plain java application (no camel dependencies)',1),(7793,'it’s the default option when you run this command:mvn archetype:generatemaven archetypepluginnew camelprojectcamelarchetypecreatesdeveloperfigure 11',1),(7794,'1 a camel archetype and user input are processed by the maven archetype plugin, which then creates a new camel project',1),(7795,'info361managing projects with maventhe archetype plugin will ask you various questions, like what groupid and artifactid to use for the generated project',1),(7796,'when it’s complete, you’ll have a directory structure similar to this:myapp |-- pom',1),(7797,'xml `-- src    |-- main    |   `-- java    |       `-- camelinaction    |           `-- app',1),(7798,'java    `-- test        `-- java            `-- camelinaction                `-- apptest',1),(7799,'javain this structure, myapp is the artifactid and camelinaction is the groupid',1),(7800,'xml file, a java source file, and a unit test, all in the proper locations',1),(7801,'note maven follows the convention over configuration paradigm, so locations are very important',1),(7802,'without any additional configuration, maven knows that it should compile the java source under the src/main/java directory and run all unit tests under the src/test/ java directory',1),(7803,'to kick off this process, you just need to run the following maven command:mvn testif you want to take it a step further, you could tell maven to create a jar file after compiling and testing by replacing the test goal with package',1),(7804,'you could start using camel right from this example project, but it would involve adding camel dependencies like camel-core, starting up the camelcontext, and creating the routes',1),(7805,'although this wouldn’t take that long, there’s a much quicker solution: you can use one of the six archetypes provided by camel to generate all this boilerplate camel stuff for you',1),(7806,'1 lists these archetypes and their main use cases',1),(7807,'1 camel’s maven archetypesarchetype name descriptioncamel-archetype-activemq creates a camel project that has an embedded apache activemq broker',1),(7808,'camel-archetype-component creates a new camel component',1),(7809,'camel-archetype-java creates a camel project that loads up a camelcontext in spring and defines a sample route in java',1),(7810,'camel-archetype-scala creates a camel project with a sample route in the scala dsl',1),(7811,'in section 11',1),(7812,'info362 chapter 11 developing camel projectsout of these six archetypes, the most commonly used one is probably the camelarchetype-java archetype',1),(7813,'we’ll try this out next',1),(7814,'using the camel-archetype-java archetypethe camel-archetype-java archetype listed in table 11',1),(7815,'1 boots up a spring-based camelcontext and a java dsl route',1),(7816,'with this, we’ll show you how to re-create the order-routing service for rider auto parts as described in chapter 2',1),(7817,'the project will be named order-router and the package name in the source will be camelinaction',1),(7818,'to create the skeleton project for this service, run the following maven command:mvn archetype:create \\  -darchetypegroupid=org',1),(7819,'archetypes \\   -darchetypeartifactid=camel-archetype-java \\  -darchetypeversion=2',1),(7820,'0 \\  -dgroupid=camelinaction \\  -dartifactid=order-routeryou specify the archetype to use by setting the archetypeartifactid property to camel-archetype-java',1),(7821,'you could replace this with any of the archetype names listed in table 11',1),(7822,'the archetypeversion property is set to the version of camel that you want to use',1),(7823,'after a few seconds of activity, maven will have created an order-router subdirectory in the current directory',1),(7824,'the order-router directory layout is shown in the following listing',1),(7825,'xml camel-archetype-spring creates a camel project that loads up a camelcontext in spring and defines a sample route in the spring dsl (similar to camel-archetypejava, but with the route transposed to the spring dsl)',1),(7826,'camel-archetype-war creates a camel project that includes the camel web console, rest api, and a few sample routes as a war file',1),(7827,'listing 11',1),(7828,'1 camel’s maven archetypes (continued)archetype name descriptioncreate versus generatethe maven archetype plugin has two main goals: archetype:generate and archetype:create',1),(7829,'the generate goal is used when you need an interactive shell, prompting you through what you want to create',1),(7830,'you can select the camel archetypes through this interactive shell as well, so it’s a useful option for developers new to camel',1),(7831,'the create goal is useful when you know what you want to create up front and can enter it all on one command line',1),(7832,'info363managing projects with maven`-- src    |-- data                        |   |-- message1',1),(7833,'xml    |   `-- message2',1),(7834,'java                `-- resources            |-- meta-inf            |   `-- spring            |       `-- camel-context',1),(7835,'properties                              the archetype gives you a runnable camel project, with a sample route and test data to drive it',1),(7836,'txt file tells you how to run this sample project: run mvn camel:run',1),(7837,'camel will continue to run until you press ctrl-c, which causes the context to stop',1),(7838,'while running, the sample route will consume files in the src/data directory and, based on the content, will route them to one of two directories',1),(7839,'if you look in the target/messages directory, you should see something like this:target/messages |-- others |   `-- message2',1),(7840,'xml `-- uk    `-- message1',1),(7841,'xmlnow you know that camel is working on your system, so you can start editing myroutebuilder',1),(7842,'you can start by setting up ftp and web service endpoints that route to a jms queue for incoming orders:from(\"ftp://rider@localhost:21000/order',1),(7843,'password=secret&delete=true\")',1),(7844,'to(\"jms:incomingorders\"); from(\"cxf:bean:orderendpoint\")',1),(7845,'inonly(\"jms:incomingorders\")',1),(7846,'transform(constant(\"ok\"));at this point, if you try to run the application again using mvn camel:run, you’ll get the following error message:failed to resolve endpoint: ftp://rider@localhost:21000/order',1),(7847,'password=secret due to: no component found with scheme: ftpcamel couldn’t find the ftp component because it isn’t on the classpath',1),(7848,'you’d get the same error message for the cxf and jms endpoints',1),(7849,'there are, of course, other bits you have to add to your project to make this a runnable application: a test ftp server running on localhost, a cxf configuration, a jms connection factory, and so on',1),(7850,'a complete project is available in the book’s source under chapter11/order-router-full',1),(7851,'for now, we’ll focus on adding component dependencies using maven',1),(7852,'test data   spring camelcontext logging configuration    www',1),(7853,'info364 chapter 11 developing camel projects11',1),(7854,'2 camel maven dependenciestechnically, camel is just a java application',1),(7855,'to use it, you just need to add its jars to your project’s classpath',1),(7856,'but using maven to access these jars will make your life a whole lot easier',1),(7857,'camel itself was developed using maven for this very reason',1),(7858,'in the previous section, you saw that using an ftp endpoint with only the camelcore module as a dependency won’t work',1),(7859,'you need to add the camel-ftp module as a dependency to your project',1),(7860,'back in chapter 7 you saw that this was accomplished by adding the following to the dependencies section of the pom file:<dependency>  <groupid>org',1),(7861,'camel</groupid>  <artifactid>camel-ftp</artifactid>  <version>2',1),(7862,'0</version> </dependency>this dependency element will tell maven to download the camel-ftp jar from maven’s central repository at http://repo2',1),(7863,'this download url is built up from maven’s central repository url (http://repo2',1),(7864,'org/maven2) and maven coordinates (groupid, artifactid, and so on) specified in the dependency element',1),(7865,'after the download is complete, maven will add the jar to the project’s classpath',1),(7866,'one detail that may not be obvious at first is that this dependency also has transitive dependencies',1),(7867,'what are transitive dependencies',1),(7868,'well, in this case you have a project called order-router and you’ve added a dependency on camel-ftp',1),(7869,'the camel-ftp module also has a dependency on commons-net, among others',1),(7870,'so you can say that commons-net is a transitive dependency of order-router',1),(7871,'transitive dependencies are dependencies that a dependency has—the dependencies of the camel-ftp module, in this case',1),(7872,'when you add camel-ftp as a dependency, maven will look up camel-ftp’s pom file from the central maven repository and look at the dependencies it has',1),(7873,'maven will then download and add those dependencies to this project’s classpath',1),(7874,'the camel-ftp module adds a whopping 24 transitive dependencies to our project',1),(7875,'luckily only 5 of them are needed at runtime; the other 19 are used during testing',1),(7876,'the 5 transitive runtime dependencies can be viewed as a tree, as shown in figure 11',1),(7877,'0commons-management1',1),(7878,'0commons-logging-api1',1),(7879,'1jsch0',1),(7880,'43commons-net2',1),(7881,'2 transitive runtime dependencies of the camel-ftp module',1),(7882,'when you add a dependency on camel-ftp to your project, you’ll also get its transitive dependencies added to your classpath',1),(7883,'in this case, commons-net, camel-core, commons-logging-api, and jsch are added',1),(7884,'additionally, camel-core has a dependency on commons-management, so that’s added to the classpath as well',1),(7885,'info365managing projects with mavenyou’re already depending on camel-core in the order-router project, so only two dependencies—commons-net and jsch—are brought in by camel-ftp',1),(7886,'this is a view of only a small number of dependencies, but you can recognize that the dependency tree can get quite complex',1),(7887,'fortunately, maven finds these dependencies for you and resolves any duplicate dependencies',1),(7888,'the bottom line is that when you’re using maven, you don’t need to worry much about your project’s dependencies',1),(7889,'if you want to know what your project’s dependencies are (including transitive ones), maven offers the dependency:tree command',1),(7890,'to see the dependencies in your project, run the following command:mvn dependency:treeafter a few seconds of work, maven will print out a listing like this:+- org',1),(7891,'0:compile |  +- commons-logging:commons-logging-api:jar:1',1),(7892,'1:compile |  +- org',1),(7893,'fusesource',1),(7894,'commonman:commons-management:jar:1',1),(7895,'0:compile |  \\- com',1),(7896,'sun:tools:jar:1',1),(7897,'0:system +- org',1),(7898,'camel:camel-spring:jar:2',1),(7899,'0:compile |  +- org',1),(7900,'springframework:spring-context:jar:3',1),(7901,'release:compile |  |  +- org',1),(7902,'springframework:spring-beans:jar:3',1),(7903,'release:compile |  |  +- org',1),(7904,'springframework:spring-core:jar:3',1),(7905,'release:compile |  |  |  \\- commons-logging:commons-logging:jar:1',1),(7906,'1:compile |  |  +- org',1),(7907,'springframework:spring-expression:jar:3',1),(7908,'release:compile |  |  \\- org',1),(7909,'springframework:spring-asm:jar:3',1),(7910,'release:compile |  +- org',1),(7911,'springframework:spring-aop:jar:3',1),(7912,'release:compile |  |  \\- aopalliance:aopalliance:jar:1',1),(7913,'0:compile |  \\- org',1),(7914,'springframework:spring-tx:jar:3',1),(7915,'release:compile +- org',1),(7916,'0:compile |  +- com',1),(7917,'jcraft:jsch:jar:0',1),(7918,'43:compile |  \\- commons-net:commons-net:jar:2',1),(7919,'0:compile \\- log4j:log4j:jar:1',1),(7920,'16:compilehere, you can see that maven is adding 18 jars to your project’s compile-time classpath, even though you only added camel-core, camel-spring, camel-ftp, and log4j',1),(7921,'some dependencies are coming from several levels deep in the dependency tree',1),(7922,'surviving without mavenas you can imagine, adding all these dependencies to your project without the help of maven would be a bit tedious',1),(7923,'if you absolutely must use an alternative build system, you can still use maven to get the required dependencies for you by following these steps:1 download the pom file of the artifact you want',1),(7924,'for camel-ftp, this would be http://repo2',1),(7925,'pom dependency:copy-dependencies3 the dependencies for camel-ftp will be located in the target/dependency directory',1),(7926,'you can now use these in whatever build system you’re using',1),(7927,'info366 chapter 11 developing camel projectsyou now know all you need to develop camel projects using maven',1),(7928,'to make you an even more productive camel developer, let’s now look at how you can develop camel applications inside an ide, like eclipse',1),(7929,'2 using camel in eclipsewe haven’t mentioned ides much so far, mostly because you don’t need an ide to use camel',1),(7930,'certainly, though, you can’t match the power and ease of use an ide gives you',1),(7931,'from a camel point of view, having the java or spring dsls autocomplete for you makes route development a whole lot easier',1),(7932,'the common java debugging facilities and other tools will further improve your experience',1),(7933,'because maven is used as the primary build tool for camel projects, we’ll show you how to use maven tools to load up your camel project in eclipse',1),(7934,'in this section, we’ll demonstrate two ways of getting camel projects into eclipse: by using the maven eclipse plugin and by using the m2eclipse plugin for eclipse',1),(7935,'1 using the maven eclipse pluginthe maven eclipse plugin can take any maven-based project and generate an eclipse project',1),(7936,'it allows you to get a camel project into eclipse as a plain java project',1),(7937,'it offers a quick way to start camel development, but you don’t get any frills beyond what a regular java project would give you',1),(7938,'you can run this plugin on a project by executing the following command in the project’s root directory:mvn eclipse:eclipseafter this command completes, an eclipse project will be available, having all the dependencies you listed in your pom as entri...',1),(7939,'if you run this command on the order-router project you created in the previous section, a directory listing will show that you now have three extra files and an additional directory:order-router/ |--',1),(7940,'classpath |--',1),(7941,'settings |   `-- org',1),(7942,'eclipse',1),(7943,'prefs |-- readme',1),(7944,'xml |-- src(continued)if you absolutely can’t use maven but would still like to use maven repos, apache ivy (http://ant',1),(7945,'org/ivy) is a great dependency management framework for apache ant that can download from maven repos',1),(7946,'other than that, you will have to download the jars yourself from the maven central repo',1),(7947,'info367using camel in eclipsethese are files that eclipse interprets as a java project',1),(7948,'the next step after this is to import the project into eclipse',1),(7949,'this is an easy task in eclipse:1 select file > import > general > existing projects into workspace',1),(7950,'2 in the wizard, select the directory where the project is located, and then select the project name (chapter11-order-router, in this case) from the list',1),(7951,'the wizard dialog box should look something like what’s shown in figure 11',1),(7952,'3 click finish, and your project will be imported into your eclipse workspace',1),(7953,'if you take a look at the package explorer view now, you should see the chapter11order-router project listed',1),(7954,'4 shows an expanded view of what is inside the project',1),(7955,'it looks mostly like what you saw from the previous directory listing, but now it includes a list of project dependencies',1),(7956,'3 final screen of wizard to import the chapter11-order-router project into eclipse    www',1),(7957,'info368 chapter 11 developing camel projectslisted to the right of each project dependency in figure 11',1),(7958,'4 are details of where the artifact exists on your local disk',1),(7959,'this information contains a variable named m2_repo, which points to your local maven repository',1),(7960,'this is the area where maven caches downloaded dependencies so you don’t download these things for every build',1),(7961,'this variable needs to be defined for eclipse to access your project’s dependencies',1),(7962,'to specify this, follow these steps:1 open up the preferences dialog box by selecting window > preferences',1),(7963,'2 go to java > build path > classpath variables',1),(7964,'3 in the classpath variables pane, you need to add a variable named m2_repo with a path pointing to the directory of your local maven repo (recall that this is maven’s local cache of downloaded artifacts)',1),(7965,'for example, this could be something like /home/janstey/',1),(7966,'m2/repository on linux, c:\\ documents and settings\\janstey\\',1),(7967,'m2\\repository on windows xp, or c:\\users\\janstey\\',1),(7968,'m2\\repository on windows vista/7',1),(7969,'from this point on, you can develop as if this project were a regular java project in eclipse',1),(7970,'but keep in mind when adding new dependencies to your maven pom that they won’t be automatically added to the eclipse project',1),(7971,'the mvn eclipse:eclipse command will have to be run again and the project will have to be refreshed in the package explorer view',1),(7972,'2 using the m2eclipse pluginwhen using the maven eclipse plugin, you’ll find yourself often darting back and forth between eclipse and the command line',1),(7973,'eclipse will be where you develop, and the command line will be where you build',1),(7974,'if you decide instead to use the m2eclipse plugin to develop your camel project, you’ll experience a much nicer integration with maven and never have to leave the ide',1),(7975,'info369using camel in eclipseto install m2eclipse into your eclipse runtime, follow the latest instructions at http: //m2eclipse',1),(7976,'during the writing of this book, we used m2eclipse version 0',1),(7977,'one thing that some developers will like right away is that you don’t have to leave the ide to run maven command-line tools during development',1),(7978,'you can even access the camel archetypes right from eclipse',1),(7979,'to demonstrate this feature, let’s recreate the chapter11-order-router example we looked at previously',1),(7980,'click file > new > maven project to start up the new maven project wizard',1),(7981,'click next on the first screen, and you’ll be presented with a list of available archetypes, as shown in figure 11',1),(7982,'this list includes the camel archetypes',1),(7983,'when to use m2eclipsethe m2eclipse plugin does add a bit of complexity to development, so in some cases the simpler maven eclipse plugin is a better choice',1),(7984,'for instance, if you already have a maven project created, and you know you probably won’t be adding new dependencies, it’s much quicker to use the maven eclipse plugin',1),(7985,'it will also require a lot less system resources to develop the project in eclipse',1),(7986,'m2eclipse has had performance issues in the past when you have many projects open at the same time',1),(7987,'the recommendation is to turn off automatic building for all projects',1),(7988,'this way you can control when builds get kicked off',1),(7989,'new versions of the plugin are improving performance all the time, so this may not be an issue in future builds',1),(7990,'5 the new maven project wizard allows you to generate a new camel project right in eclipse',1),(7991,'info370 chapter 11 developing camel projectsusing camel archetypes in this way is equivalent to the technique you used back in section 11',1),(7992,'the m2eclipse plugin will also allow you to add maven dependencies without having to regenerate your project every time, which can be forgotten if you use the maven eclipse plugin',1),(7993,'note if you can only see version 2',1),(7994,'0 of the camel archetypes, you\'ll need to perform a few additional steps',1),(7995,'at the time of writing, an error at maven\'s central repository was preventing newer camel archetypes from being shown in m2eclipse',1),(7996,'to get around this you\'ll need to do the following:1 click the menu item window > preferences and drill down to maven > archetypes',1),(7997,'com/svn/trunk/misc/archetype-catalog',1),(7998,'xml as the catalog file',1),(7999,'click ok and close out the preferences dialog box',1),(8000,'3 when creating a new project as in figure 11',1),(8001,'5, make sure to select the catalog you just added',1),(8002,'to run the order-router project with m2eclipse, right-click on the project in the package explorer and click run as > maven build',1),(8003,'this will bring up an edit configuration dialog box where you can specify the maven goals to use as well as any parameters',1),(8004,'for the order-router project, use the camel:run goal, as shown in figure 11',1),(8005,'6 right-clicking on the order-router project in the package explorer and clicking run as > maven build will bring up the edit configuration dialog box shown here',1),(8006,'the camel:run maven goal has been entered',1),(8007,'info371developing custom componentsclicking run in this dialog box will execute the mvn camel:run command in eclipse, with console output showing in the eclipse console view',1),(8008,'now you can say that you know how to create camel projects from the command line and from eclipse',1),(8009,'you’ve also seen the two ways you can develop camel applications in eclipse, and the pitfalls of each',1),(8010,'these projects only leverage what is built into camel itself',1),(8011,'we’ll now move on to the more advanced topic of extending camel itself, by developing custom components',1),(8012,'3 developing custom componentsfor most integration scenarios, there’s a camel component available to help',1),(8013,'sometimes, though, there’s no camel component available, and you need to bridge camel to another transport, api, data format, and so on',1),(8014,'you can do this by creating your own custom component',1),(8015,'creating a camel component is relatively easy, which may be one of the reasons that custom camel components frequently show up on other community sites, in addition to the official camel distribution',1),(8016,'in this section, we’ll look at how you can create your own custom component for camel',1),(8017,'1 setting up a new camel componentjust like a regular camel project, you can start creating a new component by using a maven archetype to generate a skeleton project',1),(8018,'component as the package name and custom as the artifactid, run the following maven command:mvn archetype:create \\  -darchetypegroupid=org',1),(8019,'archetypes \\   -darchetypeartifactid=camel-archetype-component \\  -darchetypeversion=2',1),(8020,'0 \\  -dgroupid=camelinaction',1),(8021,'component \\  -dartifactid=customthis will generate a project structure like that shown here',1),(8022,'custom |-- pom',1),(8023,'txt `-- src |-- main    |   |-- java    |   |   `-- camelinaction    |   |       `-- component    |   |           |-- helloworldcomponent',1),(8024,'java    |   |           |-- helloworldconsumer',1),(8025,'java     |   `-- resources    |       |-- log4j',1),(8026,'propertieslisting 11',1),(8027,'info372 chapter 11 developing camel projects    |       `-- meta-inf    |           `-- services    |               `-- org    |                   `-- apache    |                       `-- camel    |                           `-- component    |      ...',1),(8028,'java       this is a fully functional “hello world” demo component containing a simple consumer that generates dummy messages at regular intervals, and a producer that prints a message to the console',1),(8029,'you can run the test case included with this sample component by running the following maven command:mvn testone of the first things to do when developing a custom component is to decide what endpoint name to use',1),(8030,'this name is what will be used to reference the custom component in an endpoint uri',1),(8031,'you need to make sure this name doesn’t conflict with a component that already exists by checking the online component list (http:// camel',1),(8032,'for instance, to use mycomponent as the endpoint name, you need to rename the helloworld file c to mycomponent',1),(8033,'for an explanation on how this file is used to load camel components, see section 7',1),(8034,'you should also rename the skeleton implementation classes b to better match your new component name',1),(8035,'the src directory now looks like this:src `-- main    |-- java    |   `-- camelinaction    |       `-- component    |           |-- mycomponent',1),(8036,'java    |           |-- myconsumer',1),(8037,'java    |   `-- resources    |       |-- log4j',1),(8038,'properties    |       `-- meta-inf    |           `-- services    |               `-- org    |                   `-- apache    |                       `-- camel    |                           `-- component    |                               `-- mycom...',1),(8039,'javafile that maps uri scheme to component classctest case for component    www',1),(8040,'info373developing custom componentsthis project, with the appropriate renaming, is available in the chapter11/custom directory of the book’s source',1),(8041,'when you change the component class name, to mycomponent, for example, you also need to modify the mycomponent file to point to this new class',1),(8042,'it should now contain a line like this:class=camelinaction',1),(8043,'mycomponentyour component can now be used in a camel endpoint uri',1),(8044,'but you shouldn’t stop here',1),(8045,'to understand how these classes make up a functioning component, you need to understand the implementation details of each',1),(8046,'2 diving into the implementationthe four classes that make up a component in camel have been mentioned several times before',1),(8047,'to recap, it all starts with the component class, which then creates an endpoint',1),(8048,'an endpoint, in turn, can create producers and consumers',1),(8049,'this is illustrated in figure 11',1),(8050,'we’ll first look into the component and endpoint implementations of the custom mycomponent component',1),(8051,'component and endpoint classesthe first entry point into a camel component is the class implementing the component interface',1),(8052,'a component’s main job is to be a factory of new endpoints',1),(8053,'it does a bit more than this under the hood, but typically you don’t have to worry about these details because they’re contained in the defaultcomponent class',1),(8054,'the component class generated by the camel-archetype-component archetype extends this default class and forms a pretty simple and typical component class structure, as shown here:public class mycomponent extends defaultcomponent {             protect...',1),(8055,'this method takes in the properties set in the endpoint uri string, and for each will invoke a setter method on the endpoint through reflection',1),(8056,'for instance, say you used the following endpoint uri:mycomponent:endpointname',1),(8057,'prop1=value1&prop2=value2endpointcomponentconsumer producercreatescreates createsfigure 11',1),(8058,'7 a componentcreates an endpoint, which then creates producers and consumers',1),(8059,'info374 chapter 11 developing camel projectsthe setproperties method, in this case, would try to invoke setprop1(\"value1\") and setprop2(\"value2\") on the endpoint',1),(8060,'camel will take care of converting those values to the appropriate type',1),(8061,'the endpoint, itself, is also a relatively simple class, as shown here',1),(8062,'public class myendpoint extends defaultendpoint {                      public myendpoint() {    }    public myendpoint(string uri, mycomponent component) {        super(uri, component);    }    public myendpoint(string endpointuri) {        super(end...',1),(8063,'in this case, you’re extending the defaultendpoint class',1),(8064,'it’s very common when creating a new camel component to have the component, endpoint, consumer, and producer all derive from default implementations in camel-core',1),(8065,'this isn’t necessary, but it makes new component development much easier, and you always benefit from the latest improvements to the default implementations without having to code them yourself',1),(8066,'as we mentioned in chapter 7, the endpoint class acts as a factory for both consumers and producers',1),(8067,'in this example, you’re creating both producers c and consumers d, which means that this endpoint can be used in a to or from java dsl method',1),(8068,'sometimes you may need to create a component that only has a producer or consumer, not both',1),(8069,'in that case, it’s recommended that you throw an exception, so users know that it isn’t supported:public producer createproducer() throws exception {    throw new unsupportedoperationexception(      \"you cannot send messages to this endpoint:\" + gete...',1),(8070,'3 custom camel endpoint—myendpointextends from default endpoint classbcreates new producerccreates new eventdriven consumerd    www',1),(8071,'info375developing custom componentsthe real bulk of most components is in the producer and consumer',1),(8072,'the component and endpoint classes are mostly designed to fit the component into camel',1),(8073,'in the producers and consumers, which we’ll look at next, you have to interface with the remote apis or marshal data to a particular transport',1),(8074,'producers and consumersthe producer and consumer are where you get to implement how messages will get on or off a particular transport—in effect, bridging camel to something else',1),(8075,'this is illustrated in figure 11',1),(8076,'in your skeleton component project that was generated from an archetype, a producer and consumer are implemented and ready to go',1),(8077,'these were instantiated by the myendpoint class in listing 11',1),(8078,'the producer, named myproducer, is shown in this listing',1),(8079,'public class myproducer extends defaultproducer {            private static final transient log log =',1),(8080,'class);    private myendpoint endpoint;    public myproducer(myendpoint endpoint) {        super(endpoint);        this',1),(8081,'endpoint = endpoint;    }    public void process(exchange exchange)',1),(8082,'throws exception {                                     system',1),(8083,'getbody());         } }like the component and endpoint classes, the producer also extends from a default implementation class from camel-core called defaultproducer b',1),(8084,'the producer interface extends from the processor interface, so you use a process method c',1),(8085,'as you can probably guess, a producer is called in the same way a processor is, so the entry point into the producer is the process method',1),(8086,'listing 11',1),(8087,'4 custom camel producer—myproducer',1),(8088,'routeconsumer producerftp serverjms queueprocessor processorfigure 11',1),(8089,'8 a simplified view of a route where the consumer and producer handle interfacing with external systems',1),(8090,'consumers take messages from an external system into camel, and producers send messages to external systems',1),(8091,'extends from default producer classbc serves as entry point to producerprints message bodyd    www',1),(8092,'info376 chapter 11 developing camel projectsthe sample component that was created automatically has a very basic producer—it just prints the body of the incoming message to the screen d',1),(8093,'if you were sending to an external system instead of the screen, you’d have to handle a lot more here, such as connecting to a remote system and marshaling data',1),(8094,'in the case of data marshaling, it’s often a good idea to implement this using a custom typeconverter, as described in chapter 3, which makes the converters available to other parts of your camel application',1),(8095,'you can see how messages could be sent out of a route, but how do they get into a route',1),(8096,'consumers, like the myconsumer class generated in your custom component project, get the messages into a route',1),(8097,'the myconsumer class is shown in listing 11',1),(8098,'public class myconsumer extends scheduledpollconsumer {       private final myendpoint endpoint;    public myconsumer(myendpoint endpoint, processor processor) {        super(endpoint, processor);        this',1),(8099,'endpoint = endpoint;    }    @override    protected void poll() throws exception {                   exchange exchange = endpoint',1),(8100,'the time is \" + now);        try {            getprocessor()',1),(8101,'process(exchange);                  } finally {            if (exchange',1),(8102,'handleexception(                    \"error processing exchange\", exchange,                     exchange',1),(8103,'getexception());            }        }            } }the consumer interface, itself, doesn’t impose many restrictions or give any guidelines as to how a consumer should behave, but the defaultconsumer class does, so it’s helpful to extend from this c...',1),(8104,'in listing 11',1),(8105,'5, you extend from a subclass of defaultconsumer, the scheduledpollconsumer b',1),(8106,'this consumer has a timer thread that will invoke the poll method every 500 milliseconds c',1),(8107,'tip see the discussion of the timer and quartz components in chapter 7 for more information on creating routes that need to operate on a schedule',1),(8108,'listing 11',1),(8109,'5 custom camel consumer—myconsumerextends from built-in consumerbis called every 500 mscsends to next processor in route    www',1),(8110,'info377developing interceptorstypically, a consumer will either poll a resource for a message or set up an eventdriven structure for accepting messages from remote sources',1),(8111,'in this example, you have no remote resource, so you can create an empty exchange and populate it with a “hello world” message',1),(8112,'a real consumer still would need to do this',1),(8113,'a common pattern for consumers is something like this:exchange exchange = endpoint',1),(8114,'createexchange(); // populate exchange with data getprocessor()',1),(8115,'process(exchange);here you create an empty exchange, populate it with data, and send it to the next processor in the route',1),(8116,'at this point, you should have a good understanding of what is required to create a new camel component',1),(8117,'you may even have a few ideas about what you’d like to bridge camel to next',1),(8118,'another useful way of extending camel is by writing custom interceptors',1),(8119,'let’s look at this next',1),(8120,'4 developing interceptorsinterceptors in camel are used to perform some action on a message as it goes in and out of a processor',1),(8121,'features like the tracer discussed in chapter 12 use a custom interceptor to trace each message going in and out of processors',1),(8122,'we also talked about interceptors back in chapter 6, where you used them to simulate errors occurring on a particular endpoint',1),(8123,'convenience methods built into camel’s dsl were used in that case',1),(8124,'in this section, we’ll look at how you can create your own custom interceptor',1),(8125,'1 creating an interceptstrategyto create a new interceptor, you need to use the interceptstrategy interface',1),(8126,'by implementing a custom interceptstrategy, you gain complete control over what the interceptor does',1),(8127,'the interceptstrategy interface only has a single method:processor wrapprocessorininterceptors(    camelcontext context,     processordefinition<',1),(8128,'> definition,     processor target,     processor nexttarget) throws exception;this method essentially wraps each processor within a route with another processor',1),(8129,'this wrapper processor will contain the logic you want for your interceptor',1),(8130,'in camel, interceptstrategy classes are used to implement a delay after each node in a route, to trace messages as they flow through a route, and to record performance metrics',1),(8131,'9 shows a conceptual view of how an interceptstrategy modifies a route',1),(8132,'every processor in the route shown in figure 11',1),(8133,'9 is wrapped by an interceptor processor',1),(8134,'this work of modifying the route is done automatically when you add the    www',1),(8135,'info378 chapter 11 developing camel projectsinterceptstrategy to the camelcontext',1),(8136,'you can add an interceptstrategy directly to the camelcontext with a single method call:context',1),(8137,'addinterceptstrategy(new myinterceptor());adding an interceptstrategy in spring is also easy',1),(8138,'you just add one as a bean, and camel will automatically find it on startup and add it to the camelcontext',1),(8139,'this is all you would need to write:<bean id=\"myinterceptor\" class=\"camelinaction',1),(8140,'myinterceptor\"/>what happens if you define more than one strategy',1),(8141,'10 shows that in this case camel will stack the interceptors used for each real processor',1),(8142,'you may be wondering what an actual interceptor looks like',1),(8143,'in the simplest case, you could just log an entry message before the processor and an exit message after the processor has completed',1),(8144,'this is demonstrated in listing 11',1),(8145,'consumerproducer processorinterceptorprocessorconsumer producer processorinterceptorprocessorapply interceptstrategyfigure 11',1),(8146,'9 applying an interceptstrategy to a route essentially wraps each processor with an interceptor processor',1),(8147,'consumerproducer processorinterceptorprocessor 1interceptorprocessor 1interceptorprocessor 2interceptorprocessor 2figure 11',1),(8148,'10 interceptors are stackable, meaning the more interceptstrategy classes you add to the camelcontext, the more interceptor processors will be added before each real processor is executed',1),(8149,'info379developing interceptorspublic class myinterceptor implements interceptstrategy {    private static final transient log log         = logfactory',1),(8150,'class);    public processor wrapprocessorininterceptors(        camelcontext context,                                                 processordefinition<',1),(8151,'> definition,                    final processor target,                   processor nexttarget)                                                 throws exception {        return new delegateasyncprocessor(new processor() {            public void proc...',1),(8152,'info(\"entering the processor',1),(8153,'process(exchange);                                 log',1),(8154,'info(\"exiting the processor',1),(8155,'\");            }        });    }}the wrapprocessorininterceptors method gives the interceptor developer plenty of information to help create a custom interceptor',1),(8156,'first off, you have access to the entire camelcontext, which lets you access many different services, like the bean registry or the many type converters',1),(8157,'next, and most importantly, you have access to the target processor c that you need to call, and its dsl object equivalent b',1),(8158,'why was the dsl object provided',1),(8159,'the dsl object provides richer description details than the runtime processor, so if your interceptor is, for example, graphically reporting the structure of a camel route as it’s being used, more detailed descriptions of each node may be helpful',1),(8160,'it isn’t enforced by the interface, but interceptors are supposed to call the target processor d when they have done their work',1),(8161,'after the target processor is finished, the interceptor can do some more work before returning to the next node in the route',1),(8162,'in this way, an interceptor allows you to do operations before and after each processor in a route',1),(8163,'sometimes, you don’t want to attach an interceptor to a particular processor',1),(8164,'in this case, instead of always returning a wrapped processor, you could return the target processor',1),(8165,'this would leave the target processor out of the interceptor scheme',1),(8166,'for example, you could ignore wiretap nodes from the interceptor scheme by using information from the processor’s model class:if (\"wiretap\"',1),(8167,'equals(definition',1),(8168,'getshortname())) {    return target; } else {    return new processor() {',1),(8169,'}; }     listing 11',1),(8170,'6 a custom interceptorthe target processor modelbthe target processorccall into the target processord    www',1),(8171,'info380 chapter 11 developing camel projectsthis checks the name of the processor through its dsl object, and if it’s a wire tap, it doesn’t wrap it with an interceptor',1),(8172,'you’ve now seen how to develop custom camel components and interceptors',1),(8173,'let’s step outside the java world and see how camel can be used from other languages',1),(8174,'5 using alternative languagesthroughout this book, we’ve focused on camel’s two main methods of specifying routing rules: the java dsl and spring xml configuration',1),(8175,'we did this to focus on the concepts themselves, rather than how they end up being implemented, but camel does provide advanced users with a number of options for creating routes in other jvm languages',1),(8176,'for instance, you can create routes in the groovy, scala, and ruby languages',1),(8177,'the scala dsl is probably the most mature of the three, having a custom dsl created to take advantage of language features in scala',1),(8178,'the groovy dsl is well-used too',1),(8179,'in fact, another open source project called the open ehealth integration platform (ipf) is a groovy-based project built on top of apache camel',1),(8180,'in this section, we’ll take a look at how you can create camel applications using scala',1),(8181,'we’ll first look at some of the constructs you can use to create a route in scala, and then we’ll see how to add these routes to a camelcontext',1),(8182,'1 the scala dslas you may have assumed, when using the scala dsl you’re coding in a real programming language—scala',1),(8183,'in this way it’s more comparable to the java dsl than spring xml configuration',1),(8184,'recall the following route from section 11',1),(8185,'1:from(\"ftp://rider@localhost:21000/order',1),(8186,'password=secret\")',1),(8187,'to(\"jms:incomingorders\");because this is the java dsl, it also must be enclosed within a routebuilder class as follows:class myroutebuilder extends routebuilder {    public void configure() throws exception {        from(\"ftp://rider@localhost:21000/...',1),(8188,'password=secret\")',1),(8189,'to(\"jms:incomingorders\");    } }this should look pretty familiar to you now—it’s about the simplest camel route you can get: consuming messages from one endpoint and producing them into another endpoint',1),(8190,'now let’s see what the scala version of this route looks like:class myroutebuilder extends routebuilder {   \"ftp://rider@localhost:21000/order',1),(8191,'password=secret\"',1),(8192,'to \"jms:incomingorders\" }    www',1),(8193,'info381using alternative languagesit starts off mostly the same as the java dsl version, with a myroutebuilder class extending from routebuilder',1),(8194,'in this case, routebuilder is in the org',1),(8195,'you may notice that the scala dsl route is a lot less verbose',1),(8196,'one of the aims of the scala dsl was to eliminate text that didn’t add anything to the function of a route',1),(8197,'in the java dsl, there’s a lot of text used to conform to the java language',1),(8198,'scala gives you a lot more freedom in creating your own operators and relaxes requirements for parentheses, dots, and semicolons',1),(8199,'in the previous one-line route, you have very few extraneous characters: there are two endpoint uri strings and a to operator',1),(8200,'the from method used in other camel dsls isn’t needed here; simply specifying an endpoint uri is enough to start a route',1),(8201,'the to operator can also be replaced with --> which may be more aesthetically pleasing to you, but it has exactly the same function as to',1),(8202,'there’s also no need to specify a configure method as there is in the java dsl',1),(8203,'route statements are entered directly into the class body',1),(8204,'note that in order to break this simple route into several lines of code, you would need to introduce a code block, as follows:class myroutebuilder extends routebuilder {   \"ftp://rider@localhost:21000/order',1),(8205,'password=secret\" ==> {       to(\"jms:incomingorders\")   } }the ==> operator is used to start the code block, and the braces indicate the start and end of the block',1),(8206,'these code blocks can be nested arbitrarily',1),(8207,'in this way, camel will know how to end a route’s construction and add it into the camelcontext',1),(8208,'in the scala dsl, a route ends after either a code line ends in the simple case, or when the code block ends if you’re using code blocks',1),(8209,'learn more about scalathis isn’t a book about scala, so many assumptions are made in this section about your knowledge of scala',1),(8210,'because scala is quite different from java, it’s recommended that you learn about the language fundamentals before trying to use the scala dsl in camel',1),(8211,'otherwise, you may get frustrated by language features that are very different from java',1),(8212,'the main online resource for scala is http://www',1),(8213,'org, and if you want indepth information about scala, we recommend the book coauthored by the language’s creator, programming in scala by martin odersky, lex spoon, and bill venners',1),(8214,'another must-have for scala dsl development is a plugin for your ide so you can avail yourself of code completion',1),(8215,'the scala ide for eclipse is available at http:// www',1),(8216,'info382 chapter 11 developing camel projects11',1),(8217,'2 adding scala routes to the camelcontextscala routes are added to the camelcontext in much the same way as java dsl routes are',1),(8218,'we discussed the different approaches to this in chapter 2',1),(8219,'the reason you can use the same approach is that scala ultimately compiles down to java bytecode, so when the camelcontext is searching for a routesbuilder in a package you specified, it doesn’t care whether it originated from java or scala',1),(8220,'for example, to load a scala-based route into a spring camelcontext, you would just define the camelcontext like this:<camelcontext xmlns=\"http://camel',1),(8221,'org/schema/spring\">  <package>camelinaction</package> </camelcontext>this will pick up all scala routes in the camelinaction package—exactly the same as for java routes',1),(8222,'an example of this is provided in the chapter11/scala-router directory of the book’s source',1),(8223,'to run this example, execute the following maven command:mvn camel:runthere may be times when you want to mix java and scala within a single project',1),(8224,'for instance, you may already have a working java-based system using camel, and you want to add a new route using the scala dsl',1),(8225,'what do you do in this case',1),(8226,'3 mixing java and scalaas we’ve said before, both java and scala compile down to java bytecode, so it should be easy to mix the two',1),(8227,'it mostly involves setting up your maven project to compile both types of sources and put the resultant bytecode class files in the same location',1),(8228,'suppose you have a project that has java and scala source files as follows:scala-router-javacontext |-- pom',1),(8229,'xml `-- src    `-- main        |-- java        |   `-- camelinaction        |       `-- main',1),(8230,'java        `-- scala            `-- camelinaction                `-- myroutebuilder',1),(8231,'scalathe main class creates a new camelcontext and adds the scala routebuilder myroutebuilder to the context as follows:the scala dsl and eipsthe scala dsl doesn’t support all the eips that are available in the java and spring dsls, but it does suppo...',1),(8232,'eips that don’t have a scala dsl equivalent can be accessed from the java dsl',1),(8233,'you can find examples of what the eips look like in scala at the apache camel website: http://camel',1),(8234,'org/scala-dsl-eip',1),(8235,'info383using alternative languagespublic class main {    public static void main(string args[]) throws exception {        camelcontext context = new defaultcamelcontext();        context',1),(8236,'addroutes(new myroutebuilder());',1),(8237,'both main and myroutebuilder are in the same package, so this should all work nicely, except that it doesn’t',1),(8238,'if you try to run the main class now, you’ll get a compilation error saying myroutebuilder can’t be found',1),(8239,'it can’t be found because it hasn’t been compiled yet',1),(8240,'by default, maven will compile all java sources in src/main/java, but it has no such settings in place for scala',1),(8241,'you can get around this by configuring the maven-scalaplugin as shown here',1),(8242,'scala-tools</groupid>  <artifactid>maven-scala-plugin</artifactid>  <version>2',1),(8243,'1</version>  <executions>    <execution>                                     <id>scala-compile-first</id>            <phase>process-resources</phase>        <goals>        <goal>add-source</goal>        <goal>compile</goal>      </goals>    </executi...',1),(8244,'plugins</groupid>  <artifactid>maven-compiler-plugin</artifactid>  <executions>    <execution>                                <phase>compile</phase>      <goals>        <goal>compile</goal>      </goals>    </execution>  </executions> </plugin>you ca...',1),(8245,'the process-resources phase happens just before the compile phase c, which is where the java source is compiled',1),(8246,'you didn’t specify where your scala source was, so the maven-scala-plugin used the default location of src/main/scala',1),(8247,'now all class files are saved into the target/classes folder and so will be on the same classpath when you run your application',1),(8248,'listing 11',1),(8249,'7 configuring compilation of both java and scala sourcescompiles scala sourcebcompiles java sourcec    www',1),(8250,'info384 chapter 11 developing camel projects the source for this example is in chapter11/scala-router-javacontext of the book’s source',1),(8251,'to run the example, use the following maven command:mvn compile exec:javayou should now know some of the concepts needed to create routes in the scala dsl',1),(8252,'the next step would be to try out your own scala route by either copying the example from this book, or by using the camel-archetype-scala archetype to create your own scala dsl project',1),(8253,'this archetype was mentioned in table 11',1),(8254,'6 summary and best practicesknowing how to create camel projects is very important, and you may have wondered why we chose to discuss this so late in the book',1),(8255,'we felt it was best to focus on the core concepts first and worry about project setup details later',1),(8256,'also, you should now have a better idea of what cool camel applications you can create, having read about the features first',1),(8257,'at this point, though, you should be well-equipped to start your own camel application and make it do useful work',1),(8258,'before we move on, there are a few key ideas that you should take away from this chapter:■ the easiest way to create camel applications is with maven archetypes',1),(8259,'nothing is worse than having to type out a bunch of boilerplate code for new projects',1),(8260,'the maven archetypes that are provided by camel will get you started much faster',1),(8261,'■ the easiest way to manage camel library dependencies is with maven',1),(8262,'camel is just a java framework, so you can use whatever build system you like to develop your camel projects',1),(8263,'using maven will eliminate many of the hassles of tracking down jar files from remote repos, letting you focus more on your business code than the library dependencies',1),(8264,'■ it’s easy to load up a maven-based camel project in eclipse',1),(8265,'whether you use the maven-eclipse-plugin or m2eclipse, importing camel projects is easy',1),(8266,'■ if you find no component in camel for your use case, create your own',1),(8267,'camel allows you to write and load up your own custom components easily',1),(8268,'there’s even a maven archetype for starting a custom component project',1),(8269,'■ use interceptors to inject processing around nodes in a route',1),(8270,'it’s true, camel interceptors are an advanced topic',1),(8271,'they give you the additional power to control or monitor what’s happening inside a route',1),(8272,'■ you don’t have to write routes in java or spring if you don’t want to',1),(8273,'camel also provides dsls in scala and groovy',1),(8274,'next on the agenda is how to monitor and manage your camel application',1),(8275,'info385management and monitoringapplications in production are often critical for businesses',1),(8276,'that’s especially true for applications that sit at an intermediate tier and integrate all the business applications and partners—camel is often in this role',1),(8277,'to help ensure high availability, your organization must monitor its production applications',1),(8278,'by doing so, you can gain important insight into the applications and foresee trends that otherwise could cause business processes to suffer',1),(8279,'in addition, monitoring also helps with related issues, such as operations reporting, service level agreement (sla) enforcement, and audit trails',1),(8280,'it’s also vital for the operations staff to be able to fully manage the applications',1),(8281,'for example, if an incident occurs, staff may need to stop parts of the applicationthis chapter covers■ monitoring camel instances■ tracking application activities■ using notifications■ managing camel applications■ managing custom components    www',1),(8282,'info386 chapter 12 management and monitoringfrom running while the incident investigations occur',1),(8283,'you’ll also need management capabilities to carry out scheduled maintenance or upgrades of your applications',1),(8284,'management and monitoring are often two sides of the same coin',1),(8285,'for example, management tooling includes monitoring capabilities in a single coherent dashboard, allowing a full overview for the operations staff',1),(8286,'in this chapter, we’ll review different strategies for monitoring your camel applications',1),(8287,'we’ll first cover the most common approach, which is to check on the health of those applications',1),(8288,'then we’ll look at the options for tracking activity and managing those camel applications',1),(8289,'1 monitoring camelit’s standard practice to monitor systems with periodic health checks',1),(8290,'for people, checking one’s health involves measuring parameters at regular intervals, such as pulse, temperature, and blood pressure',1),(8291,'by checking over a period of time, you not only know the current values but also trends, such as whether the temperature is rising',1),(8292,'all together, these data give insight into the health of the person',1),(8293,'for a software system, you can gather system-level data such as cpu load, memory usage, and disk usage',1),(8294,'you can also collect application-level data, such as message load, response time, and many other parameters',1),(8295,'this data tells you about the health of the system',1),(8296,'checks on the health of camel applications can occur at three levels:■ network level—this is the most basic level, where you check that the network connectivity is working',1),(8297,'■ jvm level—at this level, you check the jvm that hosts the camel application',1),(8298,'the jvm exposes a standard set of data using the jmx technology',1),(8299,'■ application level—here you check the camel application using jmx or other techniques',1),(8300,'to perform these checks, you need different tools and technologies',1),(8301,'the simple network management protocol (snmp) enables both jvm and system-level checks',1),(8302,'java management extensions (jmx) is another technology that offers similar capabilities to snmp',1),(8303,'you might use a mix of both: snmp is older and more mature and is often used in large system-management tools such as ibm tivoli, hp openview, and nagios',1),(8304,'jmx, on the other hand, is a pure java standard and is used by fuse hq and hyperic',1),(8305,'in the following sections, we’ll go over the three levels and look at some approaches you can use for performing automatic and periodic health checks on your camel applications',1),(8306,'1 checking health at the network levelthe most basic health check you can do is to check whether a system is alive',1),(8307,'you may be familiar with the ping command, which you use to send a ping request to a remote host',1),(8308,'camel doesn’t provide a ping service out of the box, but creating such a service is easy',1),(8309,'the ping service only reveals whether camel is running or not, but that will do for a basic check',1),(8310,'info387monitoring camelsuppose you have been asked to create such a ping service for rider auto parts',1),(8311,'the service is to be integrated with the existing management tools',1),(8312,'you choose to expose the ping service over http, which is a universal protocol that the management tool easily can leverage',1),(8313,'the scenario is illustrated in figure 12',1),(8314,'implementing the service in camel is easy using the jetty component',1),(8315,'all you have to do is expose a route that returns the response, as follows:from(\"jetty:http//0',1),(8316,'transform(constant(\"pong\\n\"));when the service is running, you can invoke an http get, which should return the pong response',1),(8317,'you can try this on your own with the book’s source code',1),(8318,'in the chapter12/health directory, invoke this maven goal: mvn compile exec:java -ppingservicethen invoke the http get using either a web browser or the curl command:curl http://0',1),(8319,'0:8080/ping        pongthe ping service can be enhanced to leverage the jvm and camel apis to gather additional data about the state of the internals of your application',1),(8320,'another use for the ping service is when using a load balancer in front of multiple instances of camel applications',1),(8321,'this is often done to address high availability, as shown in figure 12',1),(8322,'the load balancer will call the ping service to assess whether the particular camel instance is ready for regular service calls',1),(8323,'ping servicecamelmonitoring tool httpfigure 12',1),(8324,'1 a monitoring tool monitors camel with a ping service by sending periodic http get requests',1),(8325,'pingserviceother servicescamelpingserviceother servicescamelload balancerhealth checkservice callsfigure 12',1),(8326,'2 the load balancer uses health checks to ensure connectivity before it lets the service calls pass through',1),(8327,'info388 chapter 12 management and monitoringnetwork-level checks offer a quick and coarse assessment of the system’s state of health',1),(8328,'let’s move on to the jvm level, where you monitor camel using jmx',1),(8329,'2 checking health at the jvm levelthe simple network management protocol (snmp) is a standard for monitoring network-attached devices',1),(8330,'it’s traditionally used to monitor the health of servers at the os level by checking parameters such as cpu load, disk space, memory usage, and network traffic, but it can also be used to check parameters at the application level, such as the jvm',1),(8331,'java has a built-in snmp agent that exposes general information, such as memory and thread usage, and that issues notifications on low memory conditions',1),(8332,'this allows you to use existing snmp-aware tooling to monitor the jvm where camel is running',1),(8333,'there is also a wide range of commercial and open source monitoring tools that use snmp',1),(8334,'some are simpler and have a shell interface, and others have a powerful gui',1),(8335,'you may work in an organization that already uses a few selected monitoring tools, so make sure these tools can be used to monitor your camel applications as well',1),(8336,'the snmp agent in the jvm is limited to only exposing data at the jvm level; it can’t be used to gather information about the java applications that are running',1),(8337,'jmx, in contrast, is capable of monitoring and managing both the jvm and the applications running on it',1),(8338,'in the next section, we’ll look at how you can use jmx to monitor camel at the jvm and application levels',1),(8339,'3 checking health at the application levelcamel provides jmx monitoring and management out of the box in the form of an agent that leverages the jmx technology',1),(8340,'this is illustrated in figure 12',1),(8341,'mbeanservercameljvmmbeanservercameljvmjconsolejmx over rmijmxagentjmxagentfigure 12',1),(8342,'3 jconsole connects remotely to an mbean server inside the jvm, which opens up a world of in-depth information and management possibilities for camel instances',1),(8343,'info389using jmx with camelthe jmx agent exposes remotely (over remote method invocation) a wealth of standard details about the jvm, and some camel information as well',1),(8344,'the former is standard in the jdk, and the latter is provided by camel',1),(8345,'the most prominent feature the camel jmx agent offers is the ability to remotely control the lifecycle of any service in camel',1),(8346,'for example, you can stop routes and later bring those routes into action again',1),(8347,'you can even shut down camel itself',1),(8348,'so how do you use jmx with camel',1),(8349,'camel comes preconfigured with jmx enabled at the developer level, by which we mean that camel allows you to connect to the jvm from the same localhost where the jvm is running',1),(8350,'if you need to manage camel from a remote host, you’ll need to explicitly enable this in camel',1),(8351,'we think this is important to cover thoroughly, so we’ve devoted the next section to this topic',1),(8352,'2 using jmx with camelto use jmx with camel, you need the following four spring jar files on the classpath: ■ spring-core',1),(8353,'jar■ spring-beans',1),(8354,'jar■ spring-context',1),(8355,'jar■ spring-aop',1),(8356,'jarthese jars are needed because camel uses spring jmx to expose its managed beans to the jmx server',1),(8357,'using spring jmx is much easier than using the low-level clumsy jmx api',1),(8358,'with spring jmx, you can add a few jmx annotations in the camel codebase to expose the information you want to manage from jmx',1),(8359,'when camel starts, it logs at info level whether jmx is enabled or not:2010-01-09 11:15:23,520 [vicemain',1),(8360,'using defaultmanagedlifecyclestrategy',1),(8361,'if those four spring jars are missing, camel will report it as follows:2010-01-09 11:44:07,960 [vicemain',1),(8362,'main()] warn  defaultcamelcontext- could not find needed classes for jmx lifecycle strategy',1),(8363,'needed class is in spring-context',1),(8364,'jar using spring 2',1),(8365,'5 or newer (spring-jmx',1),(8366,'jar using spring 2',1),(8367,'noclassdeffounderror: org/springframework/jmx/export/metadata/jmxattributesource 2010-01-09 11:44:07,960 [vicemain',1),(8368,'main()] warn  defaultcamelcontext- cannot use jmx',1),(8369,'fallback to using defaultmanagementstrategy',1),(8370,'with maven, it’s easy to ensure that the jars are included in the classpath—you just add a dependency for the camel-spring component:<dependency>    <groupid>org',1),(8371,'camel</groupid>    <artifactid>camel-spring</artifactid>    <version>2',1),(8372,'0</version> </dependency>    www',1),(8373,'info390 chapter 12 management and monitoringif you don’t want to use camel-spring, you can add the aforementioned four jar files individually',1),(8374,'now let’s look at how to use a simple management tool with camel',1),(8375,'1 using jconsole to manage cameljava provides a jmx tool named jconsole',1),(8376,'you’ll use it to connect to a camel instance and see what information is available',1),(8377,'first, you need to start a camel instance',1),(8378,'you can do this from the chapter12/ health directory using this maven command: mvn compile exec:java -ppingservicethen, from another shell, you can start jconsole by invoking jconsole',1),(8379,'when jconsole starts, it displays a window with two radio buttons',1),(8380,'the local radio button is used to connect to existing jvms running on the same host',1),(8381,'the remote radio button is used for remote management, which we’ll cover shortly',1),(8382,'the local should already list a process, and you can click the connect button to connect jconsole to the camel instance',1),(8383,'4 shows the camel mbeans (management beans) that are visible from jconsole',1),(8384,'4 camel registers numerous mbeans that expose internal details, such as usage statistics and management operations',1),(8385,'info391using jmx with camelcamel registers many mbeans that expose statistics and operations for management',1),(8386,'those mbeans are divided into nine categories, which are listed in table 12',1),(8387,'most mbeans expose a set of standard information and operations, concerning things such as lifecycle',1),(8388,'we encourage you to spend a moment browsing the mbeans in jconsole to see what information they provide',1),(8389,'when you need to monitor and manage a camel instance from a remote computer, you must enable remote management in camel',1),(8390,'2 using jconsole to remotely manage camelto be able to remotely manage camel, you need to instruct camel to register a jmx connector',1),(8391,'that can be done in the following three ways:■ using jvm properties■ configuring the managementagent from java■ configuring the jmx agent from spring xmlwe’ll go over each of these three methods in the following sections',1),(8392,'using jvm propertiesby specifying the following jvm property on jvm startup, you can tell camel to create a jmx connector for remote management:-dorg',1),(8393,'1 categories of exposed camel mbeanscategory descriptioncomponents lists the components in use',1),(8394,'consumers lists all the input consumers for the camel routes',1),(8395,'some consumers have additional information and operations, such as the jms, timer, and file/ftp consumers',1),(8396,'context identifies the camelcontext itself',1),(8397,'this is the mbean you need if you want to shut down camel',1),(8398,'endpoints lists the endpoints in use',1),(8399,'errorhandlers lists the error handlers in use',1),(8400,'you can manage error handling at runtime, such as by changing the number of redelivery attempts or the delay between redeliveries',1),(8401,'routes lists all the routes in use',1),(8402,'here you can obtain route statistics, such as the number of messages completed, failed, and so on',1),(8403,'services lists miscellaneous services in use',1),(8404,'threadpools lists all the thread pools in use',1),(8405,'here you can obtain statistics about the number of threads currently active and the maximum number of threads that have been active',1),(8406,'you can also adjust the core and maximum pool size of the thread pool',1),(8407,'tracer allows you to manage the tracer service',1),(8408,'the tracer is a camel-specific service that’s used for tracing how messages are routed at runtime',1),(8409,'we’ll cover the use of the tracer in detail in section 12',1),(8410,'info392 chapter 12 management and monitoringif you do this, camel will log, at info level on startup, the jmx service url that’s needed to connect',1),(8411,'it will look something like this:2010-01-09 13:28:32,216 [main           ] info  defaultmanagementagent- jmx connector thread started and listening at: service:jmx:rmi:///jndi/rmi://davsclaus',1),(8412,'local:1099/jmxrmi/camelto connect to a remote jmx agent, you can use the remote radio button from jconsole and enter the service url listed in the log',1),(8413,'by default, port 1099 is used, but this can be configured using the org',1),(8414,'registryport jvm property',1),(8415,'defaultmanagementagent class is provided by camel as the default jmx agent',1),(8416,'you can configure it to allow remote connections as shown here:public class pingservicemain {    public static void main(string[] args) throws exception {        camelcontext context = new defaultcamelcontext();        defaultmanagementagent agent = ...',1),(8417,'addroutes(new pingservice());        context',1),(8418,'start();    } }all you need to do is create an instance of defaultmanagementagent, configure it to create a connector, and tell camel to use it',1),(8419,'the agent can also configure the registry port by using the setregistryport method',1),(8420,'but there is a simpler way: you can configure the settings directly using the managementagent, as follows:public class pingservicemain {    public static void main(string[] args) throws exception {        camelcontext context = new defaultcamelcontex...',1),(8421,'addroutes(new pingservice());        context',1),(8422,'start();    } }configuring a jmx agent from spring xmlif you use spring xml with camel, configuring a jmx connector is even easier',1),(8423,'all you have to do is add <jmxagent> in the <camelcontext>, as shown here:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(8424,'org/schema/spring\">    <jmxagent id=\"agent\" createconnector=\"true\"/>',1),(8425,'info393tracking application activitythe <jmxagent> also offers a registryport attribute that you can use to set a specific port number if the default port 1099 isn’t suitable',1),(8426,'you may have noticed that this example doesn’t provide any credentials when connecting to a jmx agent',1),(8427,'this may not be appropriate in production environments, so you can enable authentication with jmx',1),(8428,'the jmx documentation explains how to use security with jmx: http://download',1),(8429,'com/javase/6/docs/technotes/guides/ management/agent',1),(8430,'now that you’ve seen how to check the health of your applications, it’s time to learn how to keep an eye on what your applications are doing',1),(8431,'3 tracking application activitybeyond monitoring an application’s health, you need to ensure it operates as expected',1),(8432,'for example, if an application starts malfunctioning or has stopped entirely, it may harm business',1),(8433,'there may also be business or security requirements to track particular services for compliance and auditing',1),(8434,'a camel application used to integrate numerous systems may often be difficult to track because of its complexity',1),(8435,'it may have inputs using a wide range of transports, and schedules that trigger more inputs as well',1),(8436,'routes may be dynamic if you’re using content-based routing to direct messages to different destinations',1),(8437,'and there are errors occurring at all levels related to validation, security, and transport',1),(8438,'confronted with such complexity, how can you keep track of the behavior of your camel applications',1),(8439,'you do this by tracking the traces that various activities leave behind',1),(8440,'by configuring camel to leave traces, you can get a fairly good insight into what’s going on, both in real time and after the fact',1),(8441,'activity can be tracked using logs, whose verbosity can be configured to your needs',1),(8442,'camel also offers a notification system that you can leverage',1),(8443,'let’s look at how you can use log files and notifications to track activities',1),(8444,'1 using log filesmonitoring tools can be tailored to look for patterns, such as error messages in logs, and they can use pattern matching to react appropriately, such as by raising an alert',1),(8445,'log files have been around for decades, so any monitoring tool should have good support for efficient log file scanning',1),(8446,'even if this solution sounds basic, it’s a solution used extensively in today’s it world',1),(8447,'log files are read not only by monitoring tools but also by people, such as operations, support, or engineering staff',1),(8448,'that puts a burden on both camel and your applications to produce enough evidence so that both humans and machines can diagnose the issues reported',1),(8449,'camel offers four options for producing logs to track activities:■ using core logs—camel logs various types of information in its core logs',1),(8450,'major events and errors are reported by default',1),(8451,'■ using custom logging—you can leverage camel’s logging infrastructure to output your own log entries',1),(8452,'you can do this from different places, such as from the    www',1),(8453,'info394 chapter 12 management and monitoringroute using the log eip or log component',1),(8454,'you can also use regular logging from java code to output logs from your custom beans',1),(8455,'■ using tracer—tracer is used for tracing how and when a message is routed in camel',1),(8456,'camel logs, at info level, each and every step a message takes',1),(8457,'tracer offers a wealth of configuration options and features',1),(8458,'■ using notifications—camel emits notifications that you can use to track activities in real time',1),(8459,'let’s look at these options in more detail',1),(8460,'2 using core logscamel emits a lot of information at debug logging level and an incredible amount at trace logging level',1),(8461,'these levels are only appropriate for development, where the core logs provide great details for the developers',1),(8462,'in production, you’ll want to use info logging level, which generates a limited amount of data',1),(8463,'at this level, you won’t find information about activity for individual messages—for that you need to use notifications or the tracer, which we’ll cover in section 12',1),(8464,'the core logs in production usage usually only provide limited details for tracking activity',1),(8465,'important lifecycle events such as the application being started or stopped are logged, as are any errors that occur during routing',1),(8466,'3 using custom loggingcustom logging is useful if you’re required to keep an audit log',1),(8467,'with custom logging, you’re in full control of what gets logged',1),(8468,'in eip terms, it’s the wire tap pattern that describes this problem',1),(8469,'by tapping into an existing route, you can tap messages to an audit channel',1),(8470,'this audit channel, which is often an internal queue (seda or vm transport), is then consumed by a dedicated audit service, which takes care of logging the messages',1),(8471,'using wire tap for custom logginglet’s look at an example',1),(8472,'at rider auto parts, you’re required to log any incoming orders',1),(8473,'5 shows the situation where orders flowing in from csv files are wiretapped to an audit service before moving on for further processing',1),(8474,'wire tapauditchannelsedaconsumerauditservicecsv to order queue xmlorderfilescamelfigure 12',1),(8475,'5 using a wire tap to tap incoming files to an audit service before the file is translated to xml and sent to an order queue for further processing    www',1),(8476,'info395tracking application activityimplementing the routes outlined in figure 12',1),(8477,'5 in camel is fairly straightforward:public void configure() throws exception {    from(\"file://rider/orders\")',1),(8478,'wiretap(\"seda:audit\")',1),(8479,'bean(ordercsvtoxmlbean',1),(8480,'class)',1),(8481,'to(\"jms:queue:orders\");    from(\"seda:audit\")',1),(8482,'class, \"auditfile\"); }the first route is routing incoming order files',1),(8483,'these are wire-tapped to an internal seda queue (\"seda:audit\") for further processing',1),(8484,'the messages are then transformed from csv to xml using the ordercsvtoxmlbean bean before being sent to a jms queue',1),(8485,'the second route is used for auditing',1),(8486,'it consumes the tapped messages and processes them with an auditservice bean, which follows:public class auditservice {    private log log = logfactory',1),(8487,'class);    public void auditfile(string body) {        string[] parts = body',1),(8488,'split(\",\");        string id = parts[0];        string customerid = parts[1];        string msg = \"customer \" + customerid + \" send order id \" + id;        log',1),(8489,'info(msg);    } }this implementation of the auditservice bean has been kept simple by logging the audit messages using the apache commons logging log kit',1),(8490,'the actual logging is done in the auditfile method',1),(8491,'the source code for the book contains this example in the chapter12/logging directory, which you can try using the following maven goal:mvn test -dtest=audittestusing the camel log componentcamel provides a log component that’s capable of logging the...',1),(8492,'to leverage the log component, you simply route a message to it, as follows:public void configure() throws exception {    from(\"file://rider/orders\")',1),(8493,'bean(ordercsvtoxmlbean',1),(8494,'class)',1),(8495,'to(\"log:asxml)',1),(8496,'to(\"jms:queue:orders\"); }in this route, you use the log component in two places',1),(8497,'the first is to log the incoming file, and the second is after the transformation',1),(8498,'info396 chapter 12 management and monitoring you can try this example using the following maven goal from the chapter12/ logging directory:mvn test -dtest=logcomponenttestif you run the example, it will log the following: 2010-01-10 14:00:23,389 [: f...',1),(8499,'genericfile, body:123,4444,20100110,222,1] 2010-01-10 14:00:23,399 [: filecomponent] info  asxml- exchange[bodytype:string,body:<order><id>123/id><customerid>4444/customerid><date>20100110 </date><item><id>222</id><amount>1</amount></itemn></order>]b...',1),(8500,'notice that in the first log line, the type is genericfile, which represents a java',1),(8501,'in the second log line, the type has been changed to string, because the message was transformed to a string using the ordercsvtoxmlbean bean',1),(8502,'you can customize what the log component should log by using the many options it supports',1),(8503,'consult the camel log documentation for the options (http:// camel',1),(8504,'for example, to make the messages less verbose, you can disable showing the body type and limit the length of the message body being logged by using the following configuration:log:incoming',1),(8505,'showbodytype=false&maxchars=40that results in the following output:2010-01-10 14:06:10,187 [: filecomponent] info  incoming - exchange[body:123,4444,20100110,222,1] 2010-01-10 14:06:10,197 [: filecomponent] info  asxml- exchange[body:<order><id>123/i...',1),(8506,']tip the log component has a showall option to log everything from the exchange',1),(8507,'the log component is used to log information from the exchange, but what if you want to log a message in a custom way',1),(8508,'what you need is something like system',1),(8509,'println, so you can input whatever string message you like into the log',1),(8510,'that’s where the log eip comes in',1),(8511,'using the log eipthe log eip is built into the camel dsl',1),(8512,'it allows you to log a human-readable message from anywhere in a route, as if you were using system',1),(8513,'it’s primarily meant for developers, so they can quickly output a message to the log console',1),(8514,'but that doesn’t mean you can’t use it for other purposes as well',1),(8515,'suppose you want to log the filename you received as input',1),(8516,'this is easy with the log eip—all you have to do is pass in the message as a string:public void configure() throws exception {    from(\"file://riders/orders\")',1),(8517,'bean(ordercsvtoxmlbean',1),(8518,'class)    www',1),(8519,'to(\"jms:queue:orders\"); }the string is based on camel’s simple expression language, which supports the use of placeholders that are evaluated at runtime',1),(8520,'in this example, the filename is represented by ${file:name} and the message body by ${body}',1),(8521,'if you want to know more about the simple expression language, refer to appendix a',1),(8522,'you can run this example using the following maven goal from the chapter12/ logging directory:mvn test -dtest=logeiptestif you run this example, it will log the following:2010-01-10 15:11:18,001 [: filecomponent] info  route1- we got incoming file so...',1),(8523,'csv containing: 123,4444,20100110the log eip will, by default, log at info level using the route id as the logger name',1),(8524,'in this example, the route was not explicitly named, so camel assigned it the name route1',1),(8525,'using the log eip from spring xml is also easy, as shown here:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(8526,'org/schema/spring\">  <route>    <from uri=\"file://target/rider/orders\"/>    <log message=\"incoming file ${file:name} containing: ${body}\"/>    <bean beantype=\"camelinaction',1),(8527,'ordercsvtoxmlbean\"/>    <to uri=\"jms:queue:orders\"/>  </route> </camelcontext>the spring example is also provided in the source code for the book, which you can try using the following maven goal:mvn test -dtest=logeipspringtestthe log eip also offer...',1),(8528,'the third parameter is the log message:',1),(8529,'debug, \"incoming\",     \"incoming file ${file:name} containing: ${body}\")anyone who has had to browse millions of log lines to investigate an incident knows it can be hard to correlate messages',1),(8530,'using correlation idswhen logging messages in a system, the messages being processed can easily get interleaved, which means the log lines will be interleaved as well',1),(8531,'what you need is a way to correlate those log messages so you can tell which log lines are from which messages',1),(8532,'you do this by assigning a unique id to each created message',1),(8533,'in camel, this id is the exchangeid, which you can grab from the exchange using the exchange',1),(8534,'info398 chapter 12 management and monitoringtip you can tell the log component to log the exchangeid by using the following option: showexchangeid=true',1),(8535,'when using the log eip, you can use ${id} from the simple expression language to grab the id',1),(8536,'to help understand how and when messages are being routed, camel offers tracer, which logs message activity as it occurs',1),(8537,'4 using tracertracer’s role is to trace how and when messages are routed in camel',1),(8538,'it does this by intercepting each message being passed from one node to another during routing',1),(8539,'6 illustrates this principle',1),(8540,'you may remember being told that camel has a channel sitting between each node in a route—at points b, c, and d in figure 12',1),(8541,'the channel has multiple purposes, such as error handling, security, and interception',1),(8542,'because the tracer is implemented as an interceptor, it falls under the control of the channel, which at runtime will invoke it',1),(8543,'to use the tracer, you need to enable it, which is easily done in either the java dsl or spring xml',1),(8544,'settracing(true) from within the routebuilder class:public void configure() throws exception {    context',1),(8545,'}in spring xml, you enable the tracer from <camelcontext> as follows:<camelcontext id=\"camel\" trace=\"true\"              xmlns=\"http://camel',1),(8546,'org/schema/spring\">when running with tracer enabled, camel will record trace logs at info level, which at first may seem a bit verbose',1),(8547,'to reduce the verbosity, we have configured the tracer to not show properties and headers',1),(8548,'here is an example of tracer output:2010-01-10 16:40:58,229 [: filecomponent] info  tracer - ca18a05b-a7a6-401b-8f83-e97ba35df87e >>> (route1) from(file://target/rider/orders) --> wiretap(seda://audit) <<< pattern:inonly, bodytype:org',1),(8549,'genericfile, body:123,4444,20100110,222,1wiretap orderqueuecsv toxmlorderfilesb c dfigure 12',1),(8550,'6 tracer sits between each node in the route (at b, c, and d) and traces the message flow',1),(8551,'info399tracking application activity2010-01-10 16:40:58,241 [: filecomponent] info  tracer - ca18a05b-a7a6-401b-8f83-e97ba35df87e >>> (route1) wiretap (seda://audit) --> camelinaction',1),(8552,'ordercsvtoxmlbean@129103 <<< pattern:inonly, bodytype:org',1),(8553,'genericfile, body:123,4444,20100110,222,1 2010-01-10 16:40:58,241 [1: seda://audit] info  tracer                      - b4d4c842-3884-41aa-a216-d230a6661a9e >>> (route2) from(seda://audit) --> camelinaction',1),(8554,'ordercsvtoxmlbean@129103 --> seda://queue:orders <<< pattern:inonly, bodytype:string, body:<order><id>123/id><customerid>4444/customerid><date>20100110 </date><item><id>222</id><amount>1</amount></item></order>the interesting thing to note from the t...',1),(8555,'in this example, there are two different ids in play: ca18a05b-a7a6-401b-8f83-e97ba35df87e and b4d4c842-3884-41aaa216-d230a6661a9e',1),(8556,'you may wonder why we have two ids when there is only one incoming message',1),(8557,'that’s because the wire tap creates a copy of the incoming message, and the copied message will use a new exchange id because it’s being routed as a separate process',1),(8558,'next, the tracer outputs which route the message is currently at, followed by the from --> to nodes',1),(8559,'this is probably the key information when using tracer, because you can see each individual step the message takes in camel',1),(8560,'then the tracer logs the message exchange pattern, which is either inonly or inout',1),(8561,'finally, it logs the information from the message, just as the log component would do',1),(8562,'tip you can use the delay interceptor to slow processing down to a pace we humans can follow',1),(8563,'for example, you could delay and tail the log file, watching what happens in the log file while the message is being routed, to get a better understanding of what’s going on',1),(8564,'customizing the tracer  we just said that we had customized the tracer to be less verbose',1),(8565,'this can be done by defining a bean in the registry with the bean id traceformatter',1),(8566,'in spring xml this is easy—all you do is this:<bean id=\"traceformatter\"      class=\"org',1),(8567,'processor',1),(8568,'defaulttraceformatter\">    <property name=\"showproperties\" value=\"false\"/>    <property name=\"showheaders\" value=\"false\"/> </bean>the formatter has many other options that you can read about in its online documentation (http://camel',1),(8569,'one of the options is maxchars, which can    www',1),(8570,'info400 chapter 12 management and monitoringlimit the message body being logged',1),(8571,'for example, setting it to a value of 200 will limit the tracer to only output at most 200 characters',1),(8572,'if you have many routes, the tracer will output a lot of logs',1),(8573,'fortunately, you can customize the tracer to only trace certain routes',1),(8574,'you can even do this at runtime using jmx, but we’ll get to that a bit later',1),(8575,'you can do the same with the <route> tag',1),(8576,'suppose you only wanted to trace the first route—you could enable the tracer on that particular route, as shown here:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(8577,'org/schema/spring\">    <route trace=\"true\">        <from uri=\"file://rider/orders\"/>        <wiretap uri=\"seda:audit\"/>        <bean beantype=\"camelinaction',1),(8578,'ordercsvtoxmlbean\"/>        <to uri=\"jms:queue:orders\"/>    </route>    <route>        <from uri=\"seda:audit\"/>        <bean beantype=\"camelinaction',1),(8579,'auditservice\"/>    </route> </camelcontext>doing this from the java dsl is a bit different',1),(8580,'you need to do it using the fluent builder syntax by using either tracing() or notracing(), as follows:public void configure() throws exception {    from(\"file://target/rider/orders\")',1),(8581,'wiretap(\"seda:audit\")',1),(8582,'bean(ordercsvtoxmlbean',1),(8583,'class)',1),(8584,'to(\"jms:queue:orders\");    from(\"seda:audit\")',1),(8585,'class, \"auditfile\"); }if a route isn’t explicitly configured with a tracer, it will fall back and leverage the configuration from the camelcontext',1),(8586,'this allows you to quickly turn tracing on and off from the camelcontext but still have some special routes with their own settings',1),(8587,'the tracer can also be managed using jmx',1),(8588,'this allows you to enable tracing for a while to see what happens and identify issues',1),(8589,'managing tracer using jmxthe tracer can be managed from the jmx console in two places',1),(8590,'you can enable or disable tracing at either the context or at routes',1),(8591,'you could do the same on a per route basis using the routes mbeans',1),(8592,'you can configure what the tracer logs from the tracer mbean, as shown in figure 12',1),(8593,'info401tracking application activitywe’ve prepared an example for you to try in the source code for the book',1),(8594,'first, run this maven goal in the chapter12/tracer directory: mvn compile exec:java -pmanagetracer this will start an application that will run for a while',1),(8595,'then start jconsole and connect to the application',1),(8596,'click on the mbeans tab and expand the org',1),(8597,'8 shows where you’re going',1),(8598,'click on the value for the tracing attribute, which should be editable',1),(8599,'change the value from false to true, and press enter to confirm',1),(8600,'you should be able to see the changes in the console logged by the application',1),(8601,'spend some time playing with this',1),(8602,'for example, change some of the other options on the tracer',1),(8603,'monitoring applications via the core logs, custom logging, and tracer is like looking into camel’s internal journal after the fact',1),(8604,'if the log files get very big, it may feel like you’re looking for a needle in a haystack',1),(8605,'sometimes you might prefer to have camel call you when particular events occur',1),(8606,'this is where the notification mechanism comes into play',1),(8607,'7 managing the tracer from jmx allows you to customize the trace logging and change many attributes at runtime',1),(8608,'5 using notificationsfor fine-grained tracking of activity, camel’s management module offers notifiers for handling internal notifications',1),(8609,'these notifications are generated when specific events occur inside camel, such as when an instance starts or stops, when an exception has been caught, or when a message is created or completed',1),(8610,'the notifiers subscribe to these events as listeners, and they react when an event is received',1),(8611,'camel uses a pluggable architecture, allowing you to plug in and use your own notifier, which we’ll cover later in this section',1),(8612,'camel provides the following notifiers out of the box:■ loggingeventnotifier—a notifier for logging a text representation of the event using the apache commons logging framework',1),(8613,'this means you can use log4j, which has a broad range of appenders that can dispatch log messages to remote servers using udp, tcp, jms, snmp, email, and so on',1),(8614,'■ publisheventnotifier—a notifier for dispatching the event to any kind of camel endpoint',1),(8615,'this allows you to leverage camel transports to broadcast the message any way you want',1),(8616,'■ jmxnotificationeventnotifier—a notifier for broadcasting the events as jmx notifications',1),(8617,'for example, management and monitoring tooling can be used to subscribe to the notifications',1),(8618,'you’ll learn in the following sections how to set up and use an event notifier and how to build and use a custom notifier',1),(8619,'8 to enable tracing, select the camelcontext under the context node and change the tracing attribute from false to true',1),(8620,'info403tracking application activitywarning because routing each exchange produces at least two notifications, you can be overloaded with thousands of notifications',1),(8621,'that’s why you should always filter out unwanted notifications',1),(8622,'the publisheventnotifier will leverage camel to route the event message, which will potentially induce a second load on your system',1),(8623,'that’s why the notifier is configured by default to not generate new events during processing of events',1),(8624,'configuring an event notifiercamel doesn’t use event notifiers by default, so to use a notifier you must configure it',1),(8625,'this is done by setting the notifier instance you wish to use on the managementstrategy',1),(8626,'when using the java dsl, this is done as shown here:loggingeventnotifier notifier = new loggingeventnotifier(); notifier',1),(8627,'setignorecamelcontextevents(true); notifier',1),(8628,'setignorerouteevents(true); notifier',1),(8629,'setignoreserviceevents(true); context',1),(8630,'seteventnotifier(notifier);first you create an instance of loggingeventnotifier, because you’re going to log the events using log4j',1),(8631,'then you set the log name you wish to use',1),(8632,'in this case, you’re only interested in some of the events, so you ignore the ones you aren’t interested in',1),(8633,'the configuration when using spring xml is a bit different, because camel will pick up the notifier automatically when it scans the registry for beans of type eventnotifier on startup',1),(8634,'this means you just have to declare a spring bean, like this:<bean id=\"eventlogger\"       class=\"org',1),(8635,'eventlog\"/>    <property name=\"ignorecamelcontextevents\" value=\"true\"/>    <property name=\"ignorerouteevents\" value=\"true\"/>    <property name=\"ignoreserviceevents\" value=\"true\"/> </bean>you can also write your custom eventnotifier instead of using t...',1),(8636,'using a custom event notifierrider auto parts wants to integrate an existing camel application with the company’s centralized error log database',1),(8637,'they already have a java library that’s capable of publishing to the database, and this makes the task much easier',1),(8638,'9 illustrates the situation',1),(8639,'they decide to implement a custom event notifier named ridereventnotifier, which uses their own java code, allowing ultimate flexibility',1),(8640,'the following listing shows the important snippets of how to implement this',1),(8641,'in listing 12',1),(8642,'1, you extend the eventnotifiersupport class, which is an abstract class meant to be extended by custom notifiers',1),(8643,'if you don’t want to extend this class, you can implement the eventnotifier interface instead',1),(8644,'the riderfailurepublisher class is the existing java library for publishing failure events to the database',1),(8645,'info404 chapter 12 management and monitoringpublic class ridereventnotifier extends eventnotifiersupport {       private riderfailurepublisher publisher;    public void notify(eventobject eventobject) throws exception {        if (eventobject instanc...',1),(8646,'getexchangeid();                        exception cause = event',1),(8647,'getexception();        date now = new date();        publisher',1),(8648,'publish(appid, id, now,                          cause',1),(8649,'getmessage());             }    public boolean isenabled(eventobject eventobject) {        return true;    }    protected void dostart() throws exception {}    protected void dostop() throws exception {} }the notify method is invoked by camel with th...',1),(8650,'eventobject instance',1),(8651,'you use an instanceof test to filter for the events you’re interested in, which are failure events b',1),(8652,'then information is extracted from the event, such as the unique exchange id and the exception message to be published',1),(8653,'this information is then published using the existing java library c',1),(8654,'tip if you have any resources that must be initialized, camel offers dostart and dostop methods for this kind of work, as shown in listing 12',1),(8655,'the source code for the book contains this example in the chapter12/notifier directory, which you can try using the following maven goal:mvn test -dtest=ridereventnotifiertestlisting 12',1),(8656,'1 a custom event notifier publishes failure events to a central log databaseerror logdatabaseridercamel routescamelmonitoring toolpublish failuresmonitorseventseventnotifierfigure 12',1),(8657,'9 failure events must be published into the centralized error log database using the custom ridereventnotifier',1),(8658,'filters failure eventsbpublishes failure eventsc    www',1),(8659,'info405managing camel applicationswe’ve now reviewed four ways to monitor camel applications',1),(8660,'you learned to use camel’s standard logging capabilities and to roll a custom solution when needed',1),(8661,'in the next section, we’ll take a further look at how to manage both camel and your custom camel components',1),(8662,'4 managing camel applicationswe already touched on how to manage camel in section 12',1),(8663,'2, where we covered how to use jmx with camel',1),(8664,'in this section, we’ll take a deeper dive into managementrelated use cases and show how you can management-enable your custom camel components and services',1),(8665,'we’ll start by looking at how you can manage the lifecycles of your camel applications',1),(8666,'1 managing camel application lifecyclesit’s essential to be able to manage the lifecycles of your camel applications',1),(8667,'you should be able to stop and start camel in a reliable manner, and you should be able to pause or stop a camel route temporarily, to avoid taking in new messages while an incident is being mitigated',1),(8668,'camel offers you full lifecycle management on all levels',1),(8669,'suppose you want to stop an existing camel route',1),(8670,'to do this, you connect to the application with jmx as you learned in section 12',1),(8671,'10 shows jconsole with the route in question selected',1),(8672,'as you can see in figure 12',1),(8673,'10, route1 has been selected from the mbeans tree',1),(8674,'you can view its attributes, which reveal various stats such as the number of exchanges completed and failed, its performance, and so on',1),(8675,'the state attribute displays information about the lifecycle—whether it’s started or stopped',1),(8676,'10 selecting the route to manage in jconsole    www',1),(8677,'info406 chapter 12 management and monitoringto stop the route, select the operations entry and click the stop operation',1),(8678,'then return to the attributes entry and click the refresh button to update the attributes',1),(8679,'you should see the state attribute’s value change to stopped',1),(8680,'managing consumersstarting and stopping routes is a common thing to do, but what if you want to adjust how the routes behave at runtime',1),(8681,'camel allows you to manage the consumers, and you can adjust them at runtime',1),(8682,'imagine you have a route that uses a file consumer to pick up new files, and you want to change the polling interval for the file consumer',1),(8683,'11 shows how you can do this by selecting the file consumer under consumers in the mbean tree',1),(8684,'the changes to the attributes aren’t enforced immediately',1),(8685,'you have to restart the consumer, which is done by invoking the stop and then the start operation',1),(8686,'you may have built some camel components of your own that you would like to manage',1),(8687,'this can also be done',1),(8688,'2 managing custom camel componentssuppose rider auto parts has developed a camel erp component to integrate with their erp system, and the operations staff has requested that the component be managed',1),(8689,'the component has a verbosity switch that should be exposed for management',1),(8690,'running with verbosity enabled allows the operations staff to retrieve additional information from the logs, which is needed when some sort of issue has occurred',1),(8691,'listing 12',1),(8692,'2 shows how you can implement this on the erpendpoint class, which is part of the erp component',1),(8693,'this code listing has been abbreviated to show only the relevant parts of the listing—the full example is in the source code for the book in the chapter12/custom directory',1),(8694,'11 adjusting a file consumer at runtime by changing the delay attribute    www',1),(8695,'info407managing camel applicationsimport org',1),(8696,'managedresource;@managedresource(description = \"managed erpendpoint\")       public class erpendpoint extends defaultendpoint        implements managementaware<erpendpoint> {     private boolean verbose;    public erpendpoint(string endpointuri, compo...',1),(8697,'verbose = verbose;    }    public object getmanagedobject(erpendpoint object) {              return this;    } }if you’ve ever tried using the jmx api to expose the management capabilities of your custom beans, you’ll know it’s a painful api to leverage',1),(8698,'it’s better to go for the easy solution and leverage spring jmx',1),(8699,'you’ll notice, in the source code from listing 12',1),(8700,'2, that it uses the spring @managedresource annotation b to expose this class as an mbean',1),(8701,'in the same way, you can expose the verbose property as a managed attribute by using the @managedattribute c annotation on the getter and setter methods',1),(8702,'what remains is to tell camel to enlist this mbean for management, which is done by implementing the managementaware interface',1),(8703,'this interface brings in the getmanagedobject method d, where you simply return this',1),(8704,'you can run the following maven goal from chapter12/custom directory to try out this example: mvn compile exec:java -pcustomwhen you do, the console will output a log line every 5 seconds, as the route below illustrates:from(\"timer:foo',1),(8705,'simple(\"hello erp calling at ${date:now:hh:mm:ss}\")',1),(8706,'to(\"log:reply\");what you want to do now is turn on the verbose switch from your custom erp component',1),(8707,'12 shows how this is done from jconsole',1),(8708,'listing 12',1),(8709,'2 management-enabling a custom endpointexposes class as mbeanbexposes attributes for managementctells camel to use this mbeand    www',1),(8710,'info408 chapter 12 management and monitoringas you can see in figure 12',1),(8711,'12, your custom component is listed under endpoints as erp://foo, which was the uri used in the route',1),(8712,'the figure also shows the verbose attribute',1),(8713,'if you change this value to true, the console should immediately reflect this change',1),(8714,'the first two of the following lines are from before the verbose switch was enabled',1),(8715,'when the switch is enabled, it starts to output calling erp',1),(8716,', as shown below:2010-01-30 15:09:49,118 [foo            ] info  reply- exchange[bodytype:string, body:simulated response from erp] 2010-01-30 15:09:54,118 [foo            ] info  reply- exchange[bodytype:string, body:simulated response from erp] cal...',1),(8717,'a camel component consists of several classes, such as component, endpoint, producer, and consumer, and you can management-enable any of those',1),(8718,'for example, the schedule-based components, such as the timer, allow you to manage the consumers to adjust how often they should trigger',1),(8719,'you have now learned all there is to managing camel applications and enlisting your custom components for management',1),(8720,'12 enabling the verbose attribute at runtime using jconsole    www',1),(8721,'info409summary and best practices12',1),(8722,'5 summary and best practicesa sound strategy for monitoring your applications is necessary when you take them into production',1),(8723,'your organization may already have strategies that must be followed for running and monitoring applications',1),(8724,'in this chapter, we looked at how you can monitor your camel applications using health-level checks',1),(8725,'you learned that existing monitoring tools could be used via snmp or jmx protocols',1),(8726,'using jmx allows you to manage camel at the application level, which is essential for lifecycle management, and performing functions such as stopping a route',1),(8727,'we also looked at what camel has to offer in terms of logging',1),(8728,'you learned about the camel logs and how you can use custom logging',1),(8729,'we also covered the camel notification system, which is pluggable, allowing you to hook in your own notification adapter and send notifications to a third party',1),(8730,'here are a few simple guidelines:■ involve the operations team',1),(8731,'monitoring and management isn’t an afterthought',1),(8732,'you should involve the operations team early in the project’s lifecycle',1),(8733,'your organization likely already has procedures for managing applications, which must be followed',1),(8734,'■ use health checks',1),(8735,'for example, develop a happy page that does an internal health check and reports back on the status',1),(8736,'a happy page can then easily be accessed from a web browser and monitoring tools',1),(8737,'■ provide informative error messages',1),(8738,'when something goes wrong, you want the operations staff receiving the alert to be able to understand what the error is all about',1),(8739,'if you throw exceptions from business logic, include descriptive information about what’s wrong',1),(8740,'■ use the tracer',1),(8741,'if messages aren’t being routed as expected, you can enable the tracer to see how they’re actually being routed',1),(8742,'but beware; the tracer can be very verbose and your logs can quickly fill up with lines if your application processes a lot of messages',1),(8743,'■ read log files from testing',1),(8744,'have developers read the log files to see which exceptions have been logged',1),(8745,'this can help them preemptively fix issues that otherwise could slip into production',1),(8746,'management and monitoring aren’t the sole tasks the operations staff plays with regards to your camel applications',1),(8747,'the staff is also very much involved in the deployment process, taking your applications into production',1),(8748,'the next chapter covers this topic, walking through the various deployment strategies',1),(8749,'info410running and deploying camelin the previous chapter, you learned all about monitoring and managing camel',1),(8750,'we’ll now shift focus to another topic that’s important to master: running and deploying camel applications',1),(8751,'we’ll start with the topic of running camel—you’ll need to fully understand how to start, run, and shut down camel reliably and safely, which is imperative in a production environment',1),(8752,'we’ll also review various options you can use to tweak how camel and routes are started',1),(8753,'we’ll continue on this path, looking at how you can dynamically start and stop routes at runtime',1),(8754,'your applications won’t run forever, so we’ll spend some time focusing on how to shut down camel in a safe manner',1),(8755,'the other part of the chapter covers various strategies for deploying camel',1),(8756,'we’ll take a look at four common runtime environments supported by camel',1),(8757,'this chapter covers■ starting camel■ starting and stopping routes at runtime■ shutting down camel■ deploying camel    www',1),(8758,'info411starting camelas we discuss these topics, we’ll work through an example involving rider auto parts',1),(8759,'you’ve been asked to help move a recently developed application safely into production',1),(8760,'the application receives inventory updates from suppliers, provided via a web service or files',1),(8761,'1 shows a high-level diagram of the application',1),(8762,'1 starting camelin chapter 1, you learned how to download, install, and run camel',1),(8763,'that works well in development, but the game plan changes when you take an application into production',1),(8764,'starting up a camel application in production is harder than you might think, because the order in which the routes are started may have to be arranged in a certain way to ensure a reliable startup',1),(8765,'it’s critical that the operations staff can safely manage the application in their production environment',1),(8766,'let’s look now at how camel starts',1),(8767,'1 how camel startscamel doesn’t start magically by itself',1),(8768,'often it’s the server (container) that camel is running inside that invokes the start method on camelcontext, starting up camel',1),(8769,'this is also what you saw in chapter 1, where you used camel inside a standalone java application',1),(8770,'a standalone java application isn’t the only deployment choice—you can also run camel inside a container such as spring or osgi',1),(8771,'regardless of which container you use, the same principle applies',1),(8772,'the container must prepare and create an instance of camelcontext up front, before camel can be started, as illustrated in figure 13',1),(8773,'web servicefile csv toobjectupdateinventoryupdateroutesplit linesfigure 13',1),(8774,'1 a rider auto parts application accepting incoming inventory updates from either files or a web servicespring(camel-spring)osgi(camelspring)standalone(camel-core)camelcontext(camel-core)createscreatescreatesosgi(camelblueprint)createsfigure 13',1),(8775,'2 using camel with containers often requires the container in question to prepare and create camelcontext up front before it can be started',1),(8776,'info412 chapter 13 running and deploying camelbecause spring is a common container, we’ll outline how spring and camel work together to prepare a camelcontext',1),(8777,'preparing camelcontext in a spring containerspring allows third-party frameworks to integrate seamlessly with spring',1),(8778,'to do this, the third-party frameworks must provide a org',1),(8779,'namespacehandler, which is the extension point for using custom namespaces in spring xml files',1),(8780,'camel provides the camelnamespacehandler',1),(8781,'when using camel in the spring xml file, you would define the <camelcontext> tag as follows:   <camelcontext xmlns=\"http://camel',1),(8782,'org/schema/spring\">the http://camel',1),(8783,'org/schema/spring namespace is the camel custom namespace',1),(8784,'to let spring know about this custom namespace, it must be identified in the meta-inf/spring',1),(8785,'handlers, where you map the namespace to the class implementation:http\\://camel',1),(8786,'org/schema/spring=  org',1),(8787,'camelnamespacehandlerthe camelnamespacehandler is then responsible for parsing the xml and delegating to other factories for further processing',1),(8788,'one of these factories is the camelcontextfactorybean, which is responsible for creating the camelcontext that essentially is your camel application',1),(8789,'when spring is finished initializing, it signals to third-party frameworks that they can start by broadcasting the contextrefreshedevent event',1),(8790,'starting camelcontextat this point, camelcontext is ready to be started',1),(8791,'what happens next is the same regardless of which container or deployment option you’re using with camel',1),(8792,'3 shows a flow diagram of the startup process',1),(8793,'camelcontext is started by invoking its start method',1),(8794,'the first step in figure 13',1),(8795,'3 determines whether or not autostartup is enabled for camel',1),(8796,'if it’s disabled, the entire startup process is skipped',1),(8797,'by default, camel is set to autostart, which involves the following four steps',1),(8798,'2341noyesstart internalservicescompute the startingorder of routesprepare routesbefore staringstart routesfigure 13',1),(8799,'3 flow diagram showing how camel starts by starting internal services, computing the starting order of routes, and preparing and starting the routes',1),(8800,'info413starting camel1 start internal services—prepares and starts internal services used by camel, such as the type-converter mechanism',1),(8801,'2 compute starting order—computes the order in which the routes should be started',1),(8802,'by default, camel will start up all the routes in the order they are defined in the spring xml files or the routebuilder classes',1),(8803,'we’ll cover how to configure the order of routes in section 13',1),(8804,'3 prepare routes—prepares the routes before they’re started',1),(8805,'4 start routes—starts the routes by starting the consumers, which essentially opens the gates to camel and lets the messages start to flow in',1),(8806,'after step 4, camel writes a message to the log indicating that it has been started and that the startup process is complete',1),(8807,'in some cases, you may need to influence how camel is started, and we’ll look at that now',1),(8808,'2 camel startup optionscamel offers various options when it comes to starting camel',1),(8809,'for example, you may have a maintenance route that should not be autostarted on startup',1),(8810,'you may also want to enable tracing on startup to let camel log traces of messages being routed',1),(8811,'1 lists all the options that influence startup',1),(8812,'the options from table 13',1),(8813,'the first four options are related to startup and shutdown, and the remainder are miscellaneous options',1),(8814,'we’ll look at how to use the miscellaneous options first, and then we’ll turn our attention to the startup and shutdown options',1),(8815,'1 camel startup optionsoption descriptionautostartup this option is used to indicate whether or not the route should be started automatically when camel starts',1),(8816,'this option is enabled by default',1),(8817,'startuporder this option dictates the order in which the routes should be started when camel starts',1),(8818,'we’ll cover this in section 13',1),(8819,'shutdownroute this option is used to configure whether or not the route in question should stop immediately or defer while camel is shutting down',1),(8820,'we’ll cover shutdown in section 13',1),(8821,'shutdownrunningtask this option is used to control whether camel should continue to complete pending running tasks at shutdown or stop immediately after the current task is complete',1),(8822,'we’ll cover shutdown in section 13',1),(8823,'tracing this option is used to trace how an exchange is being routed within that particular route',1),(8824,'this option is disabled by default',1),(8825,'delayer this option is used to set a delay in milliseconds that slows down the processing of a message',1),(8826,'you can use this during debugging to reduce how quickly camel routes messages, which may help you track what happens when you watch the logs',1),(8827,'this option is disabled by default',1),(8828,'info414 chapter 13 running and deploying camelconfiguring streamcachingthe miscellaneous options are often used during development to turn on additional logging, such as the tracing option, which we covered in the last chapter',1),(8829,'or you may need to turn on stream caching if you use camel with other stream-centric systems',1),(8830,'for example, to enable stream caching, you can do the following with the java dsl:public class myroute extends routebuilder {    public void configure() throws exception {        context',1),(8831,'setstreamcaching(true);        from(\"jbi:service:http://rider',1),(8832,'to(\"xslt:html-parts',1),(8833,'xsl\")',1),(8834,'to(\"jbi:service:http://rider',1),(8835,'com/htmlservice\");    } }the same example using spring xml would look like this:<camelcontext streamcache=\"true\"              xmlns=\"http://camel',1),(8836,'org/schema/spring\">    <route>        <from uri=\"jbi:service:http://rider',1),(8837,'com/autopartservice\"/>        <to uri=\"xslt:html-parts',1),(8838,'xsl\"/>        <to uri=\"jbi:service:http://rider',1),(8839,'com/htmlservice\"/>    </route> </camelcontext>all the options from table 13',1),(8840,'1 can be scoped at either context or route level',1),(8841,'the preceding stream cache example was scoped at context level',1),(8842,'you could also configure it on a particular route:public class myroute extends routebuilder {    public void configure() throws exception {        from(\"jbi:service:http://rider',1),(8843,'to(\"xslt:html-parts',1),(8844,'xsl\")',1),(8845,'to(\"jbi:service:http://rider',1),(8846,'com/htmlservice\");    } }handlefault this option is used to turn fault messages into exceptions',1),(8847,'this is not a typical thing to do in a pure camel application, but when deployed into a jbi container like apache servicemix, you’ll need to set this option to let the camel error handler react to faults',1),(8848,'this option is disabled by default',1),(8849,'we’ll cover this in more detail shortly',1),(8850,'streamcaching this option is used to cache streams that otherwise couldn’t be accessed multiple times',1),(8851,'you may want to use this when you use redelivery during error handling, which requires being able to read the stream multiple times',1),(8852,'this option is disabled by default',1),(8853,'we’ll cover this in more detail shortly',1),(8854,'1 camel startup options (continued)option description    www',1),(8855,'info415starting camelyou can configure route-scoped stream caching in spring xml as follows:<camelcontext xmlns=\"http://camel',1),(8856,'org/schema/spring\">    <route streamcache=\"true\">        <from uri=\"jbi:service:http://rider',1),(8857,'com/autopartservice\"/>        <to uri=\"xslt:html-parts',1),(8858,'xsl\"/>        <to uri=\"jbi:service:http://rider',1),(8859,'com/htmlservice\"/>    </route> </camelcontext>note java dsl uses the syntax noxxx to disable an option, such as nostreamcaching or notracing',1),(8860,'there is one last detail to know about the context and route scopes',1),(8861,'the context scope is used as a fallback if a route doesn’t have a specific configuration',1),(8862,'the idea is that you can configure the default setting on the context scope and then override when needed at the route scope',1),(8863,'for example, you could enable tracing on the context scope and then disable it on the routes you don’t want traced',1),(8864,'configuring handlefaultin the preceding example, you route messages using the jbi component',1),(8865,'the handlefault option is used to control whether or not camel error handling should react to faults',1),(8866,'suppose sending to the jbi:service:http://rider',1),(8867,'com/htmlservice endpoint fails with a fault',1),(8868,'without handlefault enabled, the fault would be propagated back to the consumer',1),(8869,'by enabling handlefault, you can let the camel error handler react when faults occur',1),(8870,'the following code shows how you can let the deadletterchannel error handler save failed messages to files in the error directory:public class myroute extends routebuilder {    public void configure() throws exception {        errorhandler(deadletter...',1),(8871,'to(\"xslt:html-parts',1),(8872,'xsl\")',1),(8873,'to(\"jbi:service:http://rider',1),(8874,'com/htmlservice\");    } }the equivalent example in spring xml is as follows:<camelcontext xmlns=\"http://camel',1),(8875,'org/schema/spring\">    <errorhandler id=\"eh\" type=\"deadletterchannel\"                  deadletteruri=\"file:errors\"/>    <route streamcache=\"true\" errorhandlerref=\"eh\" handlefault=\"true\">        <from uri=\"jbi:service:http://rider',1),(8876,'com/autopartservice\"/>        <to uri=\"xslt:html-parts',1),(8877,'xsl\"/>        <to uri=\"jbi:service:http://rider',1),(8878,'3 ordering routesthe order in which routes are started and stopped becomes more and more important the more interdependent the routes are',1),(8879,'for example, you may have reusable routes that must be started before being leveraged by other routes',1),(8880,'also, routes that immediately consume messages that are bound for other routes may have to be started later to ensure that the other routes are ready in time',1),(8881,'to control the startup order of routes, camel provides two options: autostartup and startuporder',1),(8882,'the former dictates whether the routes should be started or not',1),(8883,'the latter is a number that dictates the order in which the routes should be started',1),(8884,'using startuporder to control ordering of routeslet’s return to our rider auto parts example, outlined at the beginning of the chapter',1),(8885,'4 shows the high-level diagram again, this time numbering the three routes in use, b, c, and d',1),(8886,'b the file-based route will poll incoming files and split each line in the file',1),(8887,'the lines are then converted to an internal camelinaction',1),(8888,'updateinventoryinput object, which is sent to the d route',1),(8889,'c the web service route is much simpler because incoming messages are automatically converted to the updateinventoryinput object',1),(8890,'the web service endpoint is configured to do this',1),(8891,'d this route is a common route that’s reused by the first two routes',1),(8892,'routes b and c depend upon route d, and that’s why you need to use startuporder to ensure that the routes are started in correct order',1),(8893,'the following listing shows the camel routes with the startuporder options in boldface',1),(8894,'web servicefile csv toobjectupdateinventoryupdateroutesplit linesbdcfigure 13',1),(8895,'4 camel application with two input routes b and c which depend on a common route d    www',1),(8896,'info417starting camelpublic class inventoryroute extends routebuilder {    @override    public void configure() throws exception {        from(\"cxf:bean:inventoryendpoint\")',1),(8897,'routeid(\"webservice\")',1),(8898,'transform()',1),(8899,'method(\"inventoryservice\", \"replyok\");        from(\"file://target/inventory/updates\")',1),(8900,'tokenize(\"\\n\"))',1),(8901,'class)',1),(8902,'method=updateinventory\");    } }listing 13',1),(8903,'1 shows how easy it is in the java dsl to configure the order of the routes using startuporder',1),(8904,'listing 13',1),(8905,'2 shows the same example using spring xml',1),(8906,'note in listing 13',1),(8907,'1, routeid is used to assign each route a meaningful name, which will then show up in the management console or in the logs',1),(8908,'if you don’t assign an id, camel will auto-assign an id using the scheme route1, route2, and so forth',1),(8909,'<camelcontext xmlns=\"http://camel',1),(8910,'org/schema/spring\">    <route id=\"webservice\" startuporder=\"3\">        <from uri=\"cxf:bean:inventoryendpoint\"/>        <to uri=\"direct:update\"/>        <transform>            <method bean=\"inventoryservice\" method=\"replyok\"/>        </transform>    <...',1),(8911,'updateinventoryinput\"/>            <to uri=\"direct:update\"/>        </split>    </route>    <route id=\"update\" startuporder=\"1\">        <from uri=\"direct:update\"/>listing 13',1),(8912,'1 starting routes in a specific orderlisting 13',1),(8913,'2 spring xml version of listing 13',1),(8914,'method=updateinventory\"/>    </route></camelcontext>you should notice that the numbers 1, 2 and 3 are used to dictate the order of the routes',1),(8915,'let’s take a moment to see how this works in camel',1),(8916,'how startuporder worksthe startuporder option in camel works much like the load-on-startup option for java servlets',1),(8917,'as with servlets, you can specify a positive number to indicate the order in which the routes should be started',1),(8918,'the numbers don’t have to be consecutive',1),(8919,'for example, you could have used the numbers 5, 20, and 87 instead of 1, 2, and 3',1),(8920,'all that matters is that the numbers must be unique',1),(8921,'you can also omit assigning a startuporder to some of the routes',1),(8922,'in that case, camel will assign these routes a unique number starting with 1,000 upwards',1),(8923,'this means that the numbers from 1 to 999 are free for camel users, and the numbers from 1,000 upward are reserved by camel',1),(8924,'tip the routes are stopped in the reverse order in which they were started',1),(8925,'in practice, you may not need to use startuporder often',1),(8926,'it’s only important when you have route dependencies, as in the previous example',1),(8927,'the source code for the book contains this example in the chapter13/startup directory',1),(8928,'you can try it out using the following maven goals:mvn test -dtest=inventoryjavadsltest mvn test -dtest=inventoryspringxmltestyou’ve now learned to control the order in which routes are started',1),(8929,'let’s move on and take a look at how you can omit starting certain routes and start them on demand later, at runtime',1),(8930,'4 disabling autostartuptable 13',1),(8931,'1 listed the autostartup option, which is used to specify whether or not a given route should be automatically started when camel starts',1),(8932,'sometimes you may not want to start a route automatically—you may want to start it on demand at runtime to support business cases involving human intervention',1),(8933,'at rider auto parts, there has been a demand to implement a manual process for updating the inventory based on files',1),(8934,'as usual, you’ve been asked to implement this in the existing application depicted in figure 13',1),(8935,'you come up with the following solution: add a new route to the existing routes in listing 13',1),(8936,'the new route listens for files being dropped in the manual directory, and uses these files to update the inventory',1),(8937,'info419starting and stopping routes at runtime',1),(8938,'tokenize(\"\\n\"))',1),(8939,'class)',1),(8940,'end();as you can see, the route is merely a copy of the file-based route in listing 13',1),(8941,'unfortunately, your boss isn’t satisfied with the solution',1),(8942,'the route is always active, so if someone accidentally drops a file into the manual folder, it would be picked up',1),(8943,'to solve this problem, you use the autostartup option to disable the route from being activated on startup:from(\"file://target/inventory/manual\")',1),(8944,'tokenize(\"\\n\"))',1),(8945,'class)',1),(8946,'end();you can start the route when a manual file is meant to be picked up',1),(8947,'this can be done by using a management console, such as jconsole, to manually start the route, waiting until the file has been processed, and manually stopping the route again',1),(8948,'tip there is a subtle difference between using boolean-based options in the java dsl and spring xml',1),(8949,'for example, autostartup is implemented as autostartup=\"false\" in spring xml and as noautostartup() in the java dsl',1),(8950,'you’ve now learned how to configure camel with various options that influence how it starts up',1),(8951,'in the next section, we’ll look at various ways of programmatically controlling the lifecycle of routes at runtime',1),(8952,'2 starting and stopping routes at runtimein chapter 12, you learned how to use management tooling, designed for operations staff, to start and stop routes at runtime',1),(8953,'being able to programmatically control routes at runtime is also desirable',1),(8954,'for example, you might want business logic to automatically turn routes on or off at runtime',1),(8955,'in this section, we’ll look at how to do this',1),(8956,'you can start and stop routes at runtime in several ways, including these:■ using camelcontext—by invoking the startroute and stoproute methods',1),(8957,'■ using routepolicy—by applying a policy to routes that camel enforces automatically at runtime',1),(8958,'■ using jmx—by obtaining the managedroute mbean for the particular routes and invoking its start or stop methods',1),(8959,'if you have remote management enabled, you can control the routes from another machine',1),(8960,'the use of jmx was covered in the previous chapter, so we’ll discuss using camelcontext and routepolicy in this chapter',1),(8961,'1 using camelcontext to start and stop routes at runtimethe camelcontext provides methods to easily start and stop routes',1),(8962,'to illustrates this, we’ll continue with the rider auto parts example from section 13',1),(8963,'about a month into production with the new route, one of the operations staff forgot to manually stop the route after use, as he was supposed to',1),(8964,'not stopping the route leads to a potential risk because files accidentally dropped into the manual directory will be picked up by the route',1),(8965,'you are again summoned to remedy this problem, and you quickly improve the route with the two changes shown in bold in the following listing',1),(8966,'maxmessagesperpoll=1\")',1),(8967,'tokenize(\"\\n\"))',1),(8968,'class)',1),(8969,'process(new processor() {        public void process(exchange exchange) throws exception {            exchange',1),(8970,'getinflightrepository()',1),(8971,'stoproute(\"manual\");        }    });the first change uses the maxmessagesperpoll option to tell the file consumer to only pick up one file at a time',1),(8972,'the second change stops the route after that one file has been processed',1),(8973,'this is done with the help of the inlined processor, which can access the camelcontext and tell it to stop the route by name',1),(8974,'(camelcontext also provides a startroute method for starting a route',1),(8975,') before you stop the route, you must unregister the current exchange from the in-flight registry, which otherwise would prevent camel from stopping the route, because it detects there is an exchange in progress',1),(8976,'the source code for the book contains this example, which you can try from the chapter13/startup directory using the following maven goal:mvn test -dtest=manualroutewithstoptesteven though the fix to stop the route was simple, using the inlined proce...',1),(8977,'it would be better to keep the business logic separated from the stopping logic',1),(8978,'this can be done with a feature called oncompletion',1),(8979,'using oncompletiononcompletion is a feature that allows you to do additional routing after the original route is done',1),(8980,'the classic example would be to send an email alert if a route fails, but it has a broad range of uses',1),(8981,'listing 13',1),(8982,'3 after a file has been processed, the route is stopped    www',1),(8983,'info421starting and stopping routes at runtime instead of using the inlined processor to stop the route, you can use oncompletion in the routebuilder to process the stoprouteprocessor class containing the logic to stop the route',1),(8984,'this is shown in bold in the following code:public void configure() throws exception {    oncompletion()',1),(8985,'process(new stoprouteprocessor(\"manual\"));    from(\"file://target/inventory/manual',1),(8986,'maxmessagesperpoll=1\")',1),(8987,'tokenize(\"\\n\"))',1),(8988,'class)',1),(8989,'to(\"direct:update\"); }the implementation of the stoprouteprocessor is simple, as shown here:public class stoprouteprocessor implements processor {    private final string name;    public stoprouteprocessor(string name) {        this',1),(8990,'name = name;    }    public void process(exchange exchange) throws exception {        exchange',1),(8991,'getinflightrepository()',1),(8992,'stoproute(name);    } }this improves the readability of the route, as it’s shorter and doesn’t mix high-level routing logic with low-level implementation logic',1),(8993,'by using oncompletion, the stopping logic has been separated from the original route',1),(8994,'scopes can be used to define oncompletions at different levels',1),(8995,'camel supports two scopes: context scope (high level) and route scope (low level)',1),(8996,'in the preceding example, you used context scope',1),(8997,'if you wanted to use route scope, you’d have to define it within the route as follows:from(\"file://target/inventory/manual',1),(8998,'maxmessagesperpoll=1\")',1),(8999,'process(new stoprouteprocessor(\"manual\"))',1),(9000,'tokenize(\"\\n\"))',1),(9001,'class)',1),(9002,'end;notice the use of',1),(9003,'you have to do this when using route scope so camel knows which pieces belong to the additional route and which to the original route',1),(9004,'this is the same principle as when you use onexception at route scope',1),(9005,'info422 chapter 13 running and deploying cameltip oncompletion also supports filtering using the onwhen predicate so that you can trigger the additional route only if the predicate is true',1),(9006,'in addition, oncompletion can be configured to only trigger when the route completes successfully or when it fails by using the oncompleteonly or onfailureonly options',1),(9007,'for example, you can use onfailureonly to build a route that sends an alert email to support personnel when a route fails',1),(9008,'the source code for the book contains this example in the chapter13/startup directory',1),(9009,'you can try it using the following maven goal:mvn test -dtest=manualroutewithoncompletiontestwe’ve now covered how to stop a route at runtime using the camelcontext api',1),(9010,'we’ll now look at another feature called routepolicy, which can also be used to control the lifecycle of routes at runtime',1),(9011,'2 using routepolicy to start and stop routes at runtimea routepolicy is a policy that can control routes at runtime',1),(9012,'for example, a routepolicy can control whether or not a route should be active',1),(9013,'but you aren’t limited to such scenarios—you can implement any kind of logic you wish',1),(9014,'routepolicy is an interface that defines two callback methods camel will automatically invoke at runtime:void onexchangebegin(route route, exchange exchange); void onexchangedone(route route, exchange exchange);the idea is that you implement this int...',1),(9015,'you’re free to implement whatever logic you want in these callbacks',1),(9016,'for convenience, camel provides the org',1),(9017,'routepolicysupport class, which you can use as a base class to extend when implementing your custom policies',1),(9018,'let’s build a simple example usingroutepolicy to demonstrate how to flip between two routes, so only one route is active at any time',1),(9019,'5 shows this principle',1),(9020,'as you can see in this figure, theroutepolicy is being used to control the two routes, starting and stopping them so only one is active at a time',1),(9021,'the following listing shows how this can be implemented',1),(9022,'startedstoppedroute 1stoppedstartedroute 2routepolicychanges changesfigure 13',1),(9023,'5 routepolicy changes the active state between the two routes so only one route is active at any time',1),(9024,'info423starting and stopping routes at runtimepublic class fliproutepolicy extends routepolicysupport {    private final string name1;    private final string name2;    public fliproutepolicy(string name1, string name2) {             this',1),(9025,'name2 = name2;    }    @override    public void onexchangedone(route route, exchange exchange) {        string stop = route',1),(9026,'equals(name1)',1),(9027,'name1 : name2;        string start = route',1),(9028,'equals(name1)',1),(9029,'getinflightrepository()',1),(9030,'stoproute(stop);                              context',1),(9031,'startroute(start);                        } catch (exception e) {            getexceptionhandler()',1),(9032,'handleexception(e);        }    } }in the constructor, you identify the names of the two routes to flip b',1),(9033,'as you extend the routepolicysupport class, you only override the onexchangedone method, as the flipping logic should be invoked when the route is done',1),(9034,'you then compute which of the two routes to stop and start with the help of the route parameter, which denotes the current active route',1),(9035,'having computed that, you then use camelcontext to flip the routes c',1),(9036,'if an exception is thrown, you let the exceptionhandler take care of it, which by default will log the exception',1),(9037,'to use fliproutepolicy, you must assign it to the two routes',1),(9038,'in the java dsl, this is done using the routepolicy method, as shown in the following routebuilder:public void configure() throws exception {    routepolicy policy = new fliproutepolicy(\"foo\", \"bar\");    from(\"timer://foo\")',1),(9039,'constant(\"foo message\")',1),(9040,'constant(\"bar message\")',1),(9041,'to(\"mock:bar\"); }if you’re using spring xml, you can use routepolicy as shown here:<bean id=\"flippolicy\" class=\"camelinaction',1),(9042,'fliproutepolicy\">    <constructor-arg index=\"0\" value=\"foo\"/>    <constructor-arg index=\"1\" value=\"bar\"/> </bean>listing 13',1),(9043,'4 a routepolicy that flips two routes being active at runtimeidentifies routes to flipbc flips the two routes    www',1),(9044,'info424 chapter 13 running and deploying camel<camelcontext xmlns=\"http://camel',1),(9045,'org/schema/spring\">    <route id=\"foo\" routepolicyref=\"flippolicy\">        <from uri=\"timer://foo\"/>        <setbody><constant>foo message</constant></setbody>        <to uri=\"log:foo\"/>        <to uri=\"mock:foo\"/>    </route>    <route id=\"bar\" rout...',1),(9046,'the source code for the book contains this example in the chapter13/routepolicy directory',1),(9047,'you can try it using the following maven goals:mvn test -dtest=fliproutepolicyjavadsltest mvn test -dtest=fliproutepolicyspringxmltestwhen running either of the examples, you should see the two routes being logged interchangeably (foo and bar)',1),(9048,'info  foo - exchange[bodytype:string, body:foo message] info  bar - exchange[bodytype:string, body:bar message] info  foo - exchange[bodytype:string, body:foo message] info  bar - exchange[bodytype:string, body:bar message] info  foo - exchange[bodyt...',1),(9049,'it’s time to learn about shutting down camel, which is more complex than it sounds',1),(9050,'3 shutting down camelthe new inventory application at rider auto parts is scheduled to be in production at the end of the month',1),(9051,'you’re on the team to ensure its success and help run the final tests before it’s handed over to production',1),(9052,'these tests also cover reliably shutting down the application',1),(9053,'shutting down the camel application is complex because there may be numerous in-flight messages being processed',1),(9054,'shutting down while messages are in flight may harm your business because those messages could potentially be lost',1),(9055,'so the goal of shutting down a camel application reliably is to shut it down when its quiet—when there are no in-flight messages',1),(9056,'all you have to do is find this quiet moment',1),(9057,'this is hard to do because while you wait for the current messages to complete, the application may take in new messages',1),(9058,'you have to stop taking in new messages while the current messages are given time to complete',1),(9059,'this process is known as graceful shutdown, which means shutting down in a reliable and controlled manner',1),(9060,'1 graceful shutdownwhen camelcontext is being stopped, which happens when its stop() method is invoked, it uses a strategy to shut down',1),(9061,'this strategy is defined in the shutdownstrategy interface',1),(9062,'the default implementation of this shutdownstrategy interface uses the graceful shutdown technique',1),(9063,'for example, when you stop the rider auto parts example, you’ll see these log lines:defaultcamelcontext       - apache camel 2',1),(9064,'0 is shutting down defaultshutdownstrategy   - starting to graceful shutdown routes                            (timeout 300 seconds)defaultshutdownstrategy   - route: update shutdown complete',1),(9065,'defaultshutdownstrategy   - route: file suspended and shutdown deferred',1),(9066,'defaultshutdownstrategy   - route: webservice shutdown complete',1),(9067,'defaultshutdownstrategy   - route: file shutdown complete',1),(9068,'defaultshutdownstrategy   - graceful shutdown of routes completed in                            0 secondsdefaultinflightrepository - shutting down with no inflight exchanges',1),(9069,'422 seconds defaultcamelcontext       - apache camel 2',1),(9070,'0 is shutdownthis tells you a few things',1),(9071,'you can see the graceful shutdown is using a 300-second timeout',1),(9072,'this is the maximum time camel allows for shutting down gracefully before it starts to shut down more aggressively by forcing routes to stop immediately',1),(9073,'the default value is 300 seconds, which you can configure on the camelcontext',1),(9074,'for example, to use 20 seconds as the default timeout value, you can do as follows:camelcontext',1),(9075,'settimeout(20);doing this in spring xml requires a bit more work, because you have to define a spring bean to set the timeout value:<bean id=\"shutdown\" class=\"org',1),(9076,'defaultshutdownstrategy\">    <property name=\"timeout\" value=\"20\"/> </bean>notice that the timeout value is in seconds',1),(9077,'then camel logs the progress of the routes as they shut down, one by one, according to the order in which they were started',1),(9078,'notice that the file route is suspended and deferred, and then later is shut down',1),(9079,'this is a little glimpse of the complex logic the graceful shutdown process uses to shut down camel in a reliable manner',1),(9080,'we’ll cover what suspension and defer mean in a moment',1),(9081,'at the end, camel logs the completion of the graceful shutdown, which in this case was really fast and completed in less than one second',1),(9082,'camel also logs whether there were any in-flight messages just before it stops completely',1),(9083,'if camel did not complete the graceful shutdown, it would log at warn level how many in-flight messages were still in progress:warn - defaultinflightrepository - shutting down while there are still                                   5 inflight exchanges',1),(9084,'info426 chapter 13 running and deploying camelshutting down the rider auto parts applicationat rider auto parts, you’re in the final testing of the application before it’s handed over to production',1),(9085,'one of the tests is based on processing a big inventory file, and you wanted to test what happens if you shut down camel while it was working on the big file',1),(9086,'you expected camel would continue processing the big file and only shut down when the file was completed',1),(9087,'but the log shows something else',1),(9088,'at first, you see the usual logging about the shutdown in progress:defaultshutdownstrategy - starting to graceful shutdown routes                          (timeout 300 seconds)defaultshutdownstrategy - route: update shutdown complete',1),(9089,'defaultshutdownstrategy - route: file suspended and shutdown deferred',1),(9090,'defaultshutdownstrategy - route: webservice shutdown complete',1),(9091,'then there is a log line indicating that camel has noticed the one in-flight exchange, which is the big file',1),(9092,'this is expected behavior:defaultshutdownstrategy - waiting as there are still 1 inflight and               pending exchanges to complete before we can shutdownthen the application logs the progress of the inventory update, which should happen for ea...',1),(9093,'updateinventoryinput@e9d110]warn - directproducer - no consumers available on endpoint: endpoint[direct://update] to process: exchange[message: camelinaction',1),(9094,'updateinventoryinput@5735c4]finally, you see the last log lines, which report the end of the shutdown',1),(9095,'defaultshutdownstrategy   - route: file shutdown complete',1),(9096,'defaultshutdownstrategy   - graceful shutdown of routes completed in                            13 secondsdefaultinflightrepository - shutting down with no inflight exchanges',1),(9097,'742 seconds defaultcamelcontext       - apache camel 2',1),(9098,'0 is shutdownso what went wrong',1),(9099,'the clues have been shown in the logs',1),(9100,'first, you noticed the warn logs, which indicated that the direct:update consumer had been stopped',1),(9101,'this consumer is from the first route, which has startup order 1:from(\"direct:update\")',1),(9102,'method=updateinventory\");you then noticed that camel stops this route as the first route during the shutdown process:defaultshutdownstrategy - route: update shutdown complete',1),(9103,'info427shutting down camelthis is a shared route that the other routes depend upon, as illustrated in figure 13',1),(9104,'that’s why it needed to be started before the other routes',1),(9105,'now the problem is that this route is also stopped before the other routes',1),(9106,'you’ve got a catch-22 situation',1),(9107,'the good news is that it’s possible to remedy this in camel',1),(9108,'what you need to do is somehow tell camel to defer shutting down this shared route',1),(9109,'this is done using the shutdownroute option, which was listed in table 13',1),(9110,'all you have to do is add the option in the route as shown in bold here:from(\"direct:update\")',1),(9111,'method=updateinventory\");the same route in spring xml is as follows:<route id=\"update\" startuporder=\"1\" shutdownroute=\"defer\">    <from uri=\"direct:update\"/>    <to uri=\"bean:inventoryservice',1),(9112,'method=updateinventory\"/> </route>now when you run the test, the application shuts down in a reliable manner',1),(9113,'the log shows that camel detects that the big file is still in progress and patiently waits:defaultshutdownstrategy - waiting as there are still 1 inflight       and pending exchanges to complete before we can shutdown inventory 58026 updated invento...',1),(9114,'5 has been improved to handle the example we’ve just covered',1),(9115,'camel now always defers direct endpoints, which means you no longer have to configure this manually',1),(9116,'the example illustrates the principle of how to shut down a camel application in a reliable manner',1),(9117,'the source code for the book contains this example in the chapter13/shutdown directory',1),(9118,'you can try it by using the following maven goals:mvn test -dtest=gracefulshutdownbigfiletest mvn test -dtest=gracefulshutdownbigfilexmltestas you’ve just learned, camel end users are responsible for configuring routes correctly to support reliable s...',1),(9119,'some may say this is a trade-off, but we, the camel team, think of it as flexibility and don’t believe computer logic can substitute for human logic in ensuring a reliable shutdown',1),(9120,'we think it’s best to give camel users the power to configure their routes to support their use cases',1),(9121,'info428 chapter 13 running and deploying cameljvmjdkcameljarsother jarscamelcontextyour java applicationfigure 13',1),(9122,'6 camel embedded in a standalone java applicationabout stopping and shutting downcamel will leverage the graceful shutdown mechanism when it stops or shuts down routes',1),(9123,'that means the example in listing 13',1),(9124,'3 will stop the route in a graceful manner',1),(9125,'as a result, you can reliably stop routes at runtime, without the risk of losing inflight messages',1),(9126,'the difference between using the stoproute and shutdownroute methods is that the latter will also unregister the route from management (jmx)',1),(9127,'use stoproute when you want to be able to start the route again',1),(9128,'only use shutdownroute if the route should be permanently removed',1),(9129,'that’s all there is to shutting down camel',1),(9130,'it’s now time to review some of the deployment strategies that are possible',1),(9131,'4 deploying camelcamel is described as a lightweight and embeddable integration framework',1),(9132,'this means that it supports more deployment strategies and flexibility than traditional esbs and application servers',1),(9133,'camel can be used in a wide range of runtime environments, from standalone java applications, to web containers, to the cloud',1),(9134,'in this section, we’ll look at four different deployment strategies that are possible with camel and present their strengths and weaknesses',1),(9135,'■ embedding camel in a java application■ running camel in a web environment on apache tomcat■ running camel inside jboss application server■ running camel in an osgi container such as apache karafthese four deployment strategies are the common ways o...',1),(9136,'1 embedded in a java applicationit’s appealing to embed camel in a java application if you need to communicate with the outside world',1),(9137,'by bringing camel into your application, you can benefit from all the transports, routes, eips, and so on, that camel offers',1),(9138,'6 shows camel embedded in a standard java application',1),(9139,'in the embedded mode, you must add to the classpath all the necessary camel and third-party jars needed by the underlying transports',1),(9140,'because camel is built with maven, you can use maven for your own project and benefit from its dependency-management system',1),(9141,'we discussed building camel projects with maven in chapter 11',1),(9142,'bootstrapping camel for your code is easy',1),(9143,'in fact, you did that in your first ride on the camel in chapter 1',1),(9144,'all you need to do is create a camelcontext and start it, as shown in the following listing',1),(9145,'info429deploying camelpublic class filecopierwithcamel {    public static void main(string args',1),(9146,') throws exception {        camelcontext context = new defaultcamelcontext();               context',1),(9147,'addroutes(new routebuilder() {            public void configure() {                from(\"file:data/inbox\")',1),(9148,'stop();    } }it’s important to keep a reference to camelcontext for the lifetime of your application, because you’ll need to perform a shutdown of camel',1),(9149,'as you may have noticed in listing 13',1),(9150,'5, the code execution continues after starting the camelcontext',1),(9151,'to avoid shutting down your application immediately, the listing includes code to sleep for 10 seconds',1),(9152,'in your application, you’ll need to use a different means to let your application continue and only shut down when requested to do so',1),(9153,'let’s look at the rider auto parts application illustrated in figure 13',1),(9154,'embedding the rider auto parts example in a java applicationthe rider auto parts camel application can be run as a standalone java application',1),(9155,'because the application is using spring xml files to set up camel, you just need to start spring to start the application',1),(9156,'starting spring from a main class can be done as follows:public class inventorymain {    public static void main(string[] args) throws exception {        string filename = \"meta-inf/spring/camel-context',1),(9157,'xml\";        abstractxmlapplicationcontext spring =               new classpathxmlapplicationcontext(filename);        spring',1),(9158,'sleep(10000);        spring',1),(9159,'stop();        spring',1),(9160,'destroy();    } }to start spring, you create an applicationcontext, which in the preceding example means loading the spring xml file from the classpath',1),(9161,'this code also reveals the problem of having the main method wait until you terminate the application',1),(9162,'the preceding code uses thread',1),(9163,'sleep to wait 10 seconds before terminating the application',1),(9164,'to remedy this, camel provides a main class that you can leverage instead of writing your own class',1),(9165,'you can change the previous inventorymain class to leverage this main class as follows:listing 13',1),(9166,'5 bootstrapping camel in your java application    www',1),(9167,'main;public class inventorymain {    public static void main(string[] args) throws exception {        main main = new main();        main',1),(9168,'setapplicationcontexturi(\"meta-inf/spring/camel-context',1),(9169,'start();    } }this approach also solves the issue of handling the lifecycle of the application',1),(9170,'by enabling hang-up support, you tell camel to shut down gracefully when the jvm is being terminated, such as when the ctrl-c key combination is pressed',1),(9171,'you can obviously also stop the camel application by invoking the stop method on the main instance',1),(9172,'the source code for the book contains this example in the chapter13/standalone directory',1),(9173,'you can try it out using the following maven goal:mvn compile exec:javatip you may not need to write your own main class',1),(9174,'main class can be used directly',1),(9175,'it has parameters to dictate which spring xml file it should load',1),(9176,'by default, it loads all xml files from the classpath in the meta-inf/spring location, so by dropping your spring xml file in there, you don’t even have to pass any arguments to the main class',1),(9177,'you can start it directly',1),(9178,'2 summarizes the pros and cons of embedding camel in a standalone java application',1),(9179,'you now know how to make your standalone application leverage camel',1),(9180,'let’s look at what you can do for your web applications',1),(9181,'2 embedded in a web applicationembedding camel in a web application brings the same benefits as were mentioned in section 13',1),(9182,'camel provides all you need to connect to your favorite web container',1),(9183,'if you work in an organization, you may have existing infrastructure to be used for deploying your camel applications',1),(9184,'deploying camel in such a well-known environment gives you immediate support for installing, managing, and monitoring your applications',1),(9185,'2 pros and cons of embedding camel in a standalone java applicationpros cons■ gives flexibility to deploy just what’s needed■ allows you to embed camel in any standard java application■ works well with thick client applications, such as a swing or ec...',1),(9186,'info431deploying camel when camel is embedded in a web application, as shown in figure 13',1),(9187,'7, you need to make sure all jars are packaged in the war file',1),(9188,'if you use maven, this will be done automatically',1),(9189,'the camel instance embedded in your web application is bootstrapped by spring',1),(9190,'by leveraging spring, which is such a ubiquitous framework, you let end users use well-known approaches for deployment',1),(9191,'this also conveniently ties camel’s lifecycle with spring’s lifecycle management and ensures that the camel instance is properly started and stopped in the web container',1),(9192,'the following code demonstrates that you only need a standard spring context listener in the web',1),(9193,'xml file to bootstrap spring and thereby camel',1),(9194,'xml version=\"1',1),(9195,'> <web-app xmlns=\"http://java',1),(9196,'com/xml/ns/javaee\"         xmlns:xsi=\"http://www',1),(9197,'org/2001/xmlschema-instance\"         xsi:schemalocation=\"           http://java',1),(9198,'com/xml/ns/javaee           http://java',1),(9199,'com/xml/ns/javaee/web-app_2_5',1),(9200,'xsd\"           version=\"2',1),(9201,'5\">    <listener>        <listener-class>            org',1),(9202,'contextloaderlistener        </listener-class>    </listener> </web-app>this context listener also takes care of shutting down camel properly when the web application is stopped',1),(9203,'spring will, by default, load the spring xml file from the webinf folder using the name applicationcontext',1),(9204,'in this file, you can embed camel, as shown in listing 13',1),(9205,'specifying the location of your spring xml fileif you want to use another name for your spring xml file, you’ll need to add a context parameter which specifies the filename as follows: <context-param>    <param-name>contextconfiglocation</param-name>...',1),(9206,'xml</param-value> </context-param>jdkservlet apicameljarsother jarscamelcontextyour web applicationjvmweb containerfigure 13',1),(9207,'xml version=\"1',1),(9208,'> <beans xmlns=\"http://www',1),(9209,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(9210,'org/2001/xmlschema-instance\"       xmlns:camel=\"http://camel',1),(9211,'org/schema/spring\"       xsi:schemalocation=\"         http://www',1),(9212,'org/schema/beans         http://www',1),(9213,'org/schema/beans/spring-beans',1),(9214,'xsd         http://camel',1),(9215,'org/schema/spring         http://camel',1),(9216,'org/schema/spring/camel-spring',1),(9217,'xsd\">    <import resource=\"camel-cxf',1),(9218,'xml\"/>                              <bean id=\"inventoryservice\" class=\"camelinaction',1),(9219,'inventoryservice\"/>    <bean id=\"inventoryroute\" class=\"camelinaction',1),(9220,'inventoryroute\"/>    <camelcontext xmlns=\"http://camel',1),(9221,'org/schema/spring\">        <routebuilder ref=\"inventoryroute\"/>    </camelcontext> </beans>listing 13',1),(9222,'6 is a regular spring xml file in which you can use the <import> tag to import other xml files',1),(9223,'for example, this is done by having cxf defined in the camelcxf',1),(9224,'camel, itself, is embedded using the <camelcontext> tag',1),(9225,'the source code for the book contains this example in the chapter13/war directory',1),(9226,'you can try it out by using the following maven goal:mvn jetty:runif you run this maven goal, a jetty plugin is used to quickly boot up a jetty web container running the web application',1),(9227,'to use the jetty plugin in your projects, you must remember to add it to your pom',1),(9228,'xml file in the <build><plugins> section:<plugin>    <groupid>org',1),(9229,'jetty</groupid>    <artifactid>maven-jetty-plugin</artifactid>    <version>7',1),(9230,'v20100715</version> </plugin>if you run this goal, you should notice in the console that jetty has been started:2010-05-28 [main] info  defaultcamelcontext- apache camel 2',1),(9231,'0 (camelcontext: camelcontext) started 2010-05-28 [main] info  contextloader- root webapplicationcontext: initialization completed in 3198 ms 2010-05-28 info::started selectchannelconnector@0',1),(9232,'0:8080 [info] started jetty serverlet’s look at how you can run camel as a web application in apache tomcat',1),(9233,'deploying to apache tomcatto package the application as a war file, you can run the mvn package command, which creates the war file in the target directory',1),(9234,'yes, it’s that easy with maven',1),(9235,'you want to leverage the hot deployment of apache tomcat, so you must first start it',1),(9236,'here’s how you can start it on a unix-based system, such as our mac os x laptop, using the bin/startup',1),(9237,'sh script:listing 13',1),(9238,'xml file with camel embeddedimportscxf fromanotherxml fileb    www',1),(9239,'info433deploying cameldavsclaus:~/apache-tomcat-6',1),(9240,'26$ bin/startup',1),(9241,'sh using catalina_base:   /users/davsclaus/apache-tomcat-6',1),(9242,'26 using catalina_home:   /users/davsclaus/apache-tomcat-6',1),(9243,'26 using catalina_tmpdir: /users/davsclaus/apache-tomcat-6',1),(9244,'26/temp using jre_home:        /system/library/frameworks/javavm',1),(9245,'framework/versions/1',1),(9246,'5/homeusing classpath:       /users/davsclaus/apache-tomcat-6',1),(9247,'26 /bin/bootstrap',1),(9248,'jarthis will start tomcat in the background, so you need to tail the log file to see what happens:davsclaus:~/apache-tomcat-6',1),(9249,'26$ tail -f logs/catalina',1),(9250,'hostconfig deploydirectory info: deploying web application directory root may 28, 2010 5:37:53 pm org',1),(9251,'http11protocol start info: starting coyote http/1',1),(9252,'channelsocket init info: jk: ajp13 listening on /0',1),(9253,'jkmain start info: jk running id=0 time=0/17  config=null may 28, 2010 5:37:53 pm org',1),(9254,'catalina start info: server startup in 4351 msto deploy the application, you need to copy the war file to the apache tomcat webapps directory: cp target/riderautoparts-war-1',1),(9255,'26/webapps/then apache tomcat should show the application being started in the log file',1),(9256,'you should see the familiar logging of camel being started:2010-05-28 [gine[catalina]]] info defaultcamelcontext - started 3 routes 2010-05-28 [gine[catalina]]] info defaultcamelcontext- apache camel 2',1),(9257,'0 (camelcontext: camelcontext) started 2010-05-28 [gine[catalina]]] info contextloader- root webapplicationcontext: initialization completed in 2812 msnow you need to test that the deployed application runs as expected',1),(9258,'this can be done by sending a web service request using soapui, as shown in figure 13',1),(9259,'doing this requires you to know the url  to the wsdl the web service runs at, which is http://localhost:9000/inventory',1),(9260,'wsdl',1),(9261,'8 using soapui testing the web service from the deployed application in apache tomcat    www',1),(9262,'info434 chapter 13 running and deploying camelthe web service returns “ok” as its reply, and you can also see from the log file that the application works as expected, outputting the inventory being updated:inventory 4444 updatedthere’s another great...',1),(9263,'in a standalone java deployment scenario, you have to rely on the jetty transport, but in the web deployment scenario, the container already has its socket management, thread pools, tuning, and monitoring facilities',1),(9264,'camel can leverage this if you use the servlet transport for your inbound http endpoints',1),(9265,'in the previously deployed application, you let apache cxf rely on the jetty transport',1),(9266,'let’s change this to leverage the existing servlet transports provided by apache tomcat',1),(9267,'using apache tomcat for http inbound endpointswhen using camel in an existing servlet container, such as apache tomcat, you may have to adjust camel components in your application to tap into the servlet container',1),(9268,'in the rider auto parts application, it’s the cxf component you must adjust',1),(9269,'first, you have to add cxfservlet to the web',1),(9270,'xml version=\"1',1),(9271,'> <web-app xmlns=\"http://java',1),(9272,'com/xml/ns/javaee\"         xmlns:xsi=\"http://www',1),(9273,'org/2001/xmlschema-instance\"         xsi:schemalocation=\"           http://java',1),(9274,'com/xml/ns/javaee           http://java',1),(9275,'com/xml/ns/javaee/web-app_2_5',1),(9276,'xsd\"           version=\"2',1),(9277,'5\">    <listener>        <listener-class>            org',1),(9278,'contextloaderlistener        </listener-class>    </listener>    <servlet>        <servlet-name>cxfservlet</servlet-name>        <servlet-class>            org',1),(9279,'transport',1),(9280,'cxfservlet        </servlet-class>    </servlet>    <servlet-mapping>        <servlet-name>cxfservlet</servlet-name>        <url-pattern>/services/*</url-pattern>    </servlet-mapping> </web-app>maven users need to adjust the pom',1),(9281,'xml file to depend upon the http transport instead of jetty, as follows:listing 13',1),(9282,'cxf</groupid>    <artifactid>cxf-rt-transports-http</artifactid>    <version>2',1),(9283,'11</version> </dependency>next, you must adjust the camel-cxf',1),(9284,'xml file, as shown in the following listing',1),(9285,'<beans xmlns=\"http://www',1),(9286,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(9287,'org/2001/xmlschema-instance\"       xmlns:cxf=\"http://camel',1),(9288,'org/schema/cxf\"       xsi:schemalocation=\"         http://www',1),(9289,'org/schema/beans         http://www',1),(9290,'org/schema/beans/spring-beans',1),(9291,'xsd         http://camel',1),(9292,'org/schema/cxf         http://camel',1),(9293,'org/schema/cxf/camel-cxf',1),(9294,'xsd\">    <import resource=\"classpath:meta-inf/cxf/cxf',1),(9295,'xml\"/>    <import resource=\"classpath:meta-inf/cxf/cxf-extension-soap',1),(9296,'xml\"/>    <import resource=        \"classpath:meta-inf/cxf/cxf-servlet',1),(9297,'xml\"/>                        <cxf:cxfendpoint id=\"inventoryendpoint\"        address=\"/inventory\"                               serviceclass=\"camelinaction',1),(9298,'inventoryendpoint\"/> </beans>to use apache cxf in a servlet container, you have to import the cxf-servlet',1),(9299,'xml resource b',1),(9300,'this exposes the web service via the servlet container, which means the endpoint address has to be adjusted to a relative context path c',1),(9301,'in the previous example, the web service was available at http://localhost:9000/ inventory',1),(9302,'wsdl',1),(9303,'by using apache tomcat, the web service is now exposed at this address:notice that the tcp port is 8080, which is the default apache tomcat setting',1),(9304,'the source code for the book contains this example in the chapter13/war-servlet directory',1),(9305,'you can package the application using mvn package and then copy the riderautoparts-war-servlet-1',1),(9306,'war file to the webapps directory of apache tomcat to hotdeploy the application',1),(9307,'then the web service should be available at this address: http://localhost:8080/riderautoparts-war-servlet-1',1),(9308,'0/services/inventory',1),(9309,'wsdl',1),(9310,'listing 13',1),(9311,'8 setting up the camel cxf component to tap into apache tomcatrequired import when using servletbweb service endpoint addresschttp://localhost:8080/context/services/inventory',1),(9312,'wsdlweb application contextcxf servlet mappingweb service address path    www',1),(9313,'info436 chapter 13 running and deploying camelnote camel also provides a lightweight alternative to using cxf in the servlet container',1),(9314,'the servlet component that we discussed in section 7',1),(9315,'2 of chapter 7 allows you to consume http requests coming into the servlet container in much the same way as you saw here with cxf',1),(9316,'you can find more information on the apache camel website at http://camel',1),(9317,'org/servlet',1),(9318,'3 lists the pros and cons of the web application deployment model of camel',1),(9319,'embedding camel in a web application is a popular, proven, and powerful way to deploy camel',1),(9320,'another choice for running camel applications is using an application server such as jboss application server',1),(9321,'3 embedded in jboss application servera common way of deploying camel applications in jboss application server (jboss as) is using the web deployment model we discussed in the previous section',1),(9322,'but jboss as has a pesky classloading mechanism, so you need to leverage a special camel jboss component to remedy this',1),(9323,'this component isn’t provided out of the box at the apache camel distribution, because of license implications with jboss as’s lgpl license',1),(9324,'this component is hosted at camel extra (http://code',1),(9325,'com/p/ camel-extra/), which is a project site for additional camel components that can’t be shipped from apache',1),(9326,'in the true open source spirit, you can download the source code and build the component yourself, but the source code for the book also contains this component in the example located in the chapter13/war-jboss directory',1),(9327,'this example is based on the previous example with two minor additions',1),(9328,'first, the camel-jboss-2',1),(9329,'jar is added to the src/main/webapp/web-inf/lib directory, which ensures that this jar is included when you package the application using mvn package',1),(9330,'the second change is to leverage the jboss-specific classloader, which is done by adding the following bean definition in the applicationcontext',1),(9331,'xml file:<bean id=\"jbossresolver\"      class=\"org',1),(9332,'jbosspackagescanclassresolver\"/>that’s all there is to it',1),(9333,'to deploy the application to jboss, you start it and copy the war file into the server/ default/deploy directory',1),(9334,'for example, on our laptop, jboss as 5',1),(9335,'1 is started as follows: davsclaus:~/jboss$ bin/run',1),(9336,'3 pros and cons of embedding camel in a web applicationpros cons■ taps into the servlet container■ lets the container manage the camel lifecycle■ benefits the management and monitoring capabilities of the servlet container■ provides familiar runtime ...',1),(9337,'info437camel and osgiafter a while, jboss as is ready, and this is logged to the console:15:16:43,882 info [serverimpl] jboss (microcontainer) [5',1),(9338,'ga (build: svntag=jboss_5_1_0_ga date=200905221053)] started in 27s:452msthen the war file is copied:cp target/riderautoparts-war-jboss-1',1),(9339,'war ~/jboss/server/default/deployyou can then keep an eye on the jboss console as it outputs the progress of the deployment',1),(9340,'for example, camel reports that it has picked up the jboss classloader, as shown here:15:18:42,636 info [stdout] 2010-05-30 15:18:42,636 [main] info camelcontextfactorybean - using custom packagescanclassresolver: org',1),(9341,'jbosspackagescanclassresolver@75d8afjboss as uses an embedded apache tomcat as the servlet container, which means the web service of the application is available in a familiar location:http://localhost:8080/riderautoparts-war-jboss-1',1),(9342,'0/services/inventory',1),(9343,'wsdltable 13',1),(9344,'4 lists the pros and cons of deploying camel in jboss application server',1),(9345,'deploying camel as a web application in jboss as is a fairly easy solution',1),(9346,'all you have to remember is to use the special camel jboss component to let the classloading work',1),(9347,'the last strategy we’ll cover is in a totally different ballpark: using osgi',1),(9348,'osgi is a fairly new deployment model in the java enterprise space and brings promises of modularity to the extreme',1),(9349,'5 camel and osgiosgi is a layered module system for the java platform that offers a complete dynamic component model',1),(9350,'it’s a truly dynamic environment where components can come and go without requiring a reboot (hot deployment)',1),(9351,'apache camel is osgi-ready, in the sense that all the camel jar files are osgi-compliant and are deployable in osgi containers',1),(9352,'this section will show you how to prepare and deploy the rider auto parts application in the apache karaf osgi runtime',1),(9353,'karaf provides functionality on top of thetable 13',1),(9354,'4 pros and cons of embedding camel in jboss aspros cons■ taps into the jboss as container■ allows your application to leverage the facilities provided by the java ee application server■ lets the jboss as container manage camel’s lifecycle■ benefits t...',1),(9355,'info438 chapter 13 running and deploying camelosgi container, such as hot deployment, provisioning, local and remote shells, and many other goodies',1),(9356,'you can choose between apache felix or eclipse equinox for the actual osgi container',1),(9357,'the example presented here is included with the source code for the book in the chapter13/osgi directory',1),(9358,'note in this book, we won’t go deep into the details of osgi, which is a complex topic',1),(9359,'the basics are covered on wikipedia (http://en',1),(9360,'org/ wiki/osgi), and if you’re interested in more information, we highly recommend osgi in action, by richard s',1),(9361,'hall, karl pauls, stuart mcculloch, and david savage (manning)',1),(9362,'for more information on the apache karaf osgi runtime, see the karaf website: http://karaf',1),(9363,'the first thing you need to do with the rider auto parts application is make it osgicompliant',1),(9364,'this involves setting up maven to help prepare the packaged jar file so it includes osgi metadata in the manifest',1),(9365,'xml file, you have to set the packaging element to bundle, which means the jar file will be packaged as an osgi bundle:<packaging>bundle</packaging>to generate the manifest',1),(9366,'mf entry in the jar file, you can use the apache felix maven bundle plugin, which is added to the pom',1),(9367,'xml file under the <build> section:<build>  <plugin>    <groupid>org',1),(9368,'felix</groupid>    <artifactid>maven-bundle-plugin</artifactid>    <version>2',1),(9369,'0</version>    <extensions>true</extensions>    <configuration>      <instructions>        <bundle-name>${project',1),(9370,'artifactid}</bundle-name>        <bundle-symbolicname>riderautoparts-osgi</bundle-symbolicname>        <export-package>            camelinaction,            camelinaction',1),(9371,'inventory        </export-package>        <import-package>*</import-package>        <dynamicimport-package>*</dynamicimport-package>        <implementation-title>rider auto parts osgi</implementation-title>        <implementation-version>${project',1),(9372,'version}</implementation-version>      </instructions>    </configuration>  </plugin> </build>the interesting part of the maven-bundle-plugin is its ability to set the packages to be imported and exported',1),(9373,'the plugin is set to export two packages: camelinaction and camelinaction',1),(9374,'the camelinaction package contains the inventoryroute    www',1),(9375,'info439camel and osgicamel route, and it needs to be accessible by camel so it can load the routes when the application is started',1),(9376,'inventory package contains the generated source files needed by apache cxf when it exposes the web service',1),(9377,'in terms of imports, the preceding code defines it as dynamic by using an asterisk, which means the osgi container will figure it out',1),(9378,'when needed, you can specify the imports by package name',1),(9379,'the source code for the book contains this example in the chapter13/osgi directory',1),(9380,'if you run the mvn package goal, you can see the manifest',1),(9381,'mf entry being generated in the target/classes/meta-inf directory',1),(9382,'you have now set up maven to build the jar file as an osgi bundle, which can be deployed to the container',1),(9383,'the next step is to download and install apache karaf',1),(9384,'2 installing and running apache karaf for this example, you can download and install the latest version of apache karaf from http://karaf',1),(9385,'(at the time of writing, this was apache karaf 2',1),(9386,') installing is just a matter of unzipping the zip file',1),(9387,'to run apache karaf, start it from the command line using one of these two commands:bin/karaf        (unix) bin/karaf',1),(9388,'bat    (windows)this should start up karaf and display a logo when it’s ready',1),(9389,'this will run in a shell mode, which means you can enter commands to manage the container',1),(9390,'now you need to install camel and apache cxf before you install the rider auto parts application',1),(9391,'karaf makes installing easier by using features, which are like super bundles that contain a set of bundles installed as a group',1),(9392,'installing features requires you to add the camel feature descriptions to karaf, which you do by typing the following command in the shell:features:addurl mvn:org',1),(9393,'0/xml/featuresapache karaf 2',1),(9394,'1 issue when using apache cxfapache karaf version 2',1),(9395,'1 has an issue that requires you to adjust its configuration in order to use apache cxf',1),(9396,'you need to download a file and save it in the etc directory with the name custom',1),(9397,'from a unix shell, you can do this as follows: curl http://svn',1),(9398,'org/repos/asf/servicemix/smx4/features/trunk/',1),(9399,'assembly/src/main/filtered-resources/etc/jre',1),(9400,'properties > etc/',1),(9401,'custom',1),(9402,'propertiesthis command will download and save the file as etc/custom',1),(9403,'the apachekaraf team will fix this problem in the 2',1),(9404,'2 release',1),(9405,'info440 chapter 13 running and deploying camelyou can then type features:list to see all the features that are available to be installed',1),(9406,'among these should be several camel-related features',1),(9407,'the example application requires the http, camel, and camel-cxf features',1),(9408,'type these commands in the shell:features:install http features:install camel features:install camel-cxfand then wait a bit',1),(9409,'tip you can type osgi:list to see which bundles have already been installed and their status',1),(9410,'the shell has autocompletion, so you can press tab to see the possible choices',1),(9411,'for example, type osgi and then press tab to see the choices',1),(9412,'you’re now ready to deploy the rider auto parts application',1),(9413,'3 deploying the examplekaraf can install osgi bundles from various sources, such as the filesystem or the local maven repository',1),(9414,'to install using maven, you first need to install the application in the local maven repository, which can easily be done by running mvn install from the chapter13/ osgi directory',1),(9415,'after the jar file has been copied to the local maven repository, you can deploy it to apache karaf using the following command from the shell:osgi:install mvn:com',1),(9416,'camelinaction/riderautoparts-osgi/1',1),(9417,'0upon installing any jar to karaf (a jar file is known as a bundle in osgi terms), karaf will output on the console the bundle id it has assigned to the installed bundle, as shown:bundle id: 98you can then type osgi:list to see the application being ...',1),(9418,'0)notice that the application isn’t started',1),(9419,'you can start it by entering osgi:start 98, which changes the application’s status when you do an osgi:list again:[98] [installed] [] [started] [60] riderautoparts-osgi (1',1),(9420,'0)the application is now running in the osgi container',1),(9421,'tip you can install and start the bundle in a single command using the -s option on the osgi:install command, like this: osgi:install -s mvn:com',1),(9422,'camelinaction/riderautoparts-osgi/1',1),(9423,'so how can you test that it works',1),(9424,'you can start by checking the log with the log:display command',1),(9425,'among other things, it should indicate that apache camel has been started:15:46:32,396 | info  | extenderthread-6 | defaultcamelcontext |e',1),(9426,'0 (camelcontext: mycamelcontext) started    www',1),(9427,'info441summary and best practicesyou can then use soapui to send a test request',1),(9428,'the wsdl file is available at http:// localhost:9000/inventory',1),(9429,'wsdl',1),(9430,'when you’re done testing the application, you may want to stop the osgi container, which you can do by executing the osgi:shutdown command from the shell',1),(9431,'tip you can tail the apache karaf log file using tail -f log/karaf',1),(9432,'note that this isn’t done from within the karaf shell but from the regular shell on your operating system',1),(9433,'you’ve now seen how to deploy the example into an osgi container, which marks the end of our practical coverage of osgi in this book',1),(9434,'5 lists the pros and cons of deploying camel in an osgi container',1),(9435,'you’ve now seen the most popular deployment strategies for camel and other products',1),(9436,'we’ve only scratched the surface of osgi in this chapter',1),(9437,'if you go down that path, you’ll need to pick up some other books, because osgi is a big concept to grasp and master',1),(9438,'the path of the web application is the beaten track, and there are plenty of materials and people who can help you if you come up against any problems',1),(9439,'6 summary and best practicesin this chapter, we explored the internal details of how camel starts up',1),(9440,'you learned which options you can control and whether routes should be autostarted',1),(9441,'you also learned how to dictate the order in which routes should be started',1),(9442,'more important, you learned how to shut down a running application in a reliable way without compromising the business',1),(9443,'you learned about camel’s graceful shutdown procedures and what you can do to reorder your routes to ensure a better shutdown process',1),(9444,'you also learned how to stop and shut down routes at runtime',1),(9445,'you can do this programmatically, which allows you to fully control when routes are operating and when they are not',1),(9446,'in the second part of this chapter, we explored the art of deploying camel applications as standalone java applications, as web applications, and by running camel in an osgi container',1),(9447,'remember that the deployment strategies covered in this book aren’t all of your options',1),(9448,'for example, camel can also be deployed in the cloud, or they can be started using java web start',1),(9449,'5 pros and cons of using osgi as a deployment strategypros cons■ leverages osgi for modularity■ provides classloader isolation and hot deployment■ commitment in the open source community and from big vendors endorsing osgi■ involves a learning curve ...',1),(9450,'info442 chapter 13 running and deploying camel here are some pointers to help you out with running and deployment:■ ensure reliable shutdown',1),(9451,'take the time to configure and test that your application can be shut down in a reliable manner',1),(9452,'you application is bound to be shut down at some point, whether for planned maintenance, upgrades, or unforeseen problems',1),(9453,'in those situations, you want the application to shut down in a controlled manner without negatively affecting your business',1),(9454,'■ use an existing runtime environment',1),(9455,'camel is agile, flexible, and can be embedded in whatever production setup you may want to use',1),(9456,'don’t introduce a new production environment just for the sake of using camel',1),(9457,'use what’s already working for you, and test early on in the project that your application can be deployed and run in the environment',1),(9458,'in the next (and final) chapter, we’ll revisit camel’s routing capabilities, but we’ll focus on the power of using annotations on beans',1),(9459,'we’ll also see how you can hide the camel api from clients but still let clients interact with camel by hiding the middleware layer',1),(9460,'info443bean routing and remotingin this chapter, we’ll show you a couple of extra features in camel that allow you to hide camel apis from users and developers',1),(9461,'hiding these apis is sometimes necessary when you want to limit dependence on camel',1),(9462,'these techniques also provide approaches to solving integration problems that complement approaches we’ve discussed throughout this book',1),(9463,'first, you’ll learn to use camel’s annotation-based routing, which allows regular java beans to be used for routing',1),(9464,'this allows you to access all of camel’s components and not write a single line of dsl code',1),(9465,'you sacrifice many of the routing abilities that are provided in camel’s dsls, but this isn’t a problem for simple use cases',1),(9466,'when using the routing annotations, you still have to code against camel apis, just not the camel dsl',1),(9467,'we’ll take this a step further in the last part of the chapter and discuss the art of hiding middleware',1),(9468,'by hiding middleware, you allow users of your camel application to only see the business interfaces; the complexity of remote transports and camel apis are hidden behind a clean client api',1),(9469,'this chapter covers■ routing using annotations on beans■ using remoting and hiding middleware    www',1),(9470,'info444 chapter 14 bean routing and remoting let’s get started by looking at how to route messages using camel’s messaging annotations',1),(9471,'1 using beans for routingthroughout this book, you’ve seen how camel’s unique and powerful dsls can be used to easily create complex integration applications',1),(9472,'but in order to take advantage of this power, you need to learn a camel dsl and its intricacies',1),(9473,'using a dsl also means that your application—at least the integration and routing portion—is tied to camel',1),(9474,'an alternative approach is to create simple integration applications',1),(9475,'by using annotations, you can produce and consume (send and receive) messages to and from camel endpoints by using a regular java bean',1),(9476,'in this way, you don’t need to learn much about camel at all',1),(9477,'you can write your application as you normally would in plain java, and when you want to connect it to an external service, you can use an annotation from camel',1),(9478,'it sounds pretty simple because it is',1),(9479,'this approach of using camel is only recommended for simple integration scenarios or when you can’t invest the time to learn the camel dsls',1),(9480,'we’ll discuss when to use this approach in more detail in section 14',1),(9481,'first, let’s see where this approach would be useful, and then we’ll dive into the details of the messaging annotations',1),(9482,'1 inventory update at rider auto partsback in chapter 10, we looked at how rider auto parts keeps an inventory of all the parts its suppliers currently have in stock',1),(9483,'it was kept up to date by the suppliers periodically sending updates to rider auto parts',1),(9484,'storing this information locally within rider auto parts means the business can operate without being dependent on expensive online integrations with all the suppliers',1),(9485,'suppose that you want this automated update to happen over jms, because it has built-in reliable messaging, among other things',1),(9486,'the updates will come in from multiple suppliers and enter through a single queue named partnerinventoryupdate',1),(9487,'messages on this queue are then used to update the inventorydb database',1),(9488,'1 illustrates this flow',1),(9489,'partnerinventoryupdatebusiness partner 1rider auto partsinventorydbbusiness partner n',1),(9490,'1 business partners send inventory updates to the partnerinventoryupdatequeue',1),(9491,'these updates are then used to update the internal inventory database',1),(9492,'info445using beans for routinglet’s also suppose you have a java class already available that can write this inventory update into a database',1),(9493,'here’s the class',1),(9494,'jdbctemplate;public class inventoryupdater {    private jdbctemplate jdbc;    public inventoryupdater(datasource ds) {        jdbc = new jdbctemplate(ds);    }    public void updateinventory(inventory inventory) {        jdbc',1),(9495,'execute(tosql(inventory));                     }        private string tosql(inventory inventory) {        object[] args = new object[] {            inventory',1),(9496,'format(\"insert into partner_inventory \" +             \"(supplier_id, part_id, name, amount) values \" +             \"(\'%s\', \'%s\', \'%s\', \'%s\')\", args);    } }this class has an updateinventory method that accepts a single parameter, an inventory object,...',1),(9497,'this data is then fed into the inventory database',1),(9498,'we’ll look at how the business partner sends to rider auto parts in section 14',1),(9499,'2, but for now we’ll look at how this inventory service will be implemented on the rider auto parts side',1),(9500,'2 receiving messages with @consumeinventory messages are arriving at the jms partnerinventoryupdate queue, so you need to figure out how to consume them and feed them into the database',1),(9501,'you also want to reuse the inventoryupdater class shown in listing 14',1),(9502,'1 as much as possible',1),(9503,'if you know how to create a route in one of camel’s dsls, a solution may seem pretty obvious',1),(9504,'you could set up a jms consumer, as discussed in chapter 7, and then call the inventoryupdater class using the bean component, as shown in chapter 4',1),(9505,'omitting the jms component and bean setup, the route builder would look something like this:public class inventoryupdaterroute extends routebuilder {    @override     public void configure() throws exception {         from(\"jms:partnerinventoryupdate\")',1),(9506,'to(\"bean:inventoryhelperinstance\");    } }listing 14',1);
INSERT INTO `sentences` VALUES (9507,'1 a java class that can update the inventory databaseupdates database with spring jdbc    www',1),(9508,'info446 chapter 14 bean routing and remotingto seasoned camel users this will be simple to understand',1),(9509,'but how can we do this without using camel’s dsls',1),(9510,'the answer is, “through the @consume annotation',1),(9511,'” by using the @consume annotation in the inventoryupdater bean, you can hook the partnerinventoryupdate queue directly to the updateinventory method',1),(9512,'here’s how this is done',1),(9513,'consume; import org',1),(9514,'jdbctemplate;public class inventoryupdater {',1),(9515,'@consume(uri = \"jms:partnerinventoryupdate\")           public void updateinventory(inventory inventory) {        jdbc',1),(9516,'}adding this simple annotation tells camel to consume messages from the partnerinventoryupdate queue and invoke the updateinventory method with the contents',1),(9517,'the @consume annotation accepts any camel endpoint uri, so you can easily hook up a method to anything that camel supports',1),(9518,'to see this example in action, go to the chapter14/pojo-messaging directory in the book’s source and run this maven command:mvn clean testthe test case will send a message to the partnerinventoryupdate queue and check that the update makes it into th...',1),(9519,'you may be wondering how you get from a jms message to an inventory object',1),(9520,'just because you aren’t using a routebuilder doesn’t mean that automatic type conversion won’t take place',1),(9521,'in this case, camel’s type converters automatically convert the body of the jms message to an inventory object, which is the parameter of the invoked method',1),(9522,'you may recall from chapter 4 that, by default, camel assumes that if there is a single parameter in a method being called on a bean, the body of the message needs to be converted to match that type',1),(9523,'you can also use any of the parameterbinding annotations mentioned in section 4',1),(9524,'3 to define more precisely what data to map from the incoming message',1),(9525,'loading annotated classes into camelgetting access to all of camel’s components through a simple annotation may seem like a bit of magic',1),(9526,'as you may have guessed, there’s a little more setup required to use these annotations',1),(9527,'the first thing you’ll need to set up are the required dependencies: camel-core and camel-spring',1),(9528,'you’ll also need to use a springcamelcontext as the base application—listing 14',1),(9529,'2 inventoryupdater class connected to jms queue by @consume connects method to jms queue    www',1),(9530,'info447using beans for routinga plain defaultcamelcontext from camel-core won’t do',1),(9531,'that’s because when you create a springcamelcontext in your spring xml file, like so,<camelcontext id=\"camel\" xmlns=\"http://camel',1),(9532,'org/schema/spring\" />it also registers a camelbeanpostprocessor with the spring application context',1),(9533,'the camelbeanpostprocessor is a spring beanpostprocessor that checks each new bean registered in the spring application context for the @consume and @produce annotations',1),(9534,'if it finds these annotations, it connects the bean to the specified camel endpoints for you',1),(9535,'note we’ll be discussing the @produce annotation, which is used to send messages to a camel endpoint, in section 14',1),(9536,'so all you have to do to use these annotations is create a springcamelcontext and then create your bean within the spring xml file, as follows:<bean class=\"camelinaction',1),(9537,'inventoryupdater\"/>  referencing a shared endpointif you have multiple beans consuming from the same endpoint uri, you may find it useful to define the endpoint once and reference it from each bean',1),(9538,'this way, if the uri changes, you only have to change it in one place',1),(9539,'for example, you can set up a camel endpoint in the context so it can be accessed from any bean:<camelcontext id=\"camel\" xmlns=\"http://camel',1),(9540,'org/schema/spring\">  <endpoint id=\"inventoryqueue\" uri=\"jms:partnerinventoryupdate\"/> </camelcontext>now you can reference the inventoryqueue endpoint within the @consume annotation as follows:@consume(ref = \"inventoryqueue\") public void updateinvent...',1),(9541,'execute(tosql(inventory)); }this will have the same end result as if you were specifying the endpoint uri in the annotation',1),(9542,'the only difference is that camel won’t have to resolve the endpoint instance (or create a new instance on the fly) because it’s referencing an available instance',1),(9543,'specifying what camelcontext to useif you have two camelcontext elements defined within one spring xml file, you’ll need to take extra care in making sure the @consume annotation specifies which camelcontext it should apply to',1),(9544,'why is this',1),(9545,'when you create a springcamelcontext, a beanpostprocessor is used to inspect each newly created bean and create consumers on the fly for the specified camel endpoint',1),(9546,'the problem with this is that you’ll get a new consumer for each camelcontext defined',1),(9547,'this may not be what you want to happen',1),(9548,'info448 chapter 14 bean routing and remoting to get around this, you can specify the camelcontext id in the annotation definition',1),(9549,'suppose you have two camelcontext elements defined as follows:<camelcontext id=\"camel-1\" xmlns=\"http://camel',1),(9550,'org/schema/spring\" /> <camelcontext id=\"camel-2\" xmlns=\"http://camel',1),(9551,'org/schema/spring\" />when you use the @consume annotation in your bean, you can specify the context by using the context attribute',1),(9552,'for example, to reference the context with id equal to camel-1, you could do the following:@consume(uri = \"jms:partnerinventoryupdate\", context = \"camel-1\") public void updateinventory(inventory inventory) {    jdbc',1),(9553,'execute(tosql(inventory)); }you now know all the details necessary for consuming messages from camel endpoints using the @consume annotation',1),(9554,'we mentioned before that you can similarly use annotations for producing messages to camel endpoints',1),(9555,'we’ll look at the @produce annotation that does this next',1),(9556,'3 sending messages with @produceyou now have a new requirement for the inventoryupdater bean',1),(9557,'when you receive an inventory update from a partner, in addition to updating the database, you must send the update to the jms partneraudit queue for processing',1),(9558,'rider auto parts has added a new system that keeps track of how often partners send updates, whether updates had errors, and so on',1),(9559,'2 illustrates this process',1),(9560,'this addition would be dead simple if you were using a camel dsl route already, but you need to add this to your existing inventoryupdater bean',1),(9561,'you can do this by using the @produce annotation',1),(9562,'like the @consume annotation described in the previous section, the @produce annotation allows you to access any camel endpoint without using one of camel’s dsls',1),(9563,'the difference is that the @produce annotation doesn’t attach to a method within a class; it attaches to a field or property setter within a class',1),(9564,'this field can be either a producertemplate or an interface you use in your business logic',1),(9565,'in the case of a producertemplate, camel will simply inject a new producertemplate that points to the uri you specify',1),(9566,'if a plain interface is supplied, camel has to do some extra work by injecting a proxy object',1),(9567,'we’ll look at both approaches next',1),(9568,'2 when an inventory update comes in, it’s used to update the inventory database and it’s also sent to the partneraudit queue for auditing',1),(9569,'info449using beans for routinginjecting a producertemplatethe producertemplate class is a natural way of sending messages to camel endpoints',1),(9570,'you’ve seen it used in previous chapters, so its use should be familiar',1),(9571,'a complete discussion of the producertemplate is given in appendix c',1),(9572,'you can use the @produce annotation to set up a producertemplate for a particular endpoint uri',1),(9573,'consume; import org',1),(9574,'jdbctemplate;public class inventoryupdaterannotatedwithproduce {    @produce(uri = \"jms:partneraudit\")                    producertemplate partneraudit;    private jdbctemplate jdbc;    public inventoryupdaterannotatedwithproduce(datasource ds) {    ...',1),(9575,'}the @produce annotation b takes the endpoint uri jms:partneraudit and creates a new producertemplate for that uri',1),(9576,'at any other point in the bean’s use, you can then send messages to that endpoint using the producertemplate that was created c',1),(9577,'you can also specify an endpoint reference or camelcontext to use for the @produce annotation, as was described in the previous section for the @consume annotation',1),(9578,'injecting a proxy producerit’s also possible to send messages without using the producertemplate at all',1),(9579,'camel allows you to specify an interface as the frontend for the endpoint specified',1),(9580,'this approach allows you to eliminate the dependence on more camel apis, like the producertemplate',1),(9581,'tip if you don’t care about depending on camel apis, we recommend using the producertemplate described in the previous section because it has less overhead than the solution we’ll be describing next',1),(9582,'so how can you use a plain interface as the frontend for an endpoint',1),(9583,'the short answer is that camel creates an instance of the interface—a smart proxy object',1),(9584,'thislisting 14',1),(9585,'3 using the @produce annotation to set up a producertemplatesets up producertemplate for uribsends message using producertemplatec    www',1),(9586,'info450 chapter 14 bean routing and remotingproxy object converts method calls into objects to be passed to the camel endpoint',1),(9587,'the whole process is described in more detail in section 14',1),(9588,'suppose you define an interface for your backend audit processing systems as follows:public interface partneraudit {     public void audit(inventory inventory); }the single audit method is intended to mean that the inventory object passed in should b...',1),(9589,'the interface can then replace the producertemplate, as shown here',1),(9590,'consume; import org',1),(9591,'jdbctemplate;public class inventoryupdaterannotatedwithproduceinterface {    @produce(uri = \"jms:partneraudit\")                          partneraudit partneraudit;    private jdbctemplate jdbc;    public inventoryupdaterannotatedwithproduce(datasourc...',1),(9592,'}the bean looks much like before, except that now there’s no use of producertemplate',1),(9593,'instead, you use the partneraudit interface as the binding point for the @produce annotation b',1),(9594,'this annotation will now tell camel that a smart proxy object must be created that extends from partneraudit and passes on a message to the partneraudit jms queue',1),(9595,'then, when you call the audit method on the interface c, camel sends a message to the endpoint specified in the @produce annotation',1),(9596,'4 when to use beans for routingyou may be wondering when you should use the messaging annotations rather than one of camel’s dsls',1),(9597,'there’s no clear-cut answer to the question, but we can give you some guidelines to make your decision easier',1),(9598,'listing 14',1),(9599,'4 using the @produce annotation to set up a producer on an interfaceinjects smart proxybsends message using interfacec    www',1),(9600,'info451hiding middleware in general, we recommend that you use one of camel’s dsls if at all possible',1),(9601,'they have built-in functionality for setting up common integration scenarios and will most likely make your life a lot easier',1),(9602,'you may want to use the messaging annotations in the following situations:■ you have a simple message flow where there is a single well-defined input or output uri',1),(9603,'if you require a more dynamic bean when using annotations, see the @recipientlist annotation discussed in section 2',1),(9604,'■ you would rather not learn about camel’s dsls',1),(9605,'■ you have a use case so simple that you have no need for eips',1),(9606,'■ you just want to access camel’s library of components',1),(9607,'we want to stress that for complex integration scenarios, you should use one of camel’s dsls',1),(9608,'trying to design a complex integration with the messaging annotations could lead to a messy solution—they were not designed for complex routings',1),(9609,'you’ve seen how you can reduce your dependence on camel’s dsls with these annotations',1),(9610,'let’s now take a look at how you can take that a step further and completely hide camel from users of your application',1),(9611,'2 hiding middlewaremiddleware is defined as the software layer that lies between an operating system and an application',1),(9612,'middleware is used for interoperability among applications that are running in a coherent distributed system',1),(9613,'examples include enterprise application integration (eai), enterprise service buses (esbs), and message queuing software (such as apache activemq)',1),(9614,'camel is also used for integrating and providing interoperability among applications that may run in a coherent distributed system',1),(9615,'you could potentially view camel as middleware software, but that isn’t entirely accurate, because camel leverages thirdparty software where appropriate',1),(9616,'for example, you can have camel sitting on top of apache activemq, and together they’re middleware software',1),(9617,'an important aspect of writing software these days is trying to write business logic that focuses on the domain concepts as much as possible',1),(9618,'you want your business logic to deal with the business domain rather than with the myriad of technology stacks out there, such as soap, rest, jms, ftp, and xmpp',1),(9619,'one way to avoid this situation is to decouple as much middleware from your business logic as possible—to hide the middleware',1),(9620,'by keeping your business logic hidden from the middleware, your application will be much more flexible and easy to change',1),(9621,'this also makes the lives of clients who access the business logic easier, because they only have to deal with the business domain',1),(9622,'to demonstrate this, we’ll cover a use case from rider auto parts',1),(9623,'you and your team have developed a starter kit, which is a piece of software new business partners can use to more easily integrate with rider auto parts',1),(9624,'info452 chapter 14 bean routing and remotingthe situation without the starter kit is two businesses needing to integrate their business logic',1),(9625,'because the business logic is distributed, the logic of one partner needs to communicate over the network in order to interact with the other partner’s logic',1),(9626,'that means the business logic needs to know about and use the transport',1),(9627,'you want to hide the complexity of transports, which you can depict by labeling it as middleware, as shown in figure 14',1),(9628,'the starter kit is middleware software based on camel and a selected third-party technology for the transport',1),(9629,'the transport must support networking to transfer data from one machine to another',1),(9630,'such a transport could, for example, be http- or messaging-based',1),(9631,'the transport technology that best fits the situation should be chosen',1),(9632,'for this example, the transport technology is messaging using apache activemq',1),(9633,'the business partner deploys the starter kit in their infrastructure and uses it to communicate with rider auto parts, as shown in figure 14',1),(9634,'in this example, the starter kit takes care of all the complexity involved in sending messages over the network using apache activemq',1),(9635,'all the business partner should focus on is a single client interface that defines the api they need to use',1),(9636,'in this section, you’ll learn how to develop such a starter kit',1),(9637,'we’ll start by defining the client api and creating a simple test that runs in a single jvm',1),(9638,'then you’ll learn howbusiness partner rider auto partstransportbusinesslogicbusiness transport logicnetworkmiddlewarefigure 14',1),(9639,'3 each part of the business logic leverages middleware when communicating with the other parts',1),(9640,'gateway activemqrider auto partsstarter kitbusiness partnerbusinesslogicrider auto partsactivemqbusinesslogicmiddlewarefigure 14',1),(9641,'4 the starter kit is used by business partners to hide the middleware and easily communicate with rider auto parts',1),(9642,'info453hiding middlewareto change the middleware to switch transports without requiring any changes in the client',1),(9643,'in section 14',1),(9644,'2, we’ll let the communication happen remotely between two jvms using jms as the transport, which is what you might use in a real-life situation',1),(9645,'1 introducing the starter kitthe starter kit is a camel application that defines a single interface for business partners to use when integrating their businesses with rider auto parts',1),(9646,'to keep the use case simple, the interface will provide the following two methods:public interface riderservice {    void updateinventory(inventory inventory);    list<shippingdetail> shipinventory(string supplierid, string partid); }the first method...',1),(9647,'this allows rider auto parts to maintain current information about its suppliers’ inventory situation, with all data being stored in a datastore within rider auto parts',1),(9648,'the second method is used by suppliers to find out which of the many rider auto parts retail stores inventory should be shipped to',1),(9649,'the domainin this example, the information on the domain objects is kept simple and limited, as the following code snippets show (we’ve omitted the getters and setters):public class inventory implements serializable {    private string supplierid;   ...',1),(9650,'}here’s the shippingdetail domain object:public class shippingdetail implements serializable {    private string address;    private string zip;    private string country;    private string amount;',1),(9651,'}using the riderservice interface, it should be easy for business partners to send inventory information to rider auto parts, as the following code example shows:private void updateinventory(riderservice rider) {    inventory inventory = new inventor...',1),(9652,'info454 chapter 14 bean routing and remotingthis example demonstrates the concept of decoupling business logic from the middleware',1),(9653,'the example is pure business logic, focusing on assembling inventory information and sending it to rider auto parts using the riderservice api',1),(9654,'the example has no middleware logic; there’s no logic present to indicate how the data is actually sent',1),(9655,'in this case, camel is the middleware, and the example doesn’t use any camel apis at all',1),(9656,'you’ve fully decoupled your business logic from the integration logic',1),(9657,'with the domain in place, let’s turn our attention to setting up camel',1),(9658,'first you’ll want to create a test that runs on a single jvm',1),(9659,'setting up camelin camel, you need to set up two things to implement your first test',1),(9660,'you need a mocked riderservice that can act as rider auto parts and return dummy data',1),(9661,'this is easy to do—all it involves is implementing the riderservice interface',1),(9662,'public class riderautopartsmock implements riderservice {    private static log log = logfactory',1),(9663,'getlog(riderautopartsmock',1),(9664,'class);    public void updateinventory(inventory inventory) {        log',1),(9665,'info(\"updating inventory \" + inventory);    }    public list<shippingdetail> shipinventory(string supplierid,                                              string partid) {        log',1),(9666,'setaddress(\"rider road 66\");        detail',1),(9667,'setaddress(\"ocean view 123\");        detail2',1),(9668,'setamount(\"45\");        list<shippingdetail> answer = new arraylist<shippingdetail>();        answer',1),(9669,'add(detail);        answer',1),(9670,'add(detail2);        return answer;    } }you then need to create a spring xml file',1),(9671,'<beans xmlns=\"http://www',1),(9672,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(9673,'org/2001/xmlschema-instance\"       xmlns:camel=\"http://camel',1),(9674,'org/schema/spring\"       xsi:schemalocation=\"         http://www',1),(9675,'org/schema/beanslisting 14',1),(9676,'5 simulating rider auto partslisting 14',1),(9677,'6 spring xml setting up camel    www',1),(9678,'org/schema/beans/spring-beans-3',1),(9679,'xsd         http://camel',1),(9680,'org/schema/spring         http://camel',1),(9681,'org/schema/spring/camel-spring',1),(9682,'xsd\">    <bean id=\"ridermocked\"                                           class=\"camelinaction',1),(9683,'riderautopartsmock\"/>    <camelcontext xmlns=\"http://camel',1),(9684,'org/schema/spring\">        <proxy id=\"rider\"                                                    serviceinterface=\"camelinaction',1),(9685,'riderservice\"               serviceurl=\"direct:rider\"/>        <route>                                      <from uri=\"direct:rider\"/>                    <to uri=\"bean:ridermocked\"/>         </route>                             </camelcontext> </bean...',1),(9686,'5), which is used to simulate the rider auto parts business',1),(9687,'the next part is the interesting part—it’s the mechanism that decouples the business logic from the middleware',1),(9688,'this is done by proxying c the riderservice interface and having its method invocations proxied by sending a message to the given endpoint',1),(9689,'we’ll cover this in much more detail in section 14',1),(9690,'what remains is to define a route d that sends the messages to rider auto parts',1),(9691,'in this example, you route the message to the mocked bean that simulates rider auto parts',1),(9692,'the source code for the book contains this example in the chapter14/starterkit directory',1),(9693,'you can run this example by using the following maven goal: mvn test -dtest=starterkitmockedtestwhen you run the example, you should see the following lines, among others, on the console:[main] info - sending inventory [main] info - updating inventor...',1),(9694,'starterkitmockedtest class, you should notice that it’s not using any camel code to execute the business logic',1),(9695,'in the introduction to this section, we said that camel can hide the middleware, allowing you to decouple your business logic from the transport',1),(9696,'you’ll now see this in action as you change the transport from direct to the seda component without requiring any changes in the business logic',1),(9697,'changing the transport to sedachanging the transport to seda is easily done in the spring xml file, as follows:<camelcontext xmlns=\"http://camel',1),(9698,'org/schema/spring\">    <proxy id=\"rider\"           serviceinterface=\"camelinaction',1),(9699,'riderservice\"simulates rider auto partsbproxies camel route as interfacecd specifies route to be invoked    www',1),(9700,'info456 chapter 14 bean routing and remoting           serviceurl=\"seda:rider\"/>    <route>        <from uri=\"seda:rider\"/>        <to uri=\"bean:ridermocked\"/>    </route> </camelcontext>you can run this example using the following maven goal: mvn te...',1),(9701,'listing 14',1),(9702,'6 uses a camel proxy to hide the middleware, by using the <proxy/> tag',1),(9703,'we’ll now look at how this works',1),(9704,'2 using spring remoting and camel proxiesusing a camel proxy is similar to using spring remoting, which is a feature in the spring framework that offers remoting support for various technologies, making it easier to remote-enable services',1),(9705,'spring has a limited set of technologies that can be used',1),(9706,'camel takes this a big step forward by remote-enabling all of the camel components',1),(9707,'to understand how a camel proxy works, let’s start by adding a log in the route from listing 14',1),(9708,'6 that will output information about the actual messages sent by the camel proxy:<route>    <from uri=\"direct:rider\"/>    <to uri=\"log:rider\"/>    <to uri=\"bean:ridermocked\"/> </route>the console outputs the following:[main] info rider - exchange[exc...',1),(9709,'beaninvocation, body:beaninvocation public abstract void  camelinaction',1),(9710,'inventory)  with [1234, 4444, bumper, 57]]]as you can see from the output, camel uses a beaninvocation type in the message body',1),(9711,'the purpose of the beaninvocation is to hold information about a bean invocation',1),(9712,'it indicates that the updateinventory method is to be invoked with these parameters',1),(9713,'because beaninvocation is serializable, it’s possible to send it over a remote network and have it invoked on the remote side',1),(9714,'let’s try this using jms as the transport and using two jvms',1),(9715,'info457hiding middlewareusing jms as the transportnext, we’ll look at a client and server each in separate jvms, using jms as the transport',1),(9716,'first we’ll discuss the server and how to start it',1),(9717,'then we’ll look at the client and run it to see it in action',1),(9718,'here’s the spring xml file you use to define the server',1),(9719,'<broker:broker persistent=\"false\" brokername=\"localhost\">           <broker:transportconnectors>        <broker:transportconnector name=\"tcp\" uri=\"tcp://localhost:61616\"/>    </broker:transportconnectors> </broker:broker><bean id=\"ridermocked\" class=...',1),(9720,'riderautopartsmock\"/><camelcontext xmlns=\"http://camel',1),(9721,'org/schema/spring\">    <route>        <from uri=\"activemq:queue:rider\"/>                   <to uri=\"log:server\"/>        <to uri=\"bean:ridermocked\"/>    </route> </camelcontext>on the server you embed an apache activemq broker that uses tcp as the tr...',1),(9722,'as you have two jvms, you need a remote protocol, which in this case is tcp',1),(9723,'in the route, you consume messages from the activemq rider queue c, which is the destination where the client will send the messages',1),(9724,'because you use an embedded activemq broker, you don’t need to define an activemq component because camel can leverage an intra-vm connection',1),(9725,'you can start the server using the following maven command in the chapter14/ starterkit directory:  mvn compile exec:java -pserverthe client is simple',1),(9726,'all you need to do is define the proxy and configure the activemq transport, as follows:<bean id=\"activemq\"      class=\"org',1),(9727,'activemqcomponent\">    <property name=\"brokerurl\" value=\"tcp://localhost:61616\"/> </bean><camelcontext xmlns=\"http://camel',1),(9728,'org/schema/spring\">    <proxy id=\"rider\"           serviceinterface=\"camelinaction',1),(9729,'riderservice\"           serviceurl=\"activemq:queue:rider\"/> </camelcontext>you can run the client using the following maven command in the chapter14/ starterkit directory: mvn test -dtest=starterkitclienttestlisting 14',1),(9730,'7 server with activemq brokeractivemq brokerbroute with servicec    www',1),(9731,'info458 chapter 14 bean routing and remotingwhen the client is run, you should see activity in both the client and server consoles',1),(9732,'the server should log the message received, which is similar to what you saw previously when jms wasn’t used as the transport:12:34:07 - exchange[exchangepattern:inout,',1),(9733,'body:beaninvocation public abstract void',1),(9734,'with [1234, 4444, bumper, 57]]] 12:34:07 - updating inventory 1234, 4444, bumper, 57now you’ve seen how to decouple your business logic from the middleware and change the transport without any code changes to the business logic',1),(9735,'with that, it’s time to look under the hood at how this works',1),(9736,'how camel proxies workthe code for creating camel proxies is located in camel-core as the org',1),(9737,'proxyhelper class, and it has various methods for proxying an interface with a camel endpoint',1),(9738,'in fact the <proxy/> tag you used in spring xml is a facade that leverages the proxyhelper class',1),(9739,'5 is a sequence diagram that depicts what happens at runtime when a client invokes the shipinventory method on a proxied riderservice interface',1),(9740,'in this figure, a client invokes the shipinventory method on riderservice',1),(9741,'this is proxied with the help of java',1),(9742,'proxy, which invokes the camelinvocationhandler',1),(9743,'this handler creates a beaninvocation that contains information about the method (and its parameters) invoked on the proxy',1),(9744,'then the beaninvocation is sent to the endpoint using a camel producer, which waits for the response toriderservice camelinvocationhandlerproducerbeaninvocationshipinventoryinvokecreatesend to endpointreplyconverted replyreplywaitforresponsefigure 14',1),(9745,'5 a sequence diagram showing how a camel proxy works under the covers, sending a beaninvocation message to a remote endpoint and waiting for the reply, which eventually is returned to the caller    www',1),(9746,'the response is then adapted to the riderservice by converting it to the same type as the return type on the method',1),(9747,'note camel proxies will, by default, always use request-response messaging style (inout) when a proxied method is invoked',1),(9748,'this also applies to methods that don’t return a value (whose return type is void)',1),(9749,'you can enforce a method to use the fire-and-forget messaging style (inonly) by adding the @inonly annotation to the method definition in the interface',1),(9750,'but keep in mind that when using @inonly, the method call will be fully asynchronous, so you won’t know if the receiver processed the message successfully',1),(9751,'for example, exceptions thrown by the receiver won’t be propagated back to the method call',1),(9752,'when using a camel proxy, there’s a single rule that must be adhered to',1),(9753,'rule when using a camel proxycamel proxies use a beaninvocation as the message body sent to the endpoint',1),(9754,'if the endpoint is representing a remote destination, the message body must be serialized so it can be sent over the wire',1),(9755,'this is why the information stored in beaninvocation must be serializable',1),(9756,'for camel end users, that means the parameters you pass to the proxied interface must be serializable',1),(9757,'for example, if you look at the updateinventory method in the riderservice interface, you can see that it uses an inventory object as a parameter',1),(9758,'public interface riderservice {    void updateinventory(inventory inventory);    list<shippingdetail> shipinventory(string supplierid, string partid); }when you invoke the updateinventory method, as shown in the following test snippet, the inventory ...',1),(9759,'public void teststarterkitupdateinventory() throws exception {    riderservice rider = context',1),(9760,'getregistry()',1),(9761,'class);    inventory inventory = new inventory(\"1234\", \"4444\");    inventory',1),(9762,'updateinventory(inventory); }this is done by implementing the java',1),(9763,'serializable interface on the inventory class:public class inventory implements serializable {',1),(9764,'}the same rule applies to data being returned, so the shipinventory method must also return serializable data, which is ensured by letting the shippingdetail class implement java',1),(9765,'info460 chapter 14 bean routing and remotingusing a camel proxy from the java dslyou can also create a proxy in java code',1),(9766,'for example, the following example from spring xml,<camelcontext xmlns=\"http://camel',1),(9767,'org/schema/spring\">    <proxy id=\"rider\"           serviceinterface=\"camelinaction',1),(9768,'riderservice\"           serviceurl=\"activemq:queue:rider\"/> </camelcontext>can be rewritten in java code using org',1),(9769,'proxybuilder as follows:riderservice rider = new proxybuilder(context)',1),(9770,'endpoint(\"seda:rider\")',1),(9771,'class);the source code for the book contains an example in the chapter14/starterkit directory',1),(9772,'you can try it with the following maven goal: mvn test -dtest=starterkitjavaproxybuildertestyou’ve now learned how to decouple your business logic from the integration logic by hiding the middleware with help from camel proxies',1),(9773,'3 summary and best practicesin this last chapter of camel in action, we’ve shown you ways of using camel that minimize your dependence on camel apis and completely hide camel from your application’s users',1),(9774,'these abilities are considered extra features of camel, rather than core pieces',1),(9775,'they add functionality that experienced camel users, which you now are, can appreciate',1),(9776,'there are a few things you should take away from this chapter:■ the messaging annotations are great for simple use cases',1),(9777,'when all you want to do is hook up a bean to a transport supported by camel, the messaging annotations are an easy way to go',1),(9778,'there is little learning overhead with these, compared to using the camel dsls',1),(9779,'we still recommend the camel dsls for more complex scenarios',1),(9780,'■ use hiding middleware principles when you don’t want to expose your transports',1),(9781,'in some cases, you may not want clients of your service to know what transport you’re using to communicate with the backend',1),(9782,'for instance, you may want to change the transport in the future without changing the client’s code',1),(9783,'you’ve now made it through many camel and general enterprise integration concepts; you have the knowledge to tackle complex integration problems with camel',1),(9784,'as a final suggestion, try to keep in touch with the camel community',1),(9785,'it’s a busy and exciting place, and we’d love to hear from you there',1),(9786,'info461appendix a simple, the expression languagecamel offers a powerful expression language, which back in the earlier days wasn’t as powerful and was labeled simple',1),(9787,'it has evolved to become much more since then, but don’t worry: it’s still simple to use',1),(9788,'the simple language is provided out of the box in the camel-core jar file, which means you don’t have to add any jars on the classpath to use it',1),(9789,'1 introducing simplein a nutshell, the simple expression language evaluates an expression on the current instance of exchange that is under processing',1),(9790,'the simple language can be used for both expressions and predicates, which makes it a perfect match to be used in your camel routes',1),(9791,'for example, the content-based router eip can leverage the simple language to define predicates in the when clauses, as shown here:from(\"activemq:queue:quotes\")',1),(9792,'when(simple(\"${body} contains \'camel\'\"))',1),(9793,'when(simple(\"${header',1),(9794,'to(\"activemq:bigspender\")',1),(9795,'otherwise()',1),(9796,'to(\"activemq:queue:other\");the equivalent spring xml example would be as follows:<route>    <from uri=\"activemq:queue:quotes\"/>    <choice>        <when>            <simple>${body} contains \'camel\'</simple>            <to uri=\"activemq:camel\"/>      ...',1),(9797,'info462 appendix a simple, the expression language        <when>            <simple>${header',1),(9798,'amount} > 1000</simple>            <to uri=\"activemq:bigspender\"/>        </when>        <otherwise>            <to uri=\"activemq:queue:other\"/>        </otherwise>    </choice> </route>as you can see from the preceding examples, the simple expressio...',1),(9799,'in these examples, camel will evaluate the expression as a predicate, which means the result is a boolean, which is either true or false',1),(9800,'in the example, you use operators to determine whether the message body contains the word camel or whether the message header amount is larger than 1000',1),(9801,'that gives you a taste of the simple language',1),(9802,'let’s look at its syntax',1),(9803,'2 syntaxthe simple language uses ${ } placeholders for dynamic expressions, such as those in the previous examples',1),(9804,'you can use multiple ${ } placeholders in the same expression, but nested placeholders aren’t supported',1),(9805,'the following expression is not valid: \"${header',1),(9806,'bar}}\"the following is valid:\"hello ${header',1),(9807,'name} thanks for ordering ${body}\"an alternative syntax was introduced in camel 2',1),(9808,'5 to accommodate a clash with spring’s property placeholder feature',1),(9809,'you can now also use $simple{ } placeholders with simple, such as shown in this example: \"hello $simple{header',1),(9810,'name} thanks for ordering $simple{body}\"these examples use variables such as body and header',1),(9811,'the next section covers this',1),(9812,'3 built-in variablesthe simple language provides a number of variables that bind to information in the current exchange',1),(9813,'you’ve already seen the body and header',1),(9814,'1 lists all the variables available',1),(9815,'1 variables in the simple languagevariable type descriptionbody in',1),(9816,'bodyobject contains the input message bodyout',1),(9817,'body object contains the output message body    www',1),(9818,'info463built-in functionsthe variables can easily be used in a simple expression, as you’ve already seen',1),(9819,'logging the message body can be done using ${body} as shown in the following route snippet:from(\"activemq:queue:quotes\")',1),(9820,'to(\"activemq:queue:process\");the simple language also has a set of built-in functions',1),(9821,'4 built-in functionsthe simple language has four functions at your disposal, as listed in table a',1),(9822,'xxxobject contains the input message header xxxout',1),(9823,'xxxobject contains the output message header xxxproperty',1),(9824,'xxx object contains the exchange property xxxexchangeid string contains the unique id of the exchangesys',1),(9825,'xxx sysenv',1),(9826,'xxxstring contains the system environment xxxexception object contains the exception on the exchange, if any existsexception',1),(9827,'stacktrace string contains the exception stacktrace on the exchange, if any exists; requires camel 2',1),(9828,'message string contains the exception message on the exchange, if any existsthreadname string contains the name of the current thread; can be used for logging purposestable a',1),(9829,'2 functions provided in the simple languagefunction type descriptionbodyas(type) type converts the body to the given type',1),(9830,'for example, bodyas(string) or bodyas(com',1),(9831,'mandatorybodyas(type) type converts the body to the given type',1),(9832,'will throw a notypeconversionavailableexceptionif the body could not be converted',1),(9833,'1 variables in the simple language (continued)variable type description    www',1),(9834,'info464 appendix a simple, the expression languagefor example, to log a formatted date from the message header, you could do as follows:<route>    <from uri=\"activemq:queue:quote\"/>    <log message=\"quote date ${date:header',1),(9835,'mydate:yyyy-mm-dd hh:mm:ss}\"/>    <to uri=\"activemq:queue:process\"/> </route>in this example, the input message is expected to contain a header with the key mydate, which should be of type java',1),(9836,'suppose you need to organize received messages into a directory structure containing the current day’s date as a parent folder',1),(9837,'the file producer has direct support for specifying the target filename using the simple language as shown in bold:from(\"activemq:queue:quote\")',1),(9838,'to(\"activemq:queue:process\");now suppose the file must use a filename generated from a bean',1),(9839,'you can use the bean function to achieve this:from(\"activemq:queue:quote\")',1),(9840,'to(\"activemq:queue:process\");in this example, camel will look up the bean with the id uuidbean from the registry and invoke the generate method',1),(9841,'the output of this method invocation is returned and used as the filename',1),(9842,'headeras(key, type) type converts the header with the given key to the given type',1),(9843,'method] object invokes a method on a bean',1),(9844,'camel will look up the bean with the given id from the registry and invoke the appropriate method',1),(9845,'you can optionally explicitly specify the name of the method to invoke',1),(9846,'date:command:pattern string formats a date',1),(9847,'the command must be either nowor header',1),(9848,'xxx: now represents the current timestamp, whereas header',1),(9849,'xxx will use the header with the key xxx',1),(9850,'the pattern is based on the java',1),(9851,'properties:[locations:]key string resolves a property with the given key using the camel properties component',1),(9852,'the camel properties component is covered in section 6',1),(9853,'2 functions provided in the simple language (continued)function type description    www',1),(9854,'info465built-in file variables the camel properties component is used for property placeholders',1),(9855,'for example, you could store a property in a file containing a configuration for a big-spender threshold',1),(9856,'big=5000then you could refer to the big properties key from the simple language: from(\"activemq:queue:quotes\")',1),(9857,'when(simple(\"${header',1),(9858,'to(\"activemq:bigspender\")',1),(9859,'otherwise()',1),(9860,'to(\"activemq:queue:other\");the simple language also has built-in variables when working with the camel file and ftp components',1),(9861,'5 built-in file variablesfiles consumed using the file or ftp components have file-related variables available to the simple language',1),(9862,'3 lists those variables',1),(9863,'among other things, the file variables can be used to log which file has been consumed:<route>    <from uri=\"file://inbox\"/>    <log message=\"picked up ${file:name}\"/>',1),(9864,'3 file-related variables available when consuming filesvariable type descriptionfile:name string contains the filename (relative to the starting directory)file:name',1),(9865,'ext string contains the file extensionfile:name',1),(9866,'noext string contains the filename without extension (relative to the starting directory)file:onlyname string contains the filename without any leading pathsfile:onlyname',1),(9867,'noext string contains the filename without extension and leading pathsfile:parent string contains the file parent (the paths leading to the file)file:path string contains the file path (including leading paths)file:absolute boolean whether or not the...',1),(9868,'path string contains the absolute file path',1),(9869,'file:length file:sizelong contains the file lengthfile:modified date contains the modification date of the file as a java',1),(9870,'info466 appendix a simple, the expression languagethe file and ftp endpoints have options that accept simple language expressions',1),(9871,'for example, the file consumer can be configured to move processed files into a folder you specify',1),(9872,'suppose you must move files into a directory structure organized by dates',1),(9873,'this can be done by specifying the expression in the move option, as follows:<from uri=\"file://inbox',1),(9874,'move=backup/${date:now:yyyymmdd}/${file:name}\"/>tip the ftp endpoint supports the same move option as shown here',1),(9875,'another example where the file variables come in handy is if you have to process files differently based on the file extension',1),(9876,'for example, suppose you have csv and xml files:from(\"file://inbox\")',1),(9877,'when(simple(\"${file:ext} == \'txt\'\"))',1),(9878,'when(simple(\"${file',1),(9879,'otherwise()',1),(9880,'to(\"direct:unknown\");note you can read more about the file variables at the camel website: http: //camel',1),(9881,'in this appendix, we’ve used the simple language for predicates',1),(9882,'in fact, the previous example determines whether the file is a text file or not',1),(9883,'doing this requires operators',1),(9884,'6 built-in operatorsthe first example in this appendix implemented the content-based router eip with the simple expression language',1),(9885,'it used predicates to determine where to route a message, and these predicates use operators',1),(9886,'4 lists all the operators supported in simple',1),(9887,'4 operators provided in the simple languageoperator description== tests whether the left side is equal to the right side> tests whether the left side is greater than the right side>= tests whether the left side is greater than or equal to the right s...',1),(9888,'= tests whether the left side is not equal to the right sidecontains tests whether the left side contains the string value on the right sidenot contains tests whether the left side doesn’t contain the string value on the right sidein tests whether th...',1),(9889,'info467built-in operatorsthe operators require the following syntax:${leftvalue} <op> rightvaluethe value on the left side must be enclosed in a ${ } placeholder',1),(9890,'the operator must be separated with a single space on the left and right',1),(9891,'the right value can either be a fixed value or another dynamic value enclosed using ${ }',1),(9892,'let’s look at some examples',1),(9893,'foo} == camel\")here you test whether the foo header is equal to the string value \"camel\"',1),(9894,'if you want to test for \"camel rocks\", you must enclose the string in quotes (because the value contains a space):simple(\"${in',1),(9895,'foo} == \'camel rocks\'\")camel will automatically type coerce, so you can compare apples to oranges',1),(9896,'camel will regard both as fruit:simple(\"${in',1),(9897,'bar} < 200\")suppose the bar header is a string with the value \"100\"',1),(9898,'camel will convert this value to the same type as the value on the right side, which is numeric',1),(9899,'it will therefore compute 100 < 200, which renders true',1),(9900,'you can use the range operator to test whether a value is in a numeric range',1),(9901,'199\")both the from and to range values are inclusive',1),(9902,'you must define the range exactly as shown',1),(9903,'not in tests whether the left side is not in a set of values specified on the right side; the values must be separated by commasrange tests whether the left side is within a range of values defined with the following syntax: from',1),(9904,'tonot range tests whether the left side is not within a range of values defined with the following syntax: from',1),(9905,'toregex tests whether the left side matches a regular expression pattern defined as a string value on the right sidenot regex tests whether the left side doesn’t match a regular expression pattern defined as a string value on the right sideis tests w...',1),(9906,'4 operators provided in the simple language (continued)operator description    www',1),(9907,'info468 appendix a simple, the expression language a regular expression can be used to test a variety of things, such as whether a value is a four-digit value:simple(\"${in',1),(9908,'bar} regex \'\\d{4}\'\")you can also use the built-in functions with the operators',1),(9909,'for example, to test whether a given header has today’s date, you can leverage the date function:simple(\"${in',1),(9910,'mydate} == ${date:now:yyyymmdd}\") tip you can see more examples in the camel simple online documentation: http://camel',1),(9911,'org/simple',1),(9912,'the simple language also allows you to combine two expressions together',1),(9913,'1 combining expressionsthe simple language can combine expressions using the and or or operators',1),(9914,'the syntax for combining two expressions is as follows:${leftvalue} <op> rightvalue <and|or> ${leftvalue} <op> rightvalue here’s an example using and to group two expressions:simple(\"${in',1),(9915,'bar} < 200 and ${body} contains \'camel\'\")from camel 2',1),(9916,'5 onwards you can combine any number of expressions',1),(9917,'in previous releases you could only combine exactly two expressions',1),(9918,'the simple language also supports an ognl feature',1),(9919,'7 the ognl featureboth the simple language and bean component support an object graph navigation language (ognl) feature when specifying the method name to invoke',1),(9920,'ognl allows you to specify a chain of methods in the expression',1),(9921,'suppose the message body contains a customer object that has a getaddress() method',1),(9922,'to get the zip code of the address, you would simply type the following:simple(\"${body',1),(9923,'getaddress()',1),(9924,'getzip()}\")you can use a shorter notation, omitting the get prefix and the parentheses',1),(9925,'zip}\")in this example, the zip code will be returned',1),(9926,'but if the getaddress method returns null, the example would cause a nosuchmethodexception to be thrown by camel',1),(9927,'if you want to avoid this, you can use the null-safe operator',1),(9928,'as follows:simple(\"${body',1),(9929,'zip}\")the methods in the ognl expression can be any method name',1),(9930,'for example, to invoke a sayhello method, you would do this:simple(\"${body',1),(9931,'info469using simple from custom java codecamel uses the bean parameter binding, which we covered in chapter 4',1),(9932,'this means that the method signature of sayhello can have parameters that are bound to the current exchange being routed:public string sayhello(string body) {    return \"hello \" + body; }the ognl feature has specialized support for accessing map and ...',1),(9933,'for example, suppose the getaddress method has a getlines method that returns a list',1),(9934,'you could access the lines by their index values, as follows:simple(\"${body',1),(9935,'lines[0]}\") simple(\"${body',1),(9936,'lines[1]}\") simple(\"${body',1),(9937,'lines[2]}\")if you try to index an element that is out of bounds, an indexoutofboundsexception exception is thrown',1),(9938,'you can use the null-safe operator to suppress this exception:simple(\"${body',1),(9939,'lines[2]}\")if you want to access the last element, you can use last as the index value, as shown here:simple(\"${body',1),(9940,'lines[last]}\")the access support for maps is similar, but you use a key instead of a numeric value as the index',1),(9941,'suppose the message body contains a gettype method that returns a map instance',1),(9942,'you could access the gold entry as follows:simple(\"${body',1),(9943,'type[gold]}\")you could even invoke a method on the gold entry like this:simple(\"${body',1),(9944,'sayhello}\")this concludes our tour of the various features supported by the camel simple language',1),(9945,'we’ll now take a quick look at how to use the simple language from custom java code',1),(9946,'8 using simple from custom java codethe simple language is most often used directly in your camel routes, in either the java dsl or a spring xml file',1),(9947,'but it’s also possible to use it from custom java code',1),(9948,'here’s an example that uses the simple language from a camel processor',1),(9949,'processor; import org',1),(9950,'simplebuilder;public class myprocessor implements processor {    public void process(exchange exchange) throws exception {        simplebuilder simple = new simplebuilder(listing a',1),(9951,'1 using the simple language from custom java code    www',1),(9952,'info470 appendix a simple, the expression language                                       \"${body} contains \'camel\'\");        if (simple',1),(9953,'matches(exchange) {            system',1),(9954,'println(\"this is a camel message\");        } else {            system',1),(9955,'println(\"this is not a camel message\");        }    } }as you can see in listing a',1),(9956,'1, all it takes is creating an instance of simplebuilder, which is capable of evaluating either a predicate or an expression',1),(9957,'in the listing, you use the simple language as a predicate',1),(9958,'to use an expression to say “hello,” you could do the following:simplebuilder simple = new simplebuilder(\"hello ${header',1),(9959,'name}\"); string s = simple',1),(9960,'class); system',1),(9961,'println(s);notice how you specify that you want the response back as a string by passing in string',1),(9962,'class to the evaluate method',1),(9963,'listing a',1),(9964,'1 uses the simple language from within a camel processor, but you’re free to use it anywhere, such as from a custom bean',1),(9965,'just keep in mind that the exchange must be passed into the matches method on the simplebuilder',1),(9966,'9 summarythis appendix covered the simple language, which is an expression language provided with camel',1),(9967,'you saw how well it blends with camel routes, which makes it easy to define predicates in routes, such as those needed when using the content-based router',1),(9968,'we also looked at how easy it was with the simple language to access information from the exchange message by using the built-in variables',1),(9969,'you saw that simple provides functions, such as a date function that formats dates and a bean function that invokes methods on beans',1),(9970,'finally, we covered ognl notation, which makes it even easier to access data from nested beans',1),(9971,'all together, the simple language is a great expression language that should help you with 95 percent of your use cases',1),(9972,'info471appendix b expressions and predicatesexpressions and predicates are built-in types in camel that you’ve seen used throughout this book',1),(9973,'they’re very versatile and are used in different places, but they’re most noticeable in the camel routes',1),(9974,'for example, predicates are used in the message filter and content-based router eips',1),(9975,'expressions are used for computing correlation keys for the aggregator eip, and appendix a covered the simple expression language, which is another testament to the versatility of expressions',1),(9976,'1 expressionsa camel expression (org',1),(9977,'expression) is evaluated at runtime on the instance of exchange that is under processing',1),(9978,'you can use either standard or custom expressions',1),(9979,'1 standard expressionsthe org',1),(9980,'expression interface is as follows:public interface expression {    <t> t evaluate(exchange exchange, class<t> type); }the evaluate method uses generics to specify the desired return type',1),(9981,'syntax sugarcamel provides syntax sugar for working with expressions',1),(9982,'suppose you want to implement a route that can return a message consisting of “hello ” plus the input message',1),(9983,'this can be done using the message translator eip, which leverages an expression to transform a message',1),(9984,'with the help of the syntax sugar, you can use    www',1),(9985,'info472 appendix b expressions and predicatesthe fluent builder style in the java dsl to express that you want to prepend “hello ” to the message body:from(\"direct:hey\")',1),(9986,'transform(body()',1),(9987,'prepend(\"hello \"));alternatively, you could use the simple expression language (covered in appendix a), which may be easier to understand in this example:from(\"direct:hey\")',1),(9988,'transform(simple(\"hello ${body}\"));simple comes in handy when using spring xml, because it’s a scripting language that can be used in xml, as opposed to the former solution, which can’t easily be used in spring xml',1),(9989,'that’s because it’s based on java code, which you can’t use directly in spring xml files',1),(9990,'using expressions with spring xmlin the java dsl, you have all the power of the java language, which you don’t have at your fingertips in spring xml',1),(9991,'the following route isn’t possible in spring xml',1),(9992,'<route>    <from uri=\"direct:hey\"/>    <transform>        <body><prepend>hello </prepend></body>    </transform> </route>instead, you can leverage simple, like this:<route>    <from uri=\"direct:hey\"/>    <transform>        <simple>hello ${body}</simp...',1),(9993,'2 using custom expressionssuppose you need to transform the message in a different way, and only the power of the java programming language can perform the transformation',1),(9994,'in this case, you can use a custom expression, as shown in listing b',1),(9995,'public class myexpression implements expression {    public <t> t evaluate(exchange exchange, class<t> type) {        string body = exchange',1),(9996,'class);        object answer;        if (body',1),(9997,'contains(\"camel\")) {            answer = \"yes camel rocks\";        } else {            answer = \"hello \" + body;listing b',1),(9998,'1 implementing a custom expression    www',1),(9999,'info473predicates        }        return exchange',1),(10000,'convertto(type, answer);    }}using a custom expression in the java dsl is just a matter of providing an instance in the transform eip, as follows:from(\"direct:hey\")',1),(10001,'transform(new myexpression());when using custom expressions in spring xml, you have to define the expression as a bean, and then use the method call expression to invoke the expression:<bean id=\"myexpression\" class=\"camelinaction',1),(10002,'myexpression\"/><camelcontext id=\"camel\" xmlns=\"http://camel',1),(10003,'org/schema/spring\">    <route>        <from uri=\"direct:hey\"/>        <transform>            <method ref=\"myexpression\"/>        </transform>    </route> </camelcontext>you may have noticed that listing b',1),(10004,'1 uses the camel type converter to convert the answer to the given type',1),(10005,'camel offers an expressionadapter class that removes the need for converting',1),(10006,'here’s the same custom expression using the adapter:public class myexpression extends expressionadapter {    @override    public object evaluate(exchange exchange) {        string body = exchange',1),(10007,'class);        if (body',1),(10008,'contains(\"camel\")) {            return \"yes camel rocks\";        } else {            return \"hello \" + body;        }    } }that’s it for expressions',1),(10009,'let’s look now at predicates',1),(10010,'2 predicatesa camel predicate (org',1),(10011,'predicate) is a specialized expression that always returns a boolean type',1),(10012,'this makes predicates useful for yes/no kinds of expressions',1),(10013,'for example, predicates are used with the content-based router eip',1),(10014,'there are standard predicates and also custom and compound predicates',1),(10015,'listing b',1),(10016,'2 implementing custom expression by extending expressionadapter    www',1),(10017,'info474 appendix b expressions and predicates b',1),(10018,'1 standard predicatesthis is the predicate interface:public interface predicate {    boolean matches(exchange exchange); }first we’ll cover the common use cases for using predicates',1),(10019,'syntax sugarcamel provides syntax sugar for working with predicates',1),(10020,'suppose you want to filter messages using the message filter eip and only allow “camel” messages to pass through the filter',1),(10021,'this can easily be defined in a camel java dsl route, as follows:from(\"direct:quotes\")',1),(10022,'contains(\"camel\"))',1),(10023,'to(\"direct:camelquotes\");as you can see, you can define the predicate as if the body contained the word “camel” using the fluent builder style',1),(10024,'implementing this example using spring xml requires a different approach, because spring xml is not java code and it doesn’t provide the same level of syntax sugar',1),(10025,'using predicates with spring xmlwhen you use spring xml, you can use expression languages such as simple (covered in appendix a)',1),(10026,'for example, you can leverage simple as follows:<route>    <from uri=\"direct:quotes\"/>    <filter>        <simple>${body} contains \'camel\'</simple>        <to uri=\"direct:camelquotes\"/>    </filter>    </route>although camel provides a lot of built-i...',1),(10027,'2 using custom predicatessuppose you need to filter messages using a more complex algorithm, or you just feel more comfortable using java code to compute the predicate',1),(10028,'in that case, you can implement a custom predicate',1),(10029,'public class mypredicate implements predicate {    public boolean matches(exchange exchange) {        string body = exchange',1),(10030,'class);        if (body',1),(10031,'contains(\"camel\")) {            return true;        } else if (body',1),(10032,'startswith(\"secret\")) {            return true;listing b',1),(10033,'3 implementing a custom predicate    www',1),(10034,'info475predicates        }        return false;    } }as you can see in listing b',1),(10035,'3, it’s easy to implement a custom predicate',1),(10036,'all you have to do is implement the matches method and return either true or false',1),(10037,'using a custom predicate in a route is just as easy',1),(10038,'you simply provide an instance of it to the filter eip:from(\"direct:quotes\")',1),(10039,'to(\"direct:camelquotes\");when using custom predicates in spring xml, you have to define the predicate as a bean, and then use the method call expression to invoke the predicate',1),(10040,'here’s the equivalent example in spring xml:<bean id=\"mypredicate\" class=\"camelinaction',1),(10041,'mypredicate\"/><camelcontext id=\"camel\" xmlns=\"http://camel',1),(10042,'org/schema/spring\">    <route>        <from uri=\"direct:quotes\"/>        <filter>            <method ref=\"mypredicate\"/>            <to uri=\"direct:camelquotes\"/>        <filter>    </route> </camelcontext>before we end this appendix, we want to show...',1),(10043,'3 using compound predicatesyou may have a number of existing predicates you want to use together',1),(10044,'for example, you may want to define a predicate as follows: is the message a string message and either a camel or a secret quote',1),(10045,'in this definition, you have three predicates:a is the message a string type',1),(10046,'b is the message a \"camel\" quote',1),(10047,'c is the message a \"secret\" quote',1),(10048,'you just have to use these three predicates together in a compound predicate:a and (b or c)implementing this in camel can be done with the help of predicatebuilder, which provides a range of predicate-related methods',1),(10049,'the builder has methods to combine two predicates using the binary operators and and or',1),(10050,'you can then define this in your camel routes, like this:    www',1),(10051,'info476 appendix b expressions and predicatespredicate a = body()',1),(10052,'isinstanceof(string',1),(10053,'class); predicate b = body()',1),(10054,'contains(\"camel\"); predicate c = body()',1),(10055,'startswith(\"secret\");predicate bc = predicatebuilder',1),(10056,'and(a, bc);from(\"direct:quotes\")',1),(10057,'to(\"direct:camelquotes\");first you define the three predicates',1),(10058,'then, to build the compound predicate, you first combine predicates b and c together using the or operator',1),(10059,'then this combined predicate is combined with the a predicate using the and operator',1),(10060,'3 summarythis appendix covered two central concepts used in camel: expressions and predicates',1),(10061,'both are used throughout camel and this book',1),(10062,'in many normal use cases, the built-in predicates and expressions should be sufficient',1),(10063,'in this appendix, you learned how to use custom expressions and predicates',1),(10064,'this should give you enough information that you’ll have no trouble using predicates and expressions with camel',1),(10065,'info477appendix cthe producer and consumer templatesthroughout this book, you’ve seen the producertemplate used as an easy way of sending messages to a camel endpoint',1),(10066,'while it was simple to understand in those cases, there are many more options to the producertemplate',1),(10067,'there is also an analog for consumers—the consumertemplate, which makes consuming messages easy',1),(10068,'both of these templates are inspired by the template utility classes in the spring framework that simplify access to an api',1),(10069,'in spring, you may have used a jmstemplate or jdbctemplate to simplify access to the jms and jdbc apis',1),(10070,'in the case of camel, the producertemplate and consumertemplate interfaces allow you to easily work with producers and consumers',1),(10071,'by “easily work,” we mean you can send a message to any kind of camel component in only one line of code',1),(10072,'for example, the following code sends a jms text message to the activemq jms queue named quotes: producertemplate',1),(10073,'sendbody(\"activemq:quotes\", \"camel rocks\");anyone who has worked with the jms api will know that it takes quite a bit of work to replicate what camel does in that single line of code',1),(10074,'in this appendix, we’ll show you how to use the producertemplate and consumertemplate in detail',1),(10075,'1 the producertemplatethe producertemplate has a lot of methods that at first may seem a bit overwhelming',1),(10076,'but these methods make it powerful and flexible, which in turn makes it a time saver in many situations',1),(10077,'1 lists the most commonly used producertemplate methods',1),(10078,'notice that the table lists two sets of methods: send and request methods',1),(10079,'it’s very important    www',1),(10080,'info478 appendix c the producer and consumer templatesto know the difference between these two',1),(10081,'send methods are used for inonly-style messaging, where you send a message to a given endpoint and don’t expect any reply',1),(10082,'request methods are used for inout-style messaging, where you send a message to a given endpoint and expect and wait for a reply',1),(10083,'the producertemplate has many variations on these methods, which you’ll learn to appreciate over time',1),(10084,'also, for each of these methods there’s a corresponding asynchronous method',1),(10085,'if you wanted to send a message body asynchronously, you could use the asyncsendbody method instead of the sendbody method',1),(10086,'chapter 10 details these methods and how to use them',1),(10087,'1 using the producertemplate here’s an example of how to use the producertemplate to send a message to a jms topic that’s used to audit orders',1),(10088,'public class auditorderbean {    private producertemplate template;    public auditorderbean(camelcontext context) {        template = context',1),(10089,'audit\", order);               } }in the constructor, you create a new instance of the producertemplate b by invoking createproducertemplate on the camelcontext',1),(10090,'this template is then used when sending the audit messages c',1),(10091,'1 the most commonly used producertemplate methodsmethod mep descriptionsendbody inonly sends a message payload to a destination',1),(10092,'sendbodyandheader inonly sends a message payload and a header to a destination',1),(10093,'sendbodyandheaders inonly sends a message payload with a map of headers to a destination',1),(10094,'requestbody inout sends a message payload to a destination',1),(10095,'the reply from the destination is returned',1),(10096,'requestbodyandheader inout sends a message payload and a header to a destination',1),(10097,'the reply from the destination is returned',1),(10098,'requestbodyandheaders inout sends a message payload with a map of headers to a destination',1),(10099,'the reply from the destination is returned',1),(10100,'listing c',1),(10101,'1 using a producertemplate to send a message to a jms topiccreates new templatebsends jms message to topicc    www',1),(10102,'info479the producertemplate to try this out for yourself, find the appendixc/producer directory in the book’s source and run the following maven command:mvn test –dtest=producertemplateinonlytestif you were instead accessing an http service that retu...',1),(10103,'here’s how you could do this',1),(10104,'public class orderstatusbean {    private producertemplate template;    public orderstatusbean() {    }    public orderstatusbean(camelcontext context) {        settemplate(context',1),(10105,'createproducertemplate());      }    public void settemplate(producertemplate template) {        this',1),(10106,'template = template;    }    public string orderstatus(string orderid) {        return template',1),(10107,'requestbody(                          \"http://localhost:8080/order/status',1),(10108,'id=\"                 + orderid,                                          null, string',1),(10109,'class);                        } }  here you use the requestbody method b to invoke a remote http service with a header id set to the specified order id',1),(10110,'you then get the order status returned as a string',1),(10111,'notice that you pass in null for the body because this particular web service only needs the id header',1),(10112,'the http producer will send an http get request in this case',1),(10113,'this example is found in the appendixc/producer directory of the book’s source and can be tested using the following maven command:mvn test –dtest=producertemplateinouttestrather than creating these templates by directly invoking the camelcontext, yo...',1),(10114,'the template and consumertemplate elements within the camelcontext element allow you to create a template and then refer to it later by using its id',1),(10115,'let’s look at this in action',1),(10116,'<bean id=\"orderstatus\" class=\"camelinaction',1),(10117,'orderstatusbean\">  <property name=\"template\" ref=\"producertemplate\"/>      </bean><camelcontext xmlns=\"http://camel',1),(10118,'org/schema/spring\">  <template id=\"producertemplate\"/>                       listing c',1),(10119,'2 using a producertemplate to get a reply from an endpointlisting c',1),(10120,'3 declaring reusable producer and consumer templatesb requests result from web serviceinjects producertemplate beanbcreates producertemplate beanc    www',1),(10121,'info480 appendix c the producer and consumer templates  <consumertemplate id=\"consumertemplate\"/>         <route>    <from uri=\"activemq:order',1),(10122,'status\"/>    <bean ref=\"orderstatus\" method=\"orderstatus\"/>  </route> </camelcontext>within the camelcontext element, you declare reusable templates (c and d) that you can wire into the orderstatusbean from listing c',1),(10123,'2 by using the bean id b',1),(10124,'note you may find the template element name a bit confusing',1),(10125,'why not use the name producertemplate to align with the consumertemplate element',1),(10126,'at first, in camel, there was only the producer template so the xml element was named template',1),(10127,'when the consumer template was introduced, the template element name was kept to be backwards compatible',1),(10128,'you can find listing c',1),(10129,'3 along with a test case in the appendixc/producer directory',1),(10130,'run the test case with the following maven command:mvn test –dtest=producertemplatedefinedinspringtestnext, we’ll focus on the consumertemplate, which you may not have seen much of yet',1),(10131,'2 the consumertemplatethe consumertemplate doesn’t have as many methods as the producertemplate',1),(10132,'it only works using the inonly messaging style, where you use it to poll a given endpoint for a message',1),(10133,'2 lists the methods you’re most likely to use',1),(10134,'let’s take a moment to see how you could use the consumertemplate to solve a problem that’s been asked about again and again on the camel mailing lists: how can you use camel to empty a jms queue',1),(10135,'2 the most commonly used consumertemplate methodsmethod mep descriptionreceive inonly polls an endpoint to receive a message and will wait until a message exists',1),(10136,'the entire message is returned',1),(10137,'receive(timeout) inonly polls an endpoint to receive a message, and will wait until a timeout occurs',1),(10138,'the entire message is returned',1),(10139,'receivenowait inonly polls an endpoint to receive a message, but will not wait if a message doesn’t exist',1),(10140,'the entire message is returned',1),(10141,'receivebody inonly polls an endpoint to receive a message, and will wait until a message exists',1),(10142,'only the message body is returned',1),(10143,'receivebody(timeout) inonly polls an endpoint to receive a message, and will wait until a timeout occurs',1),(10144,'only the message body is returned',1),(10145,'receivebodynowait inonly polls an endpoint to receive a message, but will not wait if a message doesn’t exist',1),(10146,'only the message body is returned',1),(10147,'creates consumertemplate beand    www',1),(10148,'info481the consumertemplatec',1),(10149,'1 using the consumertemplateyou can use the consumertemplate much like the producertemplate',1),(10150,'for example, you can use it to empty a jms queue containing new orders, as shown in listing c',1),(10151,'notice how easily you can use the receivebody method from table c',1),(10152,'2 to retrieve a message from a jms queue',1),(10153,'public class ordercollectorbean {    private consumertemplate consumer;    public void setconsumer(consumertemplate consumer) {            this',1),(10154,'consumer = consumer;    }    public string getorders() {        string order = \"\";        string orders = \"\";        while (order',1),(10155,'= null) {            order = consumer',1),(10156,'receivebody(                     \"activemq:orders\",                                1000, string',1),(10157,'class);                             if (order',1),(10158,'= null) {                orders = orders + \",\" + order;            }        }        return orders;    } }the ordercollectorbean bean uses a setter for the consumertemplate b so you can inject it using spring as follows:<bean id=\"ordercollectorbean\" ...',1),(10159,'ordercollectorbean\">  <property name=\"consumer\" ref=\"consumertemplate\"/>  </bean>of course, this requires that you already have a consumertemplate element defined, as shown in listing c',1),(10160,'tip the template and consumertemplate elements are optional',1),(10161,'if you have no need to refer to them by id or configure any options on them, you can just inject them into your bean by type, using spring’s @autowired annotation',1),(10162,'this is possible because camel creates a default instance of each on startup',1),(10163,'you can then empty the order queue by looping until a null body is returned c',1),(10164,'by using the receivebody method with a timeout of 1000 milliseconds, you’ll wait for 1 second before returning a null when the queue is empty',1),(10165,'this example can be found in the appendixc/consumer directory of the book’s source',1),(10166,'run the test case with the following maven command:mvn testlisting c',1),(10167,'4 using the consumertemplate to poll a jms queuesets consumertemplate on beanbc consumes message from queue    www',1),(10168,'info482 appendix c the producer and consumer templatesthe test case essentially populates the “orders” queue in activemq with a few messages and then invokes the ordercollectorbean to retrieve them',1),(10169,'3 summaryin this appendix we looked at the extremely useful producer and consumer templates',1),(10170,'these two templates give you a way of quickly accessing any camel endpoint with one method call',1),(10171,'in addition to the examples presented in this appendix, the producertemplate is used throughout the book',1),(10172,'info483appendix dthe camel communityas with any open source project, the community behind it is extremely important',1),(10173,'we think of community as an all-encompassing term for the official website, mailing lists, the issue tracker, camel users, projects based on or extending camel, and much more',1),(10174,'it’s hard to measure how vibrant a community is when it has this many moving parts, but it’s important',1),(10175,'having a stagnant or small community will make your (the user’s) experience more difficult when things go wrong and during development in general',1),(10176,'we think camel’s community is highly active and expanding, so you are in luck',1),(10177,'in this appendix we cover some main aspects of the camel community',1),(10178,'1 apache camel websitethe apache camel website, http://camel',1),(10179,'org, will be your main resource when using camel',1),(10180,'you may have already noticed that we reference pages from the camel website throughout the book',1),(10181,'that’s no mistake—it’s a good resource for us too',1),(10182,'on the camel website, you’ll find links for downloads, documentation, support, and many other topics',1),(10183,'2 fusesourcefusesource is a company that offers a productized version of apache camel, as well as training, consulting, and enterprise subscriptions to help it organizations build mission-critical applications with apache camel',1),(10184,'fusesource does the same for other popular apache projects, including servicemix, activemq, and cxf',1),(10185,'the fusesource team includes founders, pmc members, and many of the committers to apache camel, and they know the code better than anyone else does',1),(10186,'the fusesource website includes free downloads, documentation, training videos,    www',1),(10187,'info484 appendix d the camel communitywebinars, and other tools to help developers get started and be successful with apache camel',1),(10188,'3 camel toolingrider is a visual designer tool from fusesource (http://fusesource',1),(10189,'com) for creating, editing, testing, and debugging camel routes',1),(10190,'rider lets you drag and drop all the enterprise integration patterns supported by apache camel onto a canvas and easily wire them together and configure them',1),(10191,'you can use rider as a tool to visualize existing routes, modify them, or create brand new integrations',1),(10192,'rider comes in two flavors: a web version which can be used with any modern web browser, or as an eclipse plugin',1),(10193,'the web version is very handy for viewing and editing routing rules running inside your running application, whether it\'s in a standalone jvm or inside apache tomcat, apache servicemix, or some java ee container',1),(10194,'1 shows using rider inside the google chrome web browser to edit routing rules from a web application running on top of apache tomcat',1),(10195,'if you use eclipse as your ide, using the rider eclipse plugin might be an easier option for you to choose, particularly if you want to design and edit your camel routes as part of your development process',1),(10196,'2 shows using the rider eclipse plugin to edit a spring xml containing camel routing rules',1),(10197,'visit the fusesource rider website (http://rider',1),(10198,'fusesource',1),(10199,'org) for links to all the various rider documentation, screencasts, and download links',1),(10200,'1 rider web tooling visualizes the route',1),(10201,'you can drag and drop eips from the palette to the canvas to design the route at design time',1),(10202,'4 camel-extra projectcamel ships with a large number of components, but there are also other components available separately from the camel-extra project at google code (http:// code',1),(10203,'the main motivator for not including all camel components in the main distribution is licensing',1),(10204,'apache camel is developed and distributed under the apache license, version 2',1),(10205,'the camel-extra project contains components that integrate with libraries that have gpl and lgpl licenses, which are incompatible with apache',1),(10206,'at camel-extra, you’ll find components for integrating with the following, among others:■ the esper event stream processing library■ the hibernate orm tool■ jboss application serverthe components from camel-extra are not officially affiliated with or...',1),(10207,'2 rider eclipse tooling allows developers to design routes using the eclipse ide',1),(10208,'5 jira, mailing lists, and ircwhen things don’t go as planned, you’ll need to get help from people in the camel community',1),(10209,'if you know you have a problem with a demonstrative test case or have a feature request, you can create a ticket in camel’s jira instance: http://issues',1),(10210,'org/ activemq/browse/camel',1),(10211,'from here, one of the camel developers will assign the ticket to themselves and possibly commit a fix for the issue',1),(10212,'it’s also acceptable to attach a source code patch that fixes the issue directly to the jira ticket (http://camel',1),(10213,'this allows a camel developer to apply your patch to the camel source',1),(10214,'when you have general questions, you can send a message to the camel user list (http://camel',1),(10215,'org/mailing-lists',1),(10216,'html), which will be answered by one of the camel developers or another camel user',1),(10217,'you can even chat in real time with a camel developer or user on the camel irc chat room (http://camel',1),(10218,'6 camel quick reference cardthere’s a printable quick reference card available for several of camel’s eips at dzone',1),(10219,'com/refcardz/enterprise-integration)',1),(10220,'this card contains a short description of each eip, followed by java dsl and spring xml snippets that you can reuse in your own applications',1),(10221,'7 other resourcesthe camel website has an extensive collection of links to external articles, blogs, projects, presentations, podcasts, and other sources that cover camel (http:// camel',1),(10222,'there’s also a link collection to other third-party camel projects and companies who use camel (http://camel',1),(10223,'org/user-stories',1),(10224,'if you’ve written a blog entry or article, or your company uses camel and wants to have a link added, please contact the camel team on the mailing list',1),(10225,'info487appendix eakka and camelby martin krasserakka aims to be the platform for the next-generation, event-driven, scalable, and fault-tolerant architectures on the jvm',1),(10226,'one of the core features of akka is an implementation of the actor model',1),(10227,'it alleviates the developer from having to deal with explicit locking and thread management',1),(10228,'using the actor model raises the abstraction level and provides a better platform for building correct concurrent and scalable applications',1),(10229,'akka comes with a camel integration module that allows akka actors to interact with communication partners over a great variety of protocols and apis',1),(10230,'this appendix presents selected akka-camel integration features by example',1),(10231,'in particular, it covers the following:■ an introduction to akka’s actor api■ implementing consumer actors for receiving messages from camel endpoints■ implementing producer actors for sending messages to camel endpoints■ using and customizing akka’s...',1),(10232,'the examples only scratch the surface of what can be done with akka',1),(10233,'interested readers may want to refer to the akka online documentation for details (http://akkasource',1),(10234,'the actor model is also discussed on wikipedia: http:// en',1),(10235,'the code examples in this appendix are available in the source code for the book, and they include a readme file that explains how to build and run them',1),(10236,'info488 appendix e akka and camel akka offers both a scala api and a java api for actors',1),(10237,'we’ll assume that you already have a basic knowledge of the scala programming language',1),(10238,'1 introducing the akka-camel integrationin the actor model, each object is an actor; an actor is an entity that has a mailbox and a behavior',1),(10239,'messages can be exchanged between actors, and they’ll be buffered in the mailbox',1),(10240,'upon receiving a message, the behavior of the actor is executed',1),(10241,'an actor’s behavior can be any piece of code, such as code that changes internal state, sends a number of messages to other actors, creates a number of actors, or assumes new behavior for the next message to be received',1),(10242,'an important property of the actor model is that there’s no shared state between actors; all communications happen by means of messages',1),(10243,'messages are exchanged asynchronously, but akka supports waiting for responses as well',1),(10244,'also, messages are always processed sequentially by an actor',1),(10245,'there’s no concurrent execution of a single actor instance, but different actor instances can process their messages concurrently',1),(10246,'akka, itself, is written in scala, so applications often use akka’s scala api for exchanging messages with actors',1),(10247,'but this is not always an option, especially in the domain of application integration',1),(10248,'existing applications often can’t be modified to use the scala api directly, but can use file transfer on ftp servers or low-level tcp to exchange messages with other applications',1),(10249,'for existing applications to communicate with actors, a separate integration layer is needed, and this is where camel fits in: camel is designed around the messaging paradigm, and it supports asynchronous message exchanges as well',1),(10250,'for implementing an integration layer between akka actors and third-party applications or components, akka provides the akka-camel module (http://doc',1),(10251,'akkasource',1),(10252,'with the akka-camel module, it’s almost trivial to implement message exchanges with actors over protocols and apis such as http, soap, tcp, ftp, smtp, jms, and others',1),(10253,'actors can both consume messages from and produce messages for camel endpoints',1),(10254,'another important feature of the akka-camel module is that it fully supports camel’s asynchronous, nonblocking routing engine: asynchronous message exchanges with actors can be extended to a number of additional protocols and apis',1),(10255,'furthermore, all camel components are supported in a generic way: whenever a new camel component is released by the camel community, it can readily be used to exchange messages with akka actors',1),(10256,'the following section gives a brief introduction to akka’s actor api and shows how to create actors and exchange messages with them',1),(10257,'2 getting started with akka actorslet’s start with a simple example: an actor that prints any message it receives to stdout',1),(10258,'when it receives a special stop message, the actor stops itself',1),(10259,'info489getting started with akka actors an actor implementation class must extend the actor trait and implement the receive partial function',1),(10260,'incoming messages are matched against the case patterns defined in receive',1),(10261,'actorclass simpleactor extends actor {  protected def receive = {    case \"stop\" => self',1),(10262,'stop    case msg    => println(\"message = %s\" format msg)  } }if one of the patterns matches, the statement after => is executed',1),(10263,'akka’s actor api doesn’t impose any constraints on the message type and format—any scala object can be sent to an actor',1),(10264,'before sending a message to the preceding actor, clients need to create and start an instance of simpleactor',1),(10265,'this is done with the actorof factory method, which returns an actor reference, and by calling the start method on that reference',1),(10266,'this can be done as follows, where the client creates the actor and sends two messages to it:import akka',1),(10267,'_val simpleactor = actorof[simpleactor]',1),(10268,'startsimpleactor',1),(10269,'\"hello akka\" simpleactor',1),(10270,'\"stop\"the actor reference, once it’s created, is also used for sending messages to the actor',1),(10271,'(bang) operator, clients send messages with fire-and-forget semantics',1),(10272,'operator adds the message to the actor’s mailbox, and the actor processes the message asynchronously',1),(10273,'the preceding example first sends a \"hello akka\" string that matches the second pattern in the receive method',1),(10274,'the message is therefore written to stdout',1),(10275,'the \"stop\" message sent afterwards is matched by the first pattern, which stops the actor',1),(10276,'note that sending a message to a stopped actor throws an exception',1),(10277,'to run the example from the appendixe directory, enter sbt run on the command line and select camelinaction',1),(10278,'sectione2 from the list of main classes',1),(10279,'note the source code for this book contains a readme file in the appendixe directory that explains how to install and set up the simple build tool (sbt)',1),(10280,'all the examples in this appendix can be run by executing sbt run from the command line',1),(10281,'this command displays a menu, from which you can choose the example to run by its number',1),(10282,'the preceding example only uses a small part of akka’s actor api',1),(10283,'it demonstrates how clients can send messages to actors and how actors can match and process these messages',1),(10284,'the next step is to add an additional interface to the actor so that it can receive messages via a camel endpoint',1),(10285,'3 consuming messages from camel endpointsif you want to make actors accessible via camel endpoints, actor classes need to mixin the consumer trait and implement the endpointuri method',1),(10286,'consumer actors can be used for both one-way and request-response messaging',1),(10287,'1 one-way messaging the following listing extends the example from the previous section and enables the actor to receive messages from a seda endpoint',1),(10288,'{consumer, message}class sedaconsumer extends actor with consumer {  def endpointuri = \"seda:example\"  protected def receive = {    case message(\"stop\", headers) => self',1),(10289,'stop    case message(body, headers)   => println(\"message = %s\" format body)  } }the endpointuri method is implemented to return a seda endpoint uri',1),(10290,'this causes the actor to consume messages from the seda:example queue once it is started',1),(10291,'one important difference, compared to simpleactor, is that the received messages are of type message, which are immutable representations of camel messages',1),(10292,'a message object can be used for pattern matching, and the message body and headers can be bound to variables, as shown in listing e',1),(10293,'for any consumer actor to receive messages, an application needs to start a camelservice before starting a consumer actor: import akka',1),(10294,'_val service = camelservicemanager',1),(10295,'startcamelserviceservice',1),(10296,'awaitendpointactivation(1) {  actorof[sedaconsumer]',1),(10297,'sendbody(\"seda:example\", \"hello akka-camel\")    template',1),(10298,'sendbody(\"seda:example\", \"stop\") }service',1),(10299,'stopa camelservice can be started with camelservicemanager',1),(10300,'the started camelservice instance is returned from the startcamelservice method call',1),(10301,'when a consumer actor is started, the camelservice is notified and it will create and start (activate) a route from the specified endpoint to the actor',1),(10302,'this is donelisting e',1),(10303,'1 actor as consumer receiving messages from a seda endpoint    www',1),(10304,'info491consuming messages from camel endpointsasynchronously, so if an application wants to wait for a certain number of endpoints to be activated, it can do so with the awaitendpointactivation method',1),(10305,'this method blocks until the expected number of endpoints have been activated in the block that follows that method',1),(10306,'the application is then ready to produce messages to the seda:example queue',1),(10307,'a camel producertemplate for sending messages can be obtained via camelcontextmanager',1),(10308,'this returns an instance of option[producertemplate] that can be used with a for comprehension',1),(10309,'if the camelservice has been started, the body of the for comprehension will be executed once with the current producertemplate bound to the template variable',1),(10310,'if the camelservice hasn’t been started, the for body won’t be executed at all',1),(10311,'alternatively, applications may also use camelcontextmanager',1),(10312,'mandatorytemplate which returns the producertemplate directly or throws an illegalstateexception if the camelservice hasn’t been started',1),(10313,'the application first sends a message that will be printed to stdout, and then it sends a special stop message that stops the actor',1),(10314,'alternatively, clients can also send message objects directly via the native actor api:actor',1),(10315,'message(\"hello akka-camel\")finally, the application gracefully shuts down the camelservice',1),(10316,'sedaconsumer is an actor that doesn’t reply to the initial sender',1),(10317,'request-response message exchanges require a minor addition, as shown in the next section for a consumer actor with a jetty endpoint',1),(10318,'2 request-response messaging listing e',1),(10319,'2 shows how an actor can reply to the initial sender using the self',1),(10320,'in this example, the initial sender is an http client that communicates with the actor over a jetty endpoint',1),(10321,'class httpconsumer1 extends actor with consumer {  def endpointuri = \"jetty:http://0',1),(10322,'0:8811/consumer1\"  protected def receive = {    case msg: message => self',1),(10323,'reply(\"received %s\"                                    format msg',1),(10324,'bodyas[string])  } } note valid initial senders can either be other actors or camel routes to that actor',1),(10325,'this is an implementation detail: for the receiving actor, both initial sender types appear to be actor references',1),(10326,'when posting a message to http://localhost:8811/consumer1, the actor converts the received message body to a string and prepends \"received \" to it',1),(10327,'the result islisting e',1),(10328,'2 actor acting as consumer which sends back replies to sender    www',1),(10329,'info492 appendix e akka and camelreturned to the http client with the self',1),(10330,'the self object is the selfreference to the current actor',1),(10331,'the reply message is a plain string that’s internally converted to a camel message before returning it to the jetty endpoint',1),(10332,'if applications additionally want to add or modify response headers, they can do so by returning a message object containing the response body and headers',1),(10333,'the next example creates an xml response and sets the content-type header to application/xml',1),(10334,'class httpconsumer2 extends actor with consumer {  def endpointuri = \"jetty:http://0',1),(10335,'0:8811/consumer2\"  protected def receive = {    case msg: message => {      val body = \"<received>%s</received>\" format msg',1),(10336,'bodyas[string]      val headers = map(\"content-type\" -> \"application/xml\")      self',1),(10337,'reply(message(body, headers))    }  } }consumer actors wait for their clients to initiate message exchanges',1),(10338,'if actors themselves want to initiate a message exchange with a camel endpoint, a different approach must be taken',1),(10339,'4 producing messages to camel endpointsfor producing messages to camel endpoints, actors have two options',1),(10340,'they can either use a camel producertemplate directly or mixin the producer trait in the actor implementation class',1),(10341,'this section will cover the use of the producer trait',1),(10342,'the use of the camel producertemplate is explained in appendix c',1),(10343,'the advantage of using the producer trait is that actors fully leverage camel’s asynchronous routing engine',1),(10344,'to produce messages to a camel endpoint, an actor must implement the endpointuri method from the producer trait, as follows',1),(10345,'producerclass httpproducer1 extends actor with producer {  def endpointuri = \"http://localhost:8811/consumer2\" }in this example, any message sent to an instance of httpproducer1 will be posted to http://localhost:8811/consumer2, which is the endpoint...',1),(10346,'3 (these two actors are communicating over http)',1),(10347,'in the following code example, an application sends a message to the producer actor with the',1),(10348,'(bangbang) operator, which means it sends and receives eventually:listing e',1),(10349,'3 an actor sending back xml messages as reply to senderlisting e',1),(10350,'4 an actor as a producer sending messages to the defined http endpoint    www',1),(10351,'info493producing messages to camel endpointsthe message is sent to the actor asynchronously, but the caller also waits for a response',1),(10352,'{failure, message}val httpproducer1 = actorof[httpproducer1]',1),(10353,'\"camel rocks\" match { case some(m: message) => println(\"response = %s\" format m',1),(10354,'bodyas[string]) case some(f: failure) => println(\"failure = %s\" format f',1),(10355,'cause',1),(10356,'getmessage) case none             => println(\"timeout\") }the return type of',1),(10357,'is option[any]',1),(10358,'for a producer actor at runtime, the type can be one of the following:■ some(message) for a normal response■ some(failure) if the message exchange with the endpoint failed■ none if waiting for a response timed outthe timeout for a response is defined...',1),(10359,'the default value is 5000 (ms) and it can be changed by applications',1),(10360,'as you’ve probably realized, httpproducer1 doesn’t implement a receive method',1),(10361,'this is because the producer trait provides a default receive implementation that’s inherited by httpproducer1',1),(10362,'receive is to send messages to the specified endpoint and to return the result to the initial sender',1),(10363,'in the preceding example, the initial sender obtains the result from the',1),(10364,'actor classes can override the producer',1),(10365,'receiveafterproduce method to, for example, forward the result to another actor, instead of returning it to the original sender',1),(10366,'in this case, the original sender should use the',1),(10367,'operator for sending the message; otherwise it will wait for a response until timeout',1),(10368,'in the following example, the producer actor simply writes the result to stdout instead of returning it to the sender',1),(10369,'class httpproducer2 extends actor with producer {  def endpointuri = \"http://localhost:8811/consumer3\"  override protected def receiveafterproduce = {    case m: message => println(\"response = %s\" format m',1),(10370,'bodyas[string])    case f: failure => println(\"failure = %s\" format f',1),(10371,'cause',1),(10372,'getmessage)  } }a producer actor by default initiates in-out message exchanges with the specified endpoint',1),(10373,'for initiating in-only message exchanges, producer implementations must either override the producer',1),(10374,'the following code shows the latter approach by mixin the oneway trait:    www',1),(10375,'{oneway, producer}class jmsproducer extends actor with producer with oneway {  def endpointuri = \"jms:queue:test\" }for producer and consumer actors to work with camel, applications need to start the camelservice, which sets up the camelcontext for an...',1),(10376,'the next section shows some examples of how applications can customize the process of setting up a camelcontext',1),(10377,'5 customizing camelservice when started, a camelservice creates a default camelcontext and makes it accessible via the camelcontextmanager singleton',1),(10378,'applications can access the current camelcontext within a for (context <- camelcontextmanager',1),(10379,'context) { … } comprehension and make any modifications they want',1),(10380,'alternatively, a camelcontext can also be obtained directly via camelcontextmanager',1),(10381,'this will throw an illegalstateexception if the camelservice hasn’t been started',1),(10382,'but modifying a camelcontext after it’s been started isn’t always an option',1),(10383,'for example, applications may want to use their own camelcontext implementations or to make some modifications before the camelcontext is started',1),(10384,'this can be achieved either programmatically or declaratively, as explained in the following subsections',1),(10385,'1 programmatic customizationif an application wants to disable jmx, for example, it should do so before the camelcontext is started',1),(10386,'this can be achieved by manually initializing the camelcontextmanager and calling disablejmx on the created camelcontext:import akka',1),(10387,'disablejmxcamelservicemanager',1),(10388,'init method creates a defaultcamelcontext instance, but applications may also pass any other camelcontext instance as an argument to the init method:import akka',1),(10389,'disablejmxcamelservicemanager',1),(10390,'startcamelservicewhen the camelservice is started, it will also start the user-defined camelcontext',1),(10391,'info495customizing camelservice e',1),(10392,'2 declarative customizationalternatively, a camelservice can be created and configured within a spring application context',1),(10393,'the following spring xml configuration uses the akka and camel xml namespaces to set up a camelservice and a camelcontext respectively',1),(10394,'the custom camelcontext is injected into the camelservice',1),(10395,'<beans xmlns=\"http://www',1),(10396,'org/schema/beans\"       xmlns:xsi=\"http://www',1),(10397,'org/2001/xmlschema-instance\"       xmlns:akka=\"http://www',1),(10398,'akkasource',1),(10399,'org/schema/akka\"       xmlns:camel=\"http://camel',1),(10400,'org/schema/spring\"       xsi:schemalocation=\" http://www',1),(10401,'org/schema/beans http://www',1),(10402,'org/schema/beans/spring-beans-2',1),(10403,'xsd http://www',1),(10404,'akkasource',1),(10405,'org/schema/akka http://scalablesolutions',1),(10406,'xsd http://camel',1),(10407,'org/schema/spring http://camel',1),(10408,'org/schema/spring/camel-spring',1),(10409,'xsd\">  <camel:camelcontext id=\"camelcontext\">                                                          </camel:camelcontext>  <akka:camel-service id=\"camelservice\">             <akka:camel-context ref=\"camelcontext\" />  </akka:camel-service></beans>a...',1),(10410,'if an application wants to interact with the camelservice directly, it can obtain the running camelservice instance either via camelservicemanager',1),(10411,'the following code shows how you can use the former approach for obtaining the camelservice from the camelservicemananger:import org',1),(10412,'classpathxmlapplicationcontext import akka',1),(10413,'_val appctx = new classpathxmlapplicationcontext(\"/sample',1),(10414,'destroywhen the application context (appctx) is destroyed, the camelservice and the camelcontext are shut down as well',1),(10415,'in all the examples so far, routes to actors have been automatically created by the camelservice',1),(10416,'whenever a consumer actor has been started, this was detected by the camelservice and a route from the actor’s endpoint to the actor itself was added tolisting e',1),(10417,'5 spring xml file setting up akka and camel   akka camelservicebdo something with camelservice    www',1),(10418,'alternatively, applications can also define custom routes to actors by using akka’s actorcomponent',1),(10419,'6 the actor componentaccessing an actor from a camel route is done with the actor component, a camel component for producing messages to actors',1),(10420,'for example, when starting sedaconsumer from listing e',1),(10421,'1, the camelservice adds the following (simplified) route to the camelcontext: from(\"seda:example\")',1),(10422,'to(\"actor:uuid:<actoruuid>\")the route starts from seda:example and goes to the started sedaconsumer instance, where <actoruuid> is the consumer actor’s uuid',1),(10423,'an actor’s uuid can be obtained from its reference',1),(10424,'endpoint uris starting with the actor scheme are used to produce messages to actors',1),(10425,'the actor component isn’t only intended for internal use but can also be used by user-defined camel routes to access any actor; in this case, the target actor doesn’t need to implement the consumer trait',1),(10426,'the actor component also supports camel’s asynchronous routing engine and allows asynchronous in-only and in-out message exchanges with actors',1),(10427,'listing e',1),(10428,'6 shows an example: a user-defined camel route that sends a message to an instance of httpproducer1 (the producer actor from listing e',1),(10429,'this producer actor sends a message to http://localhost:8811/consumer2',1),(10430,'if the communication with the http service succeeds, the producer actor returns a message object containing the service response or a failure object with the cause of the failure',1),(10431,'if the producer can’t connect to the service, for example, the failure cause will be a connectexception',1),(10432,'this exception can be handled in the route',1),(10433,'other exceptions are possible, but they aren’t included here, to keep the example simple',1),(10434,'_class customroute(uuid: uuid) extends routebuilder {  def configure = {    from(\"direct:test\")',1),(10435,'onexception(classof[connectexception])',1),(10436,'transform',1),(10437,'constant(\"feel bad\")',1),(10438,'to(\"actor:uuid:%s\" format uuid)                     } }val producer = actorof[httpproducer1]',1),(10439,'startcamelservicelisting e',1),(10440,'6 camel route sending message to akka actorcamel route sending to actor    www',1),(10441,'addroutes(new customroute(producer',1),(10442,'requestbody(\"direct:test\", \"feel good\", classof[string]) match {    case \"<received>feel good</received>\" => println(\"communication ok\")    case \"feel bad\" => println(\"communication failed\")    case _          => println(\"unexpected response\")  } }af...',1),(10443,'it then uses a producertemplate to initiate an in-out exchange with the route and tries to match the response, where the response either comes from the http service or from the error handler',1),(10444,'we’ll now move on to a more advanced example that applies many of the features described so far',1),(10445,'it combines different actor types to a simple integration solution for transforming the content of a web page',1),(10446,'7 a routing examplecamel applications usually define message-processing routes with the camel dsl',1),(10447,'akka applications can alternatively define networks of interconnected actors, in combination with consumer and producer actors, to set up message-processing routes',1),(10448,'this section shows a simple example of how to set up a message-processing route with actors',1),(10449,'the goal of this example is to display the akka homepage (http://akkasource',1),(10450,'org) in a browser, with occurrences of akka in the page content replaced with an uppercase akka',1),(10451,'the example combines a consumer and a producer actor with another actor that transforms the content of the homepage',1),(10452,'the setup of the example application is sketched in figure e',1),(10453,'1; the corresponding code is shown in listing e',1),(10454,'1 the setup of the example application',1),(10455,'a consumer and a producer actor provide connectivity to external systems',1),(10456,'the consumer actor receives requests from a browser and forwards them to a producer actor, which fetches the html page',1),(10457,'the html page is then forwarded to an actor that transforms the content of the page and returns the transformation result to the initial sender, so that it can be displayed in the browser',1),(10458,'_class httpconsumer(producer: actorref) extends actor with consumer {  def endpointuri = \"jetty:http://0',1),(10459,'0:8875/\"  protected def receive = {    case msg => producer forward msg  } }class httpproducer(transformer: actorref) extends actor with producer {  def endpointuri = \"jetty:http://akkasource',1),(10460,'bridgeendpoint=true\"  override protected def receivebeforeproduce = {    case msg: message =>      msg',1),(10461,'setheaders(msg',1),(10462,'headers(set(exchange',1),(10463,'http_path)))     }  override protected def receiveafterproduce = {    case msg => transformer forward msg              } }class httptransformer extends actor {         protected def receive = {    case msg: failure => self',1),(10464,'reply(msg)    case msg: message => self',1),(10465,'reply(msg',1),(10466,'transformbody[string] {      _ replaceall (\"akka \", \"akka \")    })  } }camelservicemanager',1),(10467,'startcamelserviceval httptransformer = actorof(new httptransformer)',1),(10468,'start val httpproducer = actorof(new httpproducer(httptransformer))',1),(10469,'start val httpconsumer = actorof(new httpconsumer(httpproducer))',1),(10470,'starthttpconsumer is an actor that accepts http get requests on port 8875 and is configured to forward requests to an instance of httpproducer',1),(10471,'when an actor forwards a message to another actor, it forwards the initial sender reference as well',1),(10472,'this reference is needed later for returning the result to the initial sender',1),(10473,'a forwarded message causes the httpproducer to send a get request to http:// akkasource',1),(10474,'before doing so, it drops all headers b from the request message, except for the http_path header, which is needed by the bridge endpoint',1),(10475,'this preprocessing is done in the producer’s receivebeforeproduce method',1),(10476,'the received html content from http://akkasource',1),(10477,'org is then forwarded c to an instance of httptransformer',1),(10478,'the httptransformer d is an actor that replaces all occurrences of akka in the message body with an uppercase akka and returns the result to the initial sender',1),(10479,'the reference to the initial sender has been forwarded by the producer actor c',1),(10480,'listing e',1),(10481,'7 akka consumer and producer exampledrops message headers except http_pathbforwards message to transformerctransforms the messaged    www',1),(10482,'info499summary after starting the camelservice, the actors are wired and started',1),(10483,'to run the example from the appendixe directory, enter sbt run on the command line, and select camelinaction',1),(10484,'sectione7 from the list of main classes',1),(10485,'access http://localhost:8875 from a browser, and a transformed version of the akka homepage should be displayed',1),(10486,'finally, it should be noted that the actors and the jetty endpoints in this example exchange messages asynchronously; no single thread is allocated or blocked for the full duration of an in-out message exchange',1),(10487,'although it’s not critical for this example, exchanging messages asynchronously can help to save server resources, especially in applications with long-running request-response cycles and frequent client requests',1),(10488,'8 summarythis appendix shows you how to exchange messages with akka actors over protocols and apis supported by the great variety of camel components',1),(10489,'you saw how consumer actors can receive messages from camel endpoints and producer actors can send messages to camel endpoints',1),(10490,'setting up a camel endpoint for an actor is as easy as defining an endpoint uri for that actor',1),(10491,'the prerequisite for running consumer and producer actors is a started camelservice that manages an application’s camelcontext',1),(10492,'applications can configure the camelservice either programmatically or declaratively based on custom spring xml schemas provided by akka and camel',1),(10493,'you also saw how to use akka’s actor component to access any actor from a userdefined camel route',1),(10494,'actor endpoints are implemented by defining an actor endpoint uri in the route',1),(10495,'a routing example finally demonstrated how to combine consumer and producer actors to develop a simple integration solution for transforming the content of a web page',1),(10496,'the features described in this appendix are those of akka version 1',1),(10497,'if you want to keep track of the latest development activities, get in touch with the akka community via the akka user list (http://groups',1),(10498,'com/group/akka-user) and the akka developer list (http://groups',1),(10499,'your feedback is highly welcome',1),(10500,'info501indexsymbols--> operator 381 ==> operator 381aacid 284, 297, 300 activemq 4, 27dead letter queue 294 tcp connectors 288 vm protocol 288activemq component 292, 303, 457 activemqconnectionfactory 27 addinterceptstrategy method 378 addroutes 28 a...',1),(10501,'infoindex502akka (continued) camelcontextmanager 494 sending message 491camelservice 490, 495 customize 494–495camelservicemanager490, 495 consume from camel489–492 disable jmx 494 endpointuri 490–492, 497 forwarding message 493, 498 immutable messag...',1),(10502,'generate goal 362archetypes 360 artifactid 361 central repository 12, 364 configuring local maven repository in eclipse 368 convention over configuration 361 data directory 11 dependency tree 365 directories installed 11 generating an osgi bundle 438...',1),(10503,'xml 11, 361 quickstart archetype 360 recommended reading 12 src directory 11 transitive dependencies 364using the m2eclipse plugin 368apache mina 216 apache openjpa 227 apache servicemix 353, 414message bus 353 scalability 353apache tomcat 215, 428 d...',1),(10504,'infoindex 503bean (continued) parameter binding 111–119@bean 117 @body 107, 114 built-in types 113–114 exception 148 @header 107, 114 multiple parameters112–119 @namespaceprefix 118 single parameter 111 table of annotations 114 table of build in type...',1),(10505,'csv 82 @csvrecord 81 data types used 81 @datafield 81 specifying package name 82 using csv 80using fix 83 using fixed length 83@body 107, 113–114 browse 191 builder pattern 68ccamel 4 alternative languages380–384 archetypeslist of archetypes 361 usin...',1),(10506,'infoindex504camel (continued) routing and mediation engine 5 routing annotations 444, 450 @consume example 446 dependencies 446 injecting a proxy producer 449 loading annotated classes into camel 446 @produce example 449 receiving messages with @cons...',1),(10507,'camel directory 194 camel extensions, junit 155 camel extra project 436, 485 camel registry 99 camel test kit 155–166 camel-core module, components 191 camelcontext 11, 190, 411accessing via processor 64 createnewproducertemplate method 478 graceful ...',1),(10508,'infoindex 505components (continued) bean 191example using inout mep 201 how beancomponent is resolved 191 camel-core module 191 creating a custom component 371 cxf 205code-first development 215–216configuring using endpoint bean 207configuring using ...',1),(10509,'infoindex506components (continued) jpa 224–229 connecting camel jpa to openjpa 227 consumedelete option 225 consumelockentity option 225 consumer',1),(10510,'delay option 225 consumer',1),(10511,'initialdelay option 225 consumer',1),(10512,'namedquery option 225 consumer',1),(10513,'nativequery option 225 consumer',1),(10514,'query option 225 @entity 226 example 228 flushonsend option 225 manually querying the database 228 maven dependencies 224 maximumresults option 225 maxmessagesperpoll option 225 persistenceunit option 225 persistenceunitname 227 transactionmanager op...',1),(10515,'repeatinterval option 234 uri options 234ref 192 seda 192, 230, 455concurrentconsumers option 230 multipleconsumers option 230–231pros and cons 230 publish-subscribe 231 size option 230 timeout option 230 uri options 230 waitfortasktocomplete option ...',1),(10516,'infoindex 507<context:property-placeholder> tag 165contextconfiglocation 431 convention over configuration 7 correlation id 397, 399 <correlationexpression> tag 241 cron expressions 235 csv 23, 44table of data types used 80 transforming using bean 66...',1),(10517,'39 dynamic router eip 238–239, 270–272 @dynamicrouter 271eeai 451 eclipse 29, 210, 359configuring local maven repository 368 import wizard 367 m2_repo variable 368 m2eclipse plugin 368 maven eclipse plugin 366 package explorer 367 using camel 366ecli...',1),(10518,'infoindex508eip (continued) composed message processor 238, 262 concurrent consumers318, 322–323 content enricher 242 content-based router295, 304 content-based router (cbr) 44 example 45 routing after a cbr 47dead letter channel124, 126–128, 135, 25...',1),(10519,'pollenrich 71enterprise integration patterns (eips) 5 implemented as processor 33enterprise service bus (esb) 353 camel is not an esb 4@entity 226 entity manager 227 error handlerhandlefault 415 load balancer eip failover 277 transactionerrorhandler ...',1),(10520,'dofinally144 error handlers provided124–129 errorhandler 127, 135 errorhandlerref 137 exceptioncaused exception 147 context scope 144 continued 146 custom exception handling 146–148 detour message 138 exception hierarchy 139 gap detection 140 handle ...',1),(10521,'infoindex 509error handling (continued) handle fault 138 ignoring exception 148 lifecycle 124 logging error handler 128 no error handler 128 onexception 143, 149, 178 original input message 126 pollingconsumerpollstrategy124 redeliver 125 redeliverya...',1),(10522,'caused_exception 127 expression 471compound 68 custom 68 evaluate 471–472 expressionadapter 473 fluent builder, syntax sugar 472 message translator eip 471transform 472 method call 69, 259, 473, 475 syntax sugar 471 using 471–472custom expression 472...',1),(10523,'infoindex510importing generated eclipse project 29in-flight messages 425 in-flight registry 420 in-memory messaging 229 @inonly 459 inonly mep 218, 478 @inout 459 inout mep 201, 230, 478 inspecting messages 55 integration testing 183–187 interceptors...',1),(10524,'see jax-ws java dsl 28, 30–33 java ee container 437 java management extensions',1),(10525,'see jmx java message service',1),(10526,'see jms java persistence architecture',1),(10527,'see jpa java transaction api (jta) 298 java web start 441 java',1),(10528,'message 203 javax',1),(10529,'persistence',1),(10530,'index 77 using annotations 76 @xmlaccessortype 76 @xmlattribute 76 @xmlrootelement 76jbi 414 jboss application server 428starting 436 jconsole 388, 390, 401, 405, 408, 419 jdbc 221, 477 jdbc, data source 288 jdbctemplate 477 jettycontinuations 354dep...',1),(10531,'txt 9 load balancer eip 238–239, 272–280 across remote service 272 concept behind 272 introducing 272–274 strategy 272, 274–275custom 274 failover 277–278 failover by exception 276 failover inherit error handler 277 failover maximum attempts 277 fail...',1),(10532,'infoindex 511mm2_repo variable 368 m2eclipse plugin 368creating new camel projects 369installation instructions 369 performance issues 369 running a project 370 using archetypes 369main 430 main class 430 management 407jmx @managedattribute 407 manag...',1),(10533,'txt 9 notificationconfiguring eventnotifier 403 eventnotifier 403 filtering event 403 loggingeventnotifier402–403 publisheventnotifier 402 seteventnotifier 403 using 402–405 using custom eventnotifier 403–405 notifybuilder 185–187oobject/relational m...',1),(10534,'infoindex512ognl (continued) accessing map 469 bean parameter binding 469 null safe operator 469oncompletion 420–421 different from synchronization 313 oncompleteonly option 422 onfailureonly option 422 onwhen 422 scope 313 using 312–313onexception 1...',1),(10535,'xml 228 @php 116 php 45 ping service 386 pipeline 32plain old java object (pojo) 7, 23, 205 messaging 444pollenrich 71 vs',1),(10536,'enrich 71pom 11 predicate 473combining predicates 475 compound predicate 475and 476 or 476 predicatebuilder 476custom predicate 474–475 using in java dsl 475 using in spring xml 475definition 474 filter eip 474 matches 474 syntax sugar 474fluent buil...',1),(10537,'see pom project templates 360 @properties 114 properties 192 properties component 161–165 @property 114 property placeholders 164–166 <proxy> tag 458 proxybuilder 460 proxyhelper 458 proxying camel route as a interface 455 publish/subscribe 26@python...',1),(10538,'txt 9 recipient list eip 147 @recipientlist 54 recovery, aggregator eip 251 redelivery 130–135asynchronous 134 attempts 122 policy 130 policy options 130registry 25applicationcontextregistry99, 101 camel 99 jndiregistry 99, 101 osgiserviceregistry 99...',1),(10539,'infoindex 513route (continued) difference between stop and suspend 428 flip routes being active 422 lookup by id 182 oncompletion 420 ordering 416–418 routedefinition 182 routepolicy 422start route 422 stop route 422shared route 427 startuporder 416 ...',1),(10540,'see soa servicemix 4 sftp 196 shutdown 424defer 425, 427 graceful 424timeout 425 reliable 424–425, 427 shutdownroute option 427 suspend 425shutdownroute method 427shutdownroute',1),(10541,'defer 427 shutdownstrategy 425 @simple 116 simplebuilt-in file variables 465–466 file extension 466 filename 465–466built-in functions 463–465 bean 464 bodyas 463 date 464 properties 464–465built-in operators 466–468 automatic type coerce 467 combini...',1),(10542,'see soap <simple> tag 260    www',1),(10543,'infoindex514simple, invoke method on message body 260 simpledataformat 195 simpleregistry registry 99–100 soa 205 soap 138, 205, 211 soapui 433 sonicmq 42 split big file 318 <split> tag 261, 264 splitter eip 238, 255–266aggregate 258–264aggregationst...',1),(10544,'scanner 261 spring 34, 361–362, 411bean wiring example 34 beanpostprocessor 447 classpathxmlapplicationcontext 35, 160 configuring camel components 36 context listener 431 defining bean in spring xml 95 invoking a bean 95 jmx 407@managedattribute 407...',1),(10545,'handlers 412 springcamelcontext 447 sql 222, 228 ssl 196 staged event-driven architecture (seda) 322, 340, 342 concurrency 322–323 concurrent consumer 323starting camel 411–419 autostartup 412 startup diagram 412reliable startup 411 route startup ord...',1),(10546,'jar 155 externalize dynamic parts 161 file copy example 157–159 in multiple environments 161–166 reusable unit test 162integration test 182–185notifybuilder 185–187 message ordering 174expects 175 expectsascending 174 expectsdescending 174 gap detect...',1),(10547,'infoindex 515testing (continued) expectation 167 expectedbodiesreceived168, 170 expectedmessagecount168–169 expectedminimummessagecount 168 expression-based methods 171 getreceivedexchanges 171 message 172 regular expression 173 setresultwaittime 169...',1),(10548,'infoindex516transaction (continued) rollback 289, 291, 298, 300, 304, 306–307 return custom response 306 routeconvention over configuration 292transacted 292 runtime environment agnostic 290 single resource 297 spring transactionjmstransactionmanager...',1),(10549,'0 support 210xxml object marshaling 75 serializing objects to and from xml 75–76 transforming 73–77 transforming using xslt 73 xpath 116with namespace 118 xml schema 211 @xpath 54, 116, 223, 286 xpath 45, 50, 223 @xquery 116 xquery 45 xslt, loading s...',1);
/*!40000 ALTER TABLE `sentences` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2015-01-05 22:19:18
